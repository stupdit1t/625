{"meta":{"title":"625's blog","subtitle":"每天砍点柴","description":"求知若渴，虚心若愚","author":625,"url":"https://kanchai.club","root":"/"},"pages":[],"posts":[{"title":"PC列表通用排序功能","slug":"通用列表排序实现","date":"2020-03-17T15:18:40.963Z","updated":"2020-03-17T14:39:16.000Z","comments":true,"path":"2020/03/17/通用列表排序实现/","link":"","permalink":"https://kanchai.club/2020/03/17/%E9%80%9A%E7%94%A8%E5%88%97%E8%A1%A8%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"之前做过好多外包都没写过排序的实现，这次发现同事写的有问题，所以手动实现一个。不知是否有用。直接上代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168/** * 给表的排序字段排序 * * @author: 李涛 * @version: 2019年07月17日 16:51 */@Api(tags = \"给列表排序\")@RestController@RequestMapping(\"/common/sort\")@Validatedpublic class SortTableController &#123; @Autowired private ICommonSV commonSV; /** * 拖拽标志对应的表和字段 */ private static final Map&lt;String, String&gt; tables = new HashMap&lt;&gt;(); /** * 拖拽标志对应的表和字段 */ private static final Map&lt;String, String&gt; tablesWhere = new HashMap&lt;&gt;(); static &#123; // 表名 tables.put(\"app_banner\", \"sort_num\"); tables.put(\"app_health_plate\", \"sort_num\"); tables.put(\"app_start_page\", \"sort_num\"); tables.put(\"clinic_manual\", \"sort\"); tables.put(\"sys_menu\", \"menu_order\"); tables.put(\"nav_dept_adv\", \"sort_num\"); // 排序条件 tablesWhere.put(\"sys_menu\", \"and parent_id = #&#123;params.p0&#125;\"); tablesWhere.put(\"clinic_manual\", \"and deleted !='01' \"); &#125; @Log @ApiOperation(\"排序\") @ApiImplicitParams(&#123; @ApiImplicitParam(value = \"拖拽标志(nav_doctor_infor,nav_popu_dept_infor,nav_quick_entry_infor)\", name = \"tableName\", paramType = \"form\"), @ApiImplicitParam(value = \"上\", name = \"top\", paramType = \"form\"), @ApiImplicitParam(value = \"中\", name = \"mid\", paramType = \"form\"), @ApiImplicitParam(value = \"下\", name = \"bottom\", paramType = \"form\"), @ApiImplicitParam(value = \"条件\", name = \"whereCase\", paramType = \"form\"), &#125;) @Transactional @PostMapping(\"/sortTable\") public APIResponse sortTable( @NotNull String tableName, Long top, @NotNull Long mid, Long bottom, String[] whereCase ) &#123; String sort = tables.get(tableName); if (StringUtils.isBlank(sort)) &#123; throw new UnsupportedOperationException(); &#125; Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); //根据上下判定是上移还是下移 Boolean down = null; Long midSort = null; Long topSort = null; Long bottomSort = null; if (top == null) &#123; down = false; &#125; else if (bottom == null) &#123; down = true; &#125; else &#123; midSort = findSort(mid, tableName); topSort = findSort(top, tableName); bottomSort = findSort(bottom, tableName); down = midSort &gt; topSort &amp;&amp; midSort &gt; bottomSort; &#125; // 执行更新操作 String updateSql = null; if (down) &#123; if (topSort == null) &#123; topSort = findSort(top, tableName); &#125; List&lt;Long&gt; ids = findIds(top, mid, tableName, whereCase, \"first\"); if (ids.isEmpty()) &#123; return APIResponseBuilder.successNoData(); &#125; updateSql = \"update \" + tableName + \" set \" + sort + \" = \" + sort + \" + 1 where id in ( \" + StringUtils.join(ids, \",\") + \" )\"; commonSV.updateByParams(updateSql, params); params.put(\"newSort\", topSort); params.put(\"id\", mid); updateSql = \"update \" + tableName + \" set \" + sort + \" = #&#123;params.newSort&#125; where id = #&#123;params.id&#125; \"; commonSV.updateByParams(updateSql, params); &#125; else if (!down) &#123; if (bottomSort == null) &#123; bottomSort = findSort(bottom, tableName); &#125; List&lt;Long&gt; ids = findIds(mid, bottom, tableName, whereCase, \"last\"); if (ids.isEmpty()) &#123; return APIResponseBuilder.successNoData(); &#125; updateSql = \"update \" + tableName + \" set \" + sort + \" = \" + sort + \" - 1 where id in ( \" + StringUtils.join(ids, \",\") + \" )\"; commonSV.updateByParams(updateSql, params); params.put(\"newSort\", bottomSort); params.put(\"id\", mid); updateSql = \"update \" + tableName + \" set \" + sort + \" = #&#123;params.newSort&#125; where id = #&#123;params.id&#125; \"; commonSV.updateByParams(updateSql, params); &#125; return APIResponseBuilder.successNoDataWithMsg(\"排序成功!\"); &#125; /** * 查询两个ID之间的ID有哪些 * * @param startId * @param endId * @param tableName * @param whereCase * @param removeTag * @return */ private List&lt;Long&gt; findIds(Long startId, Long endId, String tableName, String[] whereCase, String removeTag) &#123; String sort = tables.get(tableName); String sql = \" select id \" + \" from \" + tableName + \" \" + \" where \" + sort + \" &gt;= (select \" + sort + \" from \" + tableName + \" where id = #&#123;params.startId&#125;) \" + \" and \" + sort + \" &lt;= (select \" + sort + \" from \" + tableName + \" where id = #&#123;params.endId&#125;) \"; String whereCaseStr = tablesWhere.get(tableName); if (whereCaseStr != null) &#123; sql += whereCaseStr; &#125; sql += \" order by \" + sort + \" desc \"; Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); params.put(\"startId\", startId); params.put(\"endId\", endId); if (whereCase != null &amp;&amp; whereCase.length &gt; 0) &#123; for (int i = 0; i &lt; whereCase.length; i++) &#123; params.put(\"p\" + i, whereCase[i]); &#125; &#125; List&lt;JSONObject&gt; longs = commonSV.queryListJSONObject(sql, params); if (StringUtils.isNotBlank(removeTag) &amp;&amp; !longs.isEmpty()) &#123; if (\"last\".equals(removeTag)) &#123; longs.remove(longs.size() - 1); &#125; else if (\"first\".equals(removeTag)) &#123; longs.remove(0); &#125; &#125; return longs.stream().map(n -&gt; n.getLong(\"id\")).collect(Collectors.toList()); &#125; /** * 根据ID查询序号 * * @param id * @param tableName * @return */ private Long findSort(Long id, String tableName) &#123; if (id == null) &#123; return null; &#125; String sql = \" select \" + tables.get(tableName) + \" from \" + tableName + \" where id = #&#123;params.id&#125;\"; Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); params.put(\"id\", id); Number sortNum = commonSV.selectField(sql, params, Number.class); return sortNum.longValue(); &#125;&#125;","categories":[{"name":"轮子","slug":"轮子","permalink":"https://kanchai.club/categories/%E8%BD%AE%E5%AD%90/"}],"tags":[{"name":"轮子","slug":"轮子","permalink":"https://kanchai.club/tags/%E8%BD%AE%E5%AD%90/"}]},{"title":"SpringBoot中Mybatis枚举翻译插件实现","slug":"Mybatis插件实现,实现数据库枚举字段翻译为中文插件","date":"2020-03-17T15:18:40.843Z","updated":"2020-03-17T15:17:29.000Z","comments":true,"path":"2020/03/17/Mybatis插件实现,实现数据库枚举字段翻译为中文插件/","link":"","permalink":"https://kanchai.club/2020/03/17/Mybatis%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0,%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%9A%E4%B8%BE%E5%AD%97%E6%AE%B5%E7%BF%BB%E8%AF%91%E4%B8%BA%E4%B8%AD%E6%96%87%E6%8F%92%E4%BB%B6/","excerpt":"开发目的新项目中类似状态值都是使用数据库的KEY:VALUE替代的.发现同事都是每次都是自己去数据库查出来,然后循环对比值…","text":"开发目的新项目中类似状态值都是使用数据库的KEY:VALUE替代的.发现同事都是每次都是自己去数据库查出来,然后循环对比值… 开发目的 新项目中类似状态值都是使用数据库的KEY:VALUE替代的.发现同事都是每次都是自己去数据库查出来,然后循环对比值.或者是给前端提供枚举查询接口,然后前端遍历.非常麻烦.所以使用Mybatis插件替代这个重复性工作.开发完毕后,发现Mybatis有类型转换器,但是和项目现在的现象出入挺大.以下介绍以下插件的开发.之后还发现和PageHepler冲突,修复了一番. 插件配置到spring容器中 此处有点坑,起初按照容器初始化加入到容器的方式.但是与Springboot的Mybatis的PagerHepler的starter顺序不好控制.导致插件的加载顺序不一致.由于分页插件的拦截顺序严格控制.如果拦截相同的地方就会导致分页插件总计失效.所以采用以下方式,采用容器启动后,加入到Mybatis拦截中的最后一个位置: 123456789101112131415161718192021/** * 配置枚举翻译插件 * * @author: 李涛 * @version: 2019年04月28日 15:23 */@Componentpublic class MybatisPluginConfig implements ApplicationRunner &#123; @Autowired private List&lt;SqlSessionFactory&gt; sqlSessionFactoryList; @Override public void run(ApplicationArguments args) throws Exception &#123; Iterator var3 = this.sqlSessionFactoryList.iterator(); while (var3.hasNext()) &#123; SqlSessionFactory sqlSessionFactory = (SqlSessionFactory) var3.next(); sqlSessionFactory.getConfiguration().addInterceptor(new MyBatisEnumHandlePlugin()); &#125; &#125;&#125; 插件开发代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/** * 处理枚举字段 * * @author: 李涛 * @version: 2019年04月28日 14:57 */@Intercepts(&#123; @Signature(type = ResultSetHandler.class, method = \"handleResultSets\", args = Statement.class)&#125;)public class MyBatisEnumHandlePlugin implements Interceptor &#123; @Override public Object intercept(Invocation invocation) throws Throwable &#123; DefaultResultSetHandler statementHandler = (DefaultResultSetHandler) invocation.getTarget(); Object proceed = invocation.proceed(); if (proceed instanceof List) &#123; List data = (List) proceed; if (data == null || data.isEmpty()) &#123; return proceed; &#125; // 对第一个对象进行分析 List&lt;Map&lt;String, Object&gt;&gt; translationInformation = getTranslationInformation(data.get(0).getClass()); // 如果没有字典标识,直接返回 if (translationInformation.isEmpty()) &#123; return proceed; &#125; // 遍历结果进行设置翻译值 for (Object datum : data) &#123; for (Map&lt;String, Object&gt; info : translationInformation) &#123; Field readField = (Field) info.get(\"read\"); Field writeField = (Field) info.get(\"write\"); Map dictValues = (Map) info.get(\"value\"); FieldUtils.writeField(writeField, datum, dictValues.get(readField.get(datum)), true); &#125; &#125; return data; &#125; return proceed; &#125; @Override public Object plugin(Object o) &#123; return Plugin.wrap(o, this); &#125; @Override public void setProperties(Properties properties) &#123; &#125; /** * 通过类,获取需要翻译的字段信息 * * @param cls * @return */ private List&lt;Map&lt;String, Object&gt;&gt; getTranslationInformation(Class&lt;?&gt; cls) &#123; // 查询字典值service ISysDictSV sysDictSV = SpringUtil.getObject(ISysDictSV.class); List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;&gt;(); List&lt;DictField&gt; dicts = new ArrayList&lt;&gt;(); getAllDictAnnotation(cls, dicts); if (dicts.isEmpty()) &#123; return list; &#125; // 开始填充Field for (DictField dictField : dicts) &#123; if (dictField.enumClass().equals(DictEnum.class)) &#123; // 如果是父类枚举直接返回 continue; &#125; // 字典读写翻译信息存储 Map&lt;String, Object&gt; fieldInfo = new HashMap&lt;&gt;(); String toField = dictField.to(); if (\"\".equals(toField)) &#123; //如果没有设置，默认为From()+Name toField = dictField.from() + \"Name\"; &#125; Field readField = FieldUtils.getField(cls, dictField.from(), true); Field writeField = FieldUtils.getField(cls, toField, true); Map dictValues = sysDictSV.getDictValues(dictField.enumClass(), dictField.codeType()); if (readField == null || writeField == null || dictValues == null) &#123; continue; &#125; fieldInfo.put(\"read\", readField); fieldInfo.put(\"write\", writeField); fieldInfo.put(\"value\", dictValues); list.add(fieldInfo); &#125; return list; &#125; /** * 获取所有的字典注解 * * @param cls 类信息 * @param fields 存放值 */ private void getAllDictAnnotation(Class&lt;?&gt; cls, List&lt;DictField&gt; fields) &#123; DictEntity annotation = cls.getAnnotation(DictEntity.class); // 加入注解 if (annotation != null) &#123; DictField[] value = annotation.value(); fields.addAll(Arrays.asList(value)); &#125; // 继续往上找 if (cls.getSuperclass() != null &amp;&amp; cls.getSuperclass() != BaseSearchModel.class &amp;&amp; cls.getSuperclass() != Object.class) &#123; getAllDictAnnotation(cls.getSuperclass(), fields); &#125; &#125;&#125; 枚举翻译注解1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 标识是一个含有数据字典的实体 * * @author: 李涛 * @version: 2019年04月28日 12:30 */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface DictEntity &#123; DictField[] value();&#125;/** * 标识是一个含有数据字典的实体 * * @author: 李涛 * @version: 2019年04月28日 12:30 */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Repeatable(value = DictEntity.class)public @interface DictField &#123; /** * 要翻译的字段名称 */ String from(); /** * 翻译到哪个字段.默认为from()+Name,可以自定义 */ String to() default \"\"; /** * 枚举类 */ Class&lt;? extends DictEnum&gt; enumClass(); /** * code类型 */ Class codeType() default String.class;&#125;","categories":[{"name":"轮子","slug":"轮子","permalink":"https://kanchai.club/categories/%E8%BD%AE%E5%AD%90/"}],"tags":[{"name":"轮子","slug":"轮子","permalink":"https://kanchai.club/tags/%E8%BD%AE%E5%AD%90/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://kanchai.club/tags/Mybatis/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-03-16T03:15:41.997Z","updated":"2020-03-16T03:15:41.997Z","comments":true,"path":"2020/03/16/hello-world/","link":"","permalink":"https://kanchai.club/2020/03/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}