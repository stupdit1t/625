<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>每天拾柴火</title>
  
  <subtitle>砍柴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kanchai.club/"/>
  <updated>2020-11-12T08:21:13.000Z</updated>
  <id>https://kanchai.club/</id>
  
  <author>
    <name>625</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mysql通篇回顾</title>
    <link href="https://kanchai.club/2020/11/12/Mysql%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE/"/>
    <id>https://kanchai.club/2020/11/12/Mysql%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE/</id>
    <published>2020-11-12T08:21:26.258Z</published>
    <updated>2020-11-12T08:21:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB 是 MySQL 默认的事务型存储引擎，只要在需要它不支持的特性时，才考虑使用其他存储引擎。</p><p>InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准隔离级别(未提交读、提交读、可重复读、可串行化)。其默认级别时可重复读（REPEATABLE READ），在可重复读级别下，通过 MVCC + Next-Key Locking 防止幻读。</p><p>主索引时聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对主键查询有很高的性能。</p><p>InnoDB 内部做了很多优化，包括从磁盘读取数据时采用的可预测性读，能够自动在内存中创建 hash 索引以加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓冲区等。</p><p>InnoDB 支持真正的在线热备份，MySQL 其他的存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合的场景中，停止写入可能也意味着停止读取。</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p><p>提供了大量的特性，包括压缩表、空间数据索引等。</p><p>不支持事务。</p><p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。</p><p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</p><p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p><h3 id="InnoDB-和-MyISAM-的比较"><a href="#InnoDB-和-MyISAM-的比较" class="headerlink" title="InnoDB 和 MyISAM 的比较"></a>InnoDB 和 MyISAM 的比较</h3><ul><li><p>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。  </p></li><li><p>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。  </p></li><li><p>外键：InnoDB 支持外键。  </p></li><li><p>备份：InnoDB 支持在线热备份。  </p></li><li><p>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。  </p></li><li><p>其它特性：MyISAM 支持压缩表和空间数据索引。  </p></li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="B-Tree-原理"><a href="#B-Tree-原理" class="headerlink" title="B+ Tree 原理"></a>B+ Tree 原理</h3><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>B Tree 指的是 Balance Tree，也就是平衡树，平衡树是一颗查找树，并且所有叶子节点位于同一层。</p><p>B+ Tree 是 B 树的一种变形，它是基于 B Tree 和叶子节点顺序访问指针进行实现，通常用于数据库和操作系统的文件系统中。</p><p>B+ 树有两种类型的节点：内部节点（也称索引节点）和叶子节点，内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存在叶子节点。</p><p>内部节点中的 key 都按照从小到大的顺序排列，对于内部节点中的一个 key，左子树中的所有 key 都小于它，右子树中的 key 都大于等于它，叶子节点的记录也是按照从小到大排列的。</p><p>每个叶子节点都存有相邻叶子节点的指针。</p><p><img src="https://pic4.zhimg.com/80/v2-4e4b732ccb930fedebdc20405ff8852f_720w.jpg" alt=""></p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>查找</p><p>查找以典型的方式进行，类似于二叉查找树。起始于根节点，自顶向下遍历树，选择其分离值在要查找值的任意一边的子指针。在节点内部典型的使用是二分查找来确定这个位置。</p><p>插入</p><ul><li><p>Perform a search to determine what bucket the new record should go into.  </p></li><li><p>If the bucket is not full(a most b - 1 entries after the insertion，b 是节点中的元素个数，一般是页的整数倍),add tht record.  </p></li><li><p>Otherwise,before inserting the new record  </p><ul><li><p>split the bucket.</p><ul><li><p>original node has 「(L+1)/2」items</p></li><li><p>new node has 「(L+1)/2」items</p></li></ul></li></ul></li></ul><ul><li><p>Move 「(L+1)/2」-th key to the parent,and insert the new node to the parent.</p></li><li><p>Repeat until a parent is found that need not split.</p></li></ul><ul><li>If the root splits,treat it as if it has an empty parent ans split as outline above.  </li></ul><p>B-trees grow as the root and not at the leaves.</p><p>删除</p><p>和插入类似，只不过是自下而上的合并操作。</p><h3 id="树的常见特性"><a href="#树的常见特性" class="headerlink" title="树的常见特性"></a>树的常见特性</h3><p>AVL 树</p><p>平衡二叉树，一般是用平衡因子差值决定并通过旋转来实现，左右子树树高差不超过1，那么和红黑树比较它是严格的平衡二叉树，平衡条件非常严格（树高差只有1），只要插入或删除不满足上面的条件就要通过旋转来保持平衡。由于旋转是非常耗费时间的。所以 AVL 树适用于插入/删除次数比较少，但查找多的场景。</p><p>红黑树</p><p>通过对从根节点到叶子节点路径上各个节点的颜色进行约束，确保没有一条路径会比其他路径长2倍，因而是近似平衡的。所以相对于严格要求平衡的AVL树来说，它的旋转保持平衡次数较少。适合，查找少，插入/删除次数多的场景。（现在部分场景使用跳表来替换红黑树，可搜索“为啥 redis 使用跳表(skiplist)而不是使用 red-black？”）</p><p>B/B+ 树</p><p>多路查找树，出度高，磁盘IO低，一般用于数据库系统中。</p><h3 id="B-树与红黑树的比较"><a href="#B-树与红黑树的比较" class="headerlink" title="B + 树与红黑树的比较"></a>B + 树与红黑树的比较</h3><p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：</p><p>（一）磁盘 IO 次数</p><p>B+ 树一个节点可以存储多个元素，相对于红黑树的树高更低，磁盘 IO 次数更少。</p><p>（二）磁盘预读特性</p><p>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道。每次会读取页的整数倍。</p><p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。</p><h3 id="B-树与-B-树的比较"><a href="#B-树与-B-树的比较" class="headerlink" title="B + 树与 B 树的比较"></a>B + 树与 B 树的比较</h3><p>B+ 树的磁盘 IO 更低</p><p>B+ 树的内部节点并没有指向关键字具体信息的指针。因此其内部节点相对 B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p><p>B+ 树的查询效率更加稳定</p><p>由于非叶子结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p><p>B+ 树元素遍历效率高</p><p>B 树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而 B 树不支持这样的操作（或者说效率太低）。</p><h2 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h2><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p><h3 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B+ Tree 索引"></a>B+ Tree 索引</h3><p>是大多数 MySQL 存储引擎的默认索引类型。</p><ul><li><p>因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。  </p></li><li><p>因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。  </p></li><li><p>可以指定多个列作为索引列，多个索引列共同组成键。  </p></li><li><p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。  </p></li></ul><p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p><p><img src="https://pic2.zhimg.com/80/v2-16a8457329925b26ddd84ecf862540f1_720w.jpg" alt=""></p><p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找，这个过程也被称作回表。</p><p><img src="https://pic2.zhimg.com/80/v2-ed26c40a16d6cceb50617b7f2bf9e1d5_720w.jpg" alt=""></p><h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p><ul><li><p>无法用于排序与分组；</p></li><li><p>只支持精确查找，无法用于部分查找和范围查找。</p></li></ul><p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p><p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p><p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p><p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p><h3 id="空间数据索引"><a href="#空间数据索引" class="headerlink" title="空间数据索引"></a>空间数据索引</h3><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p><p>必须使用 GIS 相关的函数来维护数据。</p><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h3 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h3><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p><p>例如下面的查询不能使用 actor_id 列的索引：</p><p>SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;</p><h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p><p>SELECT film_id, actor_ id FROM sakila.film_actor<br>WHERE actor_id = 1 AND film_id = 1;</p><h3 id="索引列的顺序"><a href="#索引列的顺序" class="headerlink" title="索引列的顺序"></a>索引列的顺序</h3><p>让选择性最强的索引列放在前面。</p><p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p><p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p><p>SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,<br>COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,<br>COUNT(*)<br>FROM payment;</p><p>   staff_id_selectivity: 0.0001<br>customer_id_selectivity: 0.0373<br>               COUNT(*): 16049</p><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p><p>前缀长度的选取需要根据索引选择性来确定。</p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>索引包含所有需要查询的字段的值。</p><p>具有以下优点：</p><ul><li><p>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</p></li><li><p>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</p></li><li><p>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</p></li></ul><h2 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h2><ul><li><p>大大减少了服务器需要扫描的数据行数。  </p></li><li><p>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。  </p></li><li><p>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。  </p></li></ul><h2 id="索引的使用条件"><a href="#索引的使用条件" class="headerlink" title="索引的使用条件"></a>索引的使用条件</h2><ul><li><p>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；  </p></li><li><p>对于中到大型的表，索引就非常有效；  </p></li><li><p>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。  </p></li></ul><blockquote><p>为什么对于非常小的表，大部分情况下简单的全表扫描比建立索引更高效？<br>如果一个表比较小，那么显然直接遍历表比走索引要快（因为需要回表）。<br>注：首先，要注意这个答案隐含的条件是查询的数据不是索引的构成部分，否也不需要回表操作。其次，查询条件也不是主键，否则可以直接从聚簇索引中拿到数据。  </p></blockquote><h2 id="查询性能优化"><a href="#查询性能优化" class="headerlink" title="查询性能优化"></a>查询性能优化</h2><h3 id="使用-explain-分析-select-查询语句"><a href="#使用-explain-分析-select-查询语句" class="headerlink" title="使用 explain 分析 select 查询语句"></a>使用 explain 分析 select 查询语句</h3><blockquote><p>explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。  </p></blockquote><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>常用的有 SIMPLE 简单查询，UNION 联合查询，SUBQUERY 子查询等。</p><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>要查询的表</p><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><blockquote><p>The possible indexes to choose  </p></blockquote><p>可选择的索引</p><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><blockquote><p>The index actually chosen  </p></blockquote><p>实际使用的索引</p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><blockquote><p>Estimate of rows to be examined  </p></blockquote><p>扫描的行数</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>索引查询类型，经常用到的索引查询类型：</p><p>const：使用主键或者唯一索引进行查询的时候只有一行匹配 ref：使用非唯一索引 range：使用主键、单个字段的辅助索引、多个字段的辅助索引的最后一个字段进行范围查询 index：和all的区别是扫描的是索引树 all：扫描全表：</p><h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><p>触发条件：表只有一行，这是一个 const type 的特殊情况</p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>触发条件：在使用主键或者唯一索引进行查询的时候只有一行匹配。</p><p>SELECT * FROM tbl_name WHERE primary_key=1;</p><p>SELECT * FROM tbl_name<br>  WHERE primary_key_part1=1 AND primary_key_part2=2;</p><p><img src="https://pic1.zhimg.com/80/v2-e2689c04282719b7f564c9c9e864a554_720w.jpg" alt=""></p><h3 id="eq-ref"><a href="#eq-ref" class="headerlink" title="eq_ref"></a>eq_ref</h3><p>触发条件：在进行联接查询的，使用主键或者唯一索引并且只匹配到一行记录的时候</p><p>SELECT * FROM ref_table,other_table<br>  WHERE ref_table.key_column=other_table.column;</p><p>SELECT * FROM ref_table,other_table<br>  WHERE ref_table.key_column_part1=other_table.column<br>  AND ref_table.key_column_part2=1;</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>触发条件：使用非唯一索引</p><p>SELECT * FROM ref_table WHERE key_column=expr;</p><p>SELECT * FROM ref_table,other_table<br>  WHERE ref_table.key_column=other_table.column;</p><p>SELECT * FROM ref_table,other_table<br>  WHERE ref_table.key_column_part1=other_table.column<br>  AND ref_table.key_column_part2=1;</p><p><img src="https://pic2.zhimg.com/80/v2-2ccf160966db1eb1da111695a47378b9_720w.jpeg" alt=""></p><h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>触发条件：只有在使用主键、单个字段的辅助索引、多个字段的辅助索引的最后一个字段进行范围查询才是 range</p><p>SELECT * FROM tbl_name<br>  WHERE key_column = 10;</p><p>SELECT * FROM tbl_name<br>  WHERE key_column BETWEEN 10 and 20;</p><p>SELECT * FROM tbl_name<br>  WHERE key_column IN (10,20,30);</p><p>SELECT * FROM tbl_name<br>  WHERE key_part1 = 10 AND key_part2 IN (10,20,30);</p><p><img src="https://pic4.zhimg.com/80/v2-5b5932436d1f01ad31cdd357b378c9a3_720w.jpg" alt=""></p><h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><blockquote><p>The index join type is the same as ALL, except that the index tree is scanned. This occurs two ways:  </p></blockquote><p>触发条件：</p><p>只扫描索引树</p><p>1）查询的字段是索引的一部分，覆盖索引。 2）使用主键进行排序</p><p><img src="https://pic3.zhimg.com/80/v2-4a4806bff08adef626e456dac94b54e2_720w.jpg" alt=""></p><h3 id="all"><a href="#all" class="headerlink" title="all"></a>all</h3><p>触发条件：全表扫描，不走索引</p><h2 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h2><h3 id="减少请求的数据量"><a href="#减少请求的数据量" class="headerlink" title="减少请求的数据量"></a>减少请求的数据量</h3><ul><li><p>只返回必要的列：最好不要使用 SELECT * 语句。</p></li><li><p>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</p></li><li><p>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</p></li></ul><h3 id="减少服务器端扫描的行数"><a href="#减少服务器端扫描的行数" class="headerlink" title="减少服务器端扫描的行数"></a>减少服务器端扫描的行数</h3><p>最有效的方式是使用索引来覆盖查询。</p><h2 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h2><h3 id="切分大查询"><a href="#切分大查询" class="headerlink" title="切分大查询"></a>切分大查询</h3><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p><p>DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH);</p><p>rows_affected = 0<br>do {<br>    rows_affected = do_query(<br>    “DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000”)<br>} while rows_affected &gt; 0</p><h3 id="分解大连接查询"><a href="#分解大连接查询" class="headerlink" title="分解大连接查询"></a>分解大连接查询</h3><p>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：</p><ul><li><p>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</p></li><li><p>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</p></li><li><p>减少锁竞争；</p></li><li><p>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</p><ul><li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li></ul></li></ul><p>SELECT * FROM tag<br>JOIN tag_post ON tag_post.tag_id=tag.id<br>JOIN post ON tag_post.post_id=post.id<br>WHERE tag.tag=’mysql’;</p><p>SELECT * FROM tag WHERE tag=’mysql’;<br>SELECT * FROM tag_post WHERE tag_id=1234;<br>SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是指满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><p>事务最基本的莫过于 ACID 四个特性了，这四个特性分别是：</p><ul><li><p>Atomicity：原子性</p></li><li><p>Consistency：一致性</p></li><li><p>Isolation：隔离性</p></li><li><p>Durability：持久性</p></li></ul><p>原子性</p><p>事务被视为不可分割的最小单元，事务的所有操作要么全部成功，要么全部失败回滚。</p><p>一致性</p><p>数据库在事务执行前后都保持一致性状态，在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p><p>隔离性</p><p>一个事务所做的修改在最终提交以前，对其他事务是不可见的。</p><p>持久性</p><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢。</p><h2 id="ACID-之间的关系"><a href="#ACID-之间的关系" class="headerlink" title="ACID 之间的关系"></a>ACID 之间的关系</h2><p>事务的 ACID 特性概念很简单，但不好理解，主要是因为这几个特性不是一种平级关系：</p><ul><li><p>只有满足一致性，事务的结果才是正确的。</p></li><li><p>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</p></li><li><p>事务满足持久化是为了能应对数据库崩溃的情况。</p></li></ul><p><img src="https://pic4.zhimg.com/80/v2-48a95374d5c88247a4ed19569e250b7f_720w.jpg" alt=""></p><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>未提交读（READ UNCOMMITTED）</p><p>事务中的修改，即使没有提交，对其他事务也是可见的。</p><p>提交读（READ COMMITTED）</p><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其他事务是不可见的。</p><p>可重复读（REPEATABLE READ）</p><p>保证在同一个事务中多次读取同样数据的结果是一样的。</p><p>可串行化（SERIALIZABLE）</p><p>强制事务串行执行。</p><p>需要加锁实现，而其它隔离级别通常不需要。</p><p>ble data-draft-node=”block” data-draft-type=”table” data-size=”normal” data-row-style=”normal”&gt;</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>锁是数据库系统区别于文件系统的一个关键特性。锁机制用于管理对共享资源的并发访问。</p><h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><p>共享锁（S Lock）</p><p>允许事务读一行数据</p><p>排他锁（X Lock）</p><p>允许事务删除或者更新一行数据</p><p>意向共享锁（IS Lock）</p><p>事务想要获得一张表中某几行的共享锁</p><p>意向排他锁</p><p>事务想要获得一张表中某几行的排他锁</p><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>版本号</p><ul><li><p>系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</p></li><li><p>事务版本号：事务开始时的系统版本号。</p></li></ul><p>隐藏的列</p><p>MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：</p><ul><li><p>创建版本号：指示创建一个数据行的快照时的系统版本号；</p></li><li><p>删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。</p></li></ul><p>Undo 日志</p><p>MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。</p><p><img src="https://pic2.zhimg.com/80/v2-26ed1887aa929f82cce060accf1c232d_720w.jpg" alt=""></p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>以下实现过程针对可重复读隔离级别。</p><p>当开始一个事务时，该事务的版本号肯定大于当前所有数据行快照的创建版本号，理解这一点很关键。数据行快照的创建版本号是创建数据行快照时的系统版本号，系统版本号随着创建事务而递增，因此新创建一个事务时，这个事务的系统版本号比之前的系统版本号都大，也就是比所有数据行快照的创建版本号都大。</p><p>SELECT</p><p>多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。</p><p>把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于等于 T 的版本号，因为如果大于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。除此之外，T 所要读取的数据行快照的删除版本号必须是未定义或者大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。</p><p>INSERT</p><p>将当前系统版本号作为数据行快照的创建版本号。</p><p>DELETE</p><p>将当前系统版本号作为数据行快照的删除版本号。</p><p>UPDATE</p><p>将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。</p><h3 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h3><p>在可重复读级别中，通过MVCC机制，虽然让数据变得可重复读，但我们读到的数据可能是历史数据，是不及时的数据，不是数据库当前的数据！这在一些对于数据的时效特别敏感的业务中，就很可能出问题。</p><p>对于这种读取历史数据的方式，我们叫它快照读 (snapshot read)，而读取数据库当前版本数据的方式，叫当前读 (current read)。很显然，在MVCC中：</p><p>快照读</p><p>MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。</p><p>select * from table ….;</p><p>当前读</p><p>MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。</p><p>INSERT;<br>UPDATE;<br>DELETE;</p><p>在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。</p><p>- select * from table where ? lock in share mode;</p><ul><li>select * from table where ? for update;</li></ul><p>事务的隔离级别实际上都是定义的当前读的级别，MySQL为了减少锁处理（包括等待其它锁）的时间，提升并发能力，引入了快照读的概念，使得select不用加锁。而update、insert这些“当前读”的隔离性，就需要通过加锁来实现了。</p><h2 id="锁算法"><a href="#锁算法" class="headerlink" title="锁算法"></a>锁算法</h2><h3 id="Record-Lock"><a href="#Record-Lock" class="headerlink" title="Record Lock"></a>Record Lock</h3><p>锁定一个记录上的索引，而不是记录本身。</p><p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p><h3 id="Gap-Lock"><a href="#Gap-Lock" class="headerlink" title="Gap Lock"></a>Gap Lock</h3><p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p><p>SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;</p><h3 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h3><p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p><p>(-∞, 10]<br>(10, 11]<br>(11, 13]<br>(13, 20]<br>(20, +∞)</p><blockquote><p>在 InnoDB 存储引擎中，SELECT 操作的不可重复读问题通过 MVCC 得到了解决，而 UPDATE、DELETE 的不可重复读问题通过 Record Lock 解决，INSERT 的不可重复读问题是通过 Next-Key Lock（Record Lock + Gap Lock）解决的。  </p></blockquote><h2 id="锁问题"><a href="#锁问题" class="headerlink" title="锁问题"></a>锁问题</h2><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>脏读指的是不同事务下，当前事务可以读取到另外事务未提交的数据。</p><p>例如：</p><p>T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p><p><img src="https://pic4.zhimg.com/80/v2-45bc5159953e5e31a1beff831889030b_720w.jpg" alt=""></p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>不可重复读指的是同一事务内多次读取同一数据集合，读取到的数据是不一样的情况。</p><p>例如：</p><p>T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><p><img src="https://pic2.zhimg.com/80/v2-3ba664819013c01ae1b5712e2ee5375d_720w.jpg" alt=""></p><p>在 InnoDB 存储引擎中，SELECT 操作的不可重复读问题通过 MVCC 得到了解决，而 UPDATE、DELETE 的不可重复读问题是通过 Record Lock 解决的，INSERT 的不可重复读问题是通过 Next-Key Lock（Record Lock + Gap Lock）解决的。</p><h3 id="Phantom-Proble（幻影读）"><a href="#Phantom-Proble（幻影读）" class="headerlink" title="Phantom Proble（幻影读）"></a>Phantom Proble（幻影读）</h3><blockquote><p>The so-called phantom problem occurs within a transaction when the same query produces different sets of rows at different times. For example, if a SELECT is executed twice, but returns a row the second time that was not returned the first time, the row is a “phantom” row.  </p></blockquote><p>Phantom Proble 是指在同一事务下，连续执行两次同样的 sql 语句可能返回不同的结果，第二次的 sql 语句可能会返回之前不存在的行。</p><p>幻影读是一种特殊的不可重复读问题。</p><h3 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h3><p>一个事务的更新操作会被另一个事务的更新操作所覆盖。</p><p>例如：</p><p>T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p><p><img src="https://pic1.zhimg.com/80/v2-21808e8e2b9a88c0648e264b4914fb24_720w.jpg" alt=""></p><p>这类型问题可以通过给 SELECT 操作加上排他锁来解决，不过这可能会引入性能问题，具体使用要视业务场景而定。</p><h2 id="分库分表数据切分"><a href="#分库分表数据切分" class="headerlink" title="分库分表数据切分"></a>分库分表数据切分</h2><h3 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h3><p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。</p><p>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p><p><img src="https://pic2.zhimg.com/80/v2-a6c9ecaad9ef9439fe1dda307aa40f65_720w.jpg" alt=""></p><h3 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h3><p>垂直切分是将一张表按列分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直气氛将经常被使用的列喝不经常被使用的列切分到不同的表中。</p><p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不通的库中，例如将原来电商数据部署库垂直切分称商品数据库、用户数据库等。</p><p><img src="https://pic1.zhimg.com/80/v2-e88499e975a2b10130106db63007f268_720w.jpg" alt=""></p><h3 id="Sharding-策略"><a href="#Sharding-策略" class="headerlink" title="Sharding 策略"></a>Sharding 策略</h3><ul><li><p>哈希取模：hash(key)%N</p></li><li><p>范围：可以是 ID 范围也可以是时间范围</p></li><li><p>映射表：使用单独的一个数据库来存储映射关系</p></li></ul><h3 id="Sharding-存在的问题"><a href="#Sharding-存在的问题" class="headerlink" title="Sharding 存在的问题"></a>Sharding 存在的问题</h3><p>事务问题</p><p>使用分布式事务来解决，比如 XA 接口</p><p>连接</p><p>可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。</p><p>唯一性</p><ul><li><p>使用全局唯一 ID （GUID）</p></li><li><p>为每个分片指定一个 ID 范围</p></li><li><p>分布式 ID 生成器（如 Twitter 的 Snowflake 算法）</p></li></ul><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p><ul><li><p>binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。</p></li><li><p>I/O 线程 ：负责从主服务器上读取- 二进制日志，并写入从服务器的中继日志（Relay log）。</p></li><li><p>SQL 线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</p></li></ul><p><img src="https://pic3.zhimg.com/80/v2-9f7a2dbcb62f5720cff38407e1f85c82_720w.jpg" alt=""></p><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p><p>读写分离能提高性能的原因在于：</p><ul><li><p>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</p></li><li><p>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</p></li><li><p>增加冗余，提高可用性。</p></li></ul><p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p><p><img src="https://pic3.zhimg.com/80/v2-9786e5aa2a6e5f4e3ac514b55825e40e_720w.jpg" alt=""></p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><blockquote><p>在实际业务中经常会使用到 JSON 数据类型，在查询过程中主要有两种使用需求：  </p></blockquote><ol><li><p>在 where 条件中有通过 json 中的某个字段去过滤返回结果的需求</p></li><li><p>查询 json 字段中的部分字段作为返回结果（减少内存占用）</p></li></ol><h3 id="JSON-CONTAINS"><a href="#JSON-CONTAINS" class="headerlink" title="JSON_CONTAINS"></a>JSON_CONTAINS</h3><p>JSON_CONTAINS(target, candidate[, path])</p><p>如果在 json 字段 target 指定的位置 path，找到了目标值 condidate，返回 1，否则返回 0</p><p>如果只是检查在指定的路径是否存在数据，使用JSON_CONTAINS_PATH()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET \@j &#x3D; &#39;\&#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: \&#123;&quot;d&quot;: 4\&#125;\&#125;&#39;;</span><br><span class="line">mysql&gt; SET \@j2 &#x3D; &#39;1&#39;;</span><br><span class="line">mysql&gt; SELECT JSON\_CONTAINS\(\@j, \@j2, &#39;\$.a&#39;\);</span><br><span class="line">+-------------------------------+</span><br><span class="line">| JSON\_CONTAINS\(\@j, \@j2, &#39;\$.a&#39;\) |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|                             1 |</span><br><span class="line">+-------------------------------+</span><br><span class="line">mysql&gt; SELECT JSON\_CONTAINS\(\@j, \@j2, &#39;\$.b&#39;\);</span><br><span class="line">+-------------------------------+</span><br><span class="line">| JSON\_CONTAINS\(\@j, \@j2, &#39;\$.b&#39;\) |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|                             0 |</span><br><span class="line">+-------------------------------+</span><br><span class="line"></span><br><span class="line">mysql&gt; SET \@j2 &#x3D; &#39;\&#123;&quot;d&quot;: 4\&#125;&#39;;</span><br><span class="line">mysql&gt; SELECT JSON\_CONTAINS\(\@j, \@j2, &#39;\$.a&#39;\);</span><br><span class="line">+-------------------------------+</span><br><span class="line">| JSON\_CONTAINS\(\@j, \@j2, &#39;\$.a&#39;\) |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|                             0 |</span><br><span class="line">+-------------------------------+</span><br><span class="line">mysql&gt; SELECT JSON\_CONTAINS\(\@j, \@j2, &#39;\$.c&#39;\);</span><br><span class="line">+-------------------------------+</span><br><span class="line">| JSON\_CONTAINS\(\@j, \@j2, &#39;\$.c&#39;\) |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|                             1 |</span><br><span class="line">+-------------------------------+</span><br></pre></td></tr></table></figure><h3 id="JSON-CONTAINS-PATH"><a href="#JSON-CONTAINS-PATH" class="headerlink" title="JSON_CONTAINS_PATH"></a>JSON_CONTAINS_PATH</h3><p>JSON_CONTAINS_PATH(json_doc, one_or_all, path[, path] …)</p><p>如果在指定的路径存在数据返回 1，否则返回 0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET \@j &#x3D; &#39;\&#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: \&#123;&quot;d&quot;: 4\&#125;\&#125;&#39;;</span><br><span class="line">mysql&gt; SELECT JSON\_CONTAINS\_PATH\(\@j, &#39;one&#39;, &#39;\$.a&#39;, &#39;\$.e&#39;\);</span><br><span class="line">+---------------------------------------------+</span><br><span class="line">| JSON\_CONTAINS\_PATH\(\@j, &#39;one&#39;, &#39;\$.a&#39;, &#39;\$.e&#39;\) |</span><br><span class="line">+---------------------------------------------+</span><br><span class="line">|                                           1 |</span><br><span class="line">+---------------------------------------------+</span><br><span class="line">mysql&gt; SELECT JSON\_CONTAINS\_PATH\(\@j, &#39;all&#39;, &#39;\$.a&#39;, &#39;\$.e&#39;\);</span><br><span class="line">+---------------------------------------------+</span><br><span class="line">| JSON\_CONTAINS\_PATH\(\@j, &#39;all&#39;, &#39;\$.a&#39;, &#39;\$.e&#39;\) |</span><br><span class="line">+---------------------------------------------+</span><br><span class="line">|                                           0 |</span><br><span class="line">+---------------------------------------------+</span><br><span class="line">mysql&gt; SELECT JSON\_CONTAINS\_PATH\(\@j, &#39;one&#39;, &#39;\$.c.d&#39;\);</span><br><span class="line">+----------------------------------------+</span><br><span class="line">| JSON\_CONTAINS\_PATH\(\@j, &#39;one&#39;, &#39;\$.c.d&#39;\) |</span><br><span class="line">+----------------------------------------+</span><br><span class="line">|                                      1 |</span><br><span class="line">+----------------------------------------+</span><br><span class="line">mysql&gt; SELECT JSON\_CONTAINS\_PATH\(\@j, &#39;one&#39;, &#39;\$.a.d&#39;\);</span><br><span class="line">+----------------------------------------+</span><br><span class="line">| JSON\_CONTAINS\_PATH\(\@j, &#39;one&#39;, &#39;\$.a.d&#39;\) |</span><br><span class="line">+----------------------------------------+</span><br><span class="line">|                                      0 |</span><br><span class="line">+----------------------------------------+</span><br></pre></td></tr></table></figure><p>实际使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\$conds &#x3D; new Criteria\(\);</span><br><span class="line">\$conds-&gt;andWhere\(&#39;dept\_code&#39;, &#39;in&#39;, \$deptCodes\);</span><br><span class="line">if \(\!empty\(\$aoiAreaId\)\) \&#123;</span><br><span class="line">    \$aoiAreaIdCond &#x3D; new Criteria\(\);</span><br><span class="line">    \$aoiAreaIdCond-&gt;orWhere\(&quot;JSON\_CONTAINS\_PATH\(new\_aoi\_area\_ids,&#39;one&#39;, &#39;\$.\\&quot;\$aoiAreaId\\&quot;&#39;\)&quot;, &#39;&#x3D;&#39;, 1\);</span><br><span class="line">    \$aoiAreaIdCond-&gt;orWhere\(&quot;JSON\_CONTAINS\_PATH\(old\_aoi\_area\_ids,&#39;one&#39;, &#39;\$.\\&quot;\$aoiAreaId\\&quot;&#39;\)&quot;, &#39;&#x3D;&#39;, 1\);</span><br><span class="line">    \$conds-&gt;andWhere\(\$aoiAreaIdCond\);</span><br><span class="line">\&#125;</span><br></pre></td></tr></table></figure><h3 id="column-gt-path、column-gt-gt-path"><a href="#column-gt-path、column-gt-gt-path" class="headerlink" title="column-&gt;path、column-&gt;&gt;path"></a>column-&gt;path、column-&gt;&gt;path</h3><p>获取指定路径的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">\-&gt; vs \-&gt;&gt;</span><br><span class="line"></span><br><span class="line">Whereas the \-&gt; operator simply extracts a value, the \-&gt;&gt; operator in addition unquotes the extracted result.</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT \* FROM jemp WHERE g &gt; 2;</span><br><span class="line">+-------------------------------+------+</span><br><span class="line">| c                             | g    |</span><br><span class="line">+-------------------------------+------+</span><br><span class="line">| \&#123;&quot;id&quot;: &quot;3&quot;, &quot;name&quot;: &quot;Barney&quot;\&#125; |    3 |</span><br><span class="line">| \&#123;&quot;id&quot;: &quot;4&quot;, &quot;name&quot;: &quot;Betty&quot;\&#125;  |    4 |</span><br><span class="line">+-------------------------------+------+</span><br><span class="line">2 rows in set \(0.01 sec\)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT c-&gt;&#39;\$.name&#39; AS name</span><br><span class="line">    -&gt;     FROM jemp WHERE g &gt; 2;</span><br><span class="line">+----------+</span><br><span class="line">| name     |</span><br><span class="line">+----------+</span><br><span class="line">| &quot;Barney&quot; |</span><br><span class="line">| &quot;Betty&quot;  |</span><br><span class="line">+----------+</span><br><span class="line">2 rows in set \(0.00 sec\)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT JSON\_UNQUOTE\(c-&gt;&#39;\$.name&#39;\) AS name</span><br><span class="line">    -&gt;     FROM jemp WHERE g &gt; 2;</span><br><span class="line">+--------+</span><br><span class="line">| name   |</span><br><span class="line">+--------+</span><br><span class="line">| Barney |</span><br><span class="line">| Betty  |</span><br><span class="line">+--------+</span><br><span class="line">2 rows in set \(0.00 sec\)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT c-&gt;&gt;&#39;\$.name&#39; AS name</span><br><span class="line">    -&gt;     FROM jemp WHERE g &gt; 2;</span><br><span class="line">+--------+</span><br><span class="line">| name   |</span><br><span class="line">+--------+</span><br><span class="line">| Barney |</span><br><span class="line">| Betty  |</span><br><span class="line">+--------+</span><br><span class="line">2 rows in set \(0.00 sec\)</span><br></pre></td></tr></table></figure><p>实际使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\$retTask &#x3D; AoiAreaTaskOrm::findRows\(\[&#39;status&#39;, &#39;extra\_info-&gt;&gt;&quot;\$.new\_aoi\_area\_infos&quot; as new\_aoi\_area\_infos&#39;, &#39;extra\_info-&gt;&gt;&quot;\$.old\_aoi\_area\_infos&quot; as old\_aoi\_area\_infos&#39;\], \$cond\);</span><br></pre></td></tr></table></figure><h2 id="关系数据库设计理论"><a href="#关系数据库设计理论" class="headerlink" title="关系数据库设计理论"></a>关系数据库设计理论</h2><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p><p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p><p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</p><p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>以下的学生课程关系的函数依赖为 {Sno, Cname} -&gt; {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p><p>ble data-draft-node=”block”data-draft-type=”table” data-size=”normal” data-row-style=”normal”&gt;</p><p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p><ul><li><p>冗余数据：例如 <code>学生-2</code> 出现了两次。</p></li><li><p>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</p></li><li><p>删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 <code>课程-1</code> 需要删除第一行和第三行，那么 <code>学生-1</code> 的信息就会丢失。</p></li><li><p>插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</p></li></ul><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>范式理论是为了解决以上提到四种异常。</p><p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p><h3 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式 (1NF)"></a>第一范式 (1NF)</h3><p>属性不可分。</p><h3 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式 (2NF)"></a>第二范式 (2NF)</h3><p>每个非主属性完全函数依赖于键码。</p><p>可以通过分解来满足。</p><p>分解前</p><p>ble data-draft-node=”block”data-draft-type=”table” data-size=”normal” data-row-style=”normal”&gt;</p><p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：</p><ul><li><p>Sno -&gt; Sname, Sdept</p></li><li><p>Sdept -&gt; Mname</p></li><li><p>Sno, Cname-&gt; Grade</p></li></ul><p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p><p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p><p>分解后</p><p>关系-1</p><p>ble data-draft-node=”block” data-draft-type=”table” data-size=”normal” data-row-style=”normal”&gt;</p><p>有以下函数依赖：</p><ul><li><p>Sno -&gt; Sname, Sdept</p></li><li><p>Sdept -&gt; Mname</p></li></ul><p>关系-2</p><p>ble data-draft-node=”block” data-draft-type=”table” data-size=”normal” data-row-style=”normal”&gt;</p><p>有以下函数依赖：</p><ul><li>Sno, Cname -&gt; Grade</li></ul><h3 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式 (3NF)"></a>第三范式 (3NF)</h3><p>非主属性不传递函数依赖于键码。</p><p>上面的 关系-1 中存在以下传递函数依赖：</p><ul><li>Sno -&gt; Sdept -&gt; Mname</li></ul><p>可以进行以下分解：</p><p>关系-11</p><p>ble data-draft-node=”block” data-draft-type=”table” data-size=”normal” data-row-style=”normal”&gt;</p><p>关系-12</p><p>ble data-draft-node=”block” data-draft-type=”table” data-size=”normal” data-row-style=”normal”&gt;</p><h3 id="ER-图"><a href="#ER-图" class="headerlink" title="ER 图"></a>ER 图</h3><p>Entity-Relationship，有三个组成部分：实体、属性、联系。</p><p>用来进行关系型数据库系统的概念设计。</p><h3 id="实体的三种联系"><a href="#实体的三种联系" class="headerlink" title="实体的三种联系"></a>实体的三种联系</h3><p>包含一对一，一对多，多对多三种。</p><ul><li><p>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；</p></li><li><p>如果是一对一，画两个带箭头的线段；</p></li><li><p>如果是多对多，画两个不带箭头的线段。</p></li></ul><p>下图的 Course 和 Student 是一对多的关系。</p><p><img src="https://pic3.zhimg.com/80/v2-417dcb80dfb273f93012a8bc7c95fbfa_720w.jpg" alt=""></p><h3 id="表示出现多次的关系"><a href="#表示出现多次的关系" class="headerlink" title="表示出现多次的关系"></a>表示出现多次的关系</h3><p>一个实体在联系出现几次，就要用几条线连接。</p><p>下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p><p><img src="https://pic4.zhimg.com/80/v2-a34e7063c243a1b8ffe53911300d5057_720w.jpg" alt=""></p><h3 id="联系的多向性"><a href="#联系的多向性" class="headerlink" title="联系的多向性"></a>联系的多向性</h3><p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p><p><img src="https://pic4.zhimg.com/80/v2-ec2b1f26121ca652dedea515b793fe43_720w.jpg" alt=""></p><h3 id="表示子类"><a href="#表示子类" class="headerlink" title="表示子类"></a>表示子类</h3><p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p><p><img src="https://pic3.zhimg.com/80/v2-fc103da3aad081581c0d259f87f501ae_720w.jpg" alt=""></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p>姜承尧. MySQL 技术内幕: InnoDB 存储引擎 [M]. 机械工业出版社, 2011.</p></li><li><p><a href="https://link.zhihu.com/?target=https%3A//github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md">CS-Notes-MySQL</a></p></li><li><p><a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/B%252B_tree">B+ tree</a></p></li><li><p><a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/charlesblc/p/5987812.html">红黑树、B(+)树、跳表、AVL等数据结构，应用场景及分析，以及一些英文缩写</a></p></li><li><p><a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/chengdabelief/p/7384691.html">B树、B+树、红黑树、AVL树比较</a></p></li><li><p><a href="https://link.zhihu.com/?target=https%3A//dev.mysql.com/doc/refman/8.0/en/explain-output.html%23explain-join-types">8.8.2 EXPLAIN Output Format</a></p></li><li><p><a href="https://link.zhihu.com/?target=https%3A//mengkang.net/1124.html">最官方的 mysql explain type 字段解读</a></p></li><li><p><a href="https://link.zhihu.com/?target=https%3A//dev.mysql.com/doc/refman/8.0/en/json-search-functions.html">12.18.3 Functions That Search JSON Values</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/265575385" target="_blank" rel="noopener">转载地址</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;存储引擎&quot;&gt;&lt;a href=&quot;#存储引擎&quot; class=&quot;headerlink&quot; title=&quot;存储引擎&quot;&gt;&lt;/a&gt;存储引擎&lt;/h2&gt;&lt;h3 id=&quot;InnoDB&quot;&gt;&lt;a href=&quot;#InnoDB&quot; class=&quot;headerlink&quot; title=&quot;InnoD
      
    
    </summary>
    
    
    
      <category term="Mysql" scheme="https://kanchai.club/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>GC日志时间分析</title>
    <link href="https://kanchai.club/2020/11/12/GC%E6%97%A5%E5%BF%97%E6%97%B6%E9%97%B4%E5%88%86%E6%9E%90/"/>
    <id>https://kanchai.club/2020/11/12/GC%E6%97%A5%E5%BF%97%E6%97%B6%E9%97%B4%E5%88%86%E6%9E%90/</id>
    <published>2020-11-12T08:03:15.630Z</published>
    <updated>2020-11-12T08:02:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java中的GC有哪几种类型？</p><table cellpadding="0" cellspacing="0" width="852"><tbody style="box-sizing: border-box; outline: 0px; border: 0px; overflow-wrap: break-word;"><tr style="box-sizing: border-box; outline: 0px; border-width: 1px 0px 0px; border-right-style: initial; border-bottom-style: initial; border-left-style: initial; border-right-color: initial; border-bottom-color: initial; border-left-color: initial; border-image: initial; border-top-style: solid; border-top-color: rgb(221, 221, 221); overflow-wrap: break-word;" class="firstRow"><td style="box-sizing: border-box; outline: 0px; padding: 8px; margin: 0px; overflow-wrap: break-word; font-size: 14px; color: rgb(79, 79, 79); line-height: 22px;"><p style="box-sizing: border-box; outline: 0px; overflow: auto hidden; line-height: 22px; overflow-wrap: break-word;">参数</p></td><td style="box-sizing: border-box; outline: 0px; padding: 8px; margin: 0px; overflow-wrap: break-word; font-size: 14px; color: rgb(79, 79, 79); line-height: 22px;"><p style="box-sizing: border-box; outline: 0px; overflow: auto hidden; line-height: 22px; overflow-wrap: break-word;">描述</p></td></tr><tr style="box-sizing: border-box; outline: 0px; border-width: 1px 0px 0px; border-right-style: initial; border-bottom-style: initial; border-left-style: initial; border-right-color: initial; border-bottom-color: initial; border-left-color: initial; border-image: initial; border-top-style: solid; border-top-color: rgb(221, 221, 221); background-color: rgb(247, 247, 247); overflow-wrap: break-word;"><td style="box-sizing: border-box; outline: 0px; padding: 8px; margin: 0px; overflow-wrap: break-word; font-size: 14px; color: rgb(79, 79, 79); line-height: 22px;"><p style="box-sizing: border-box; outline: 0px; overflow: auto hidden; line-height: 22px; overflow-wrap: break-word;">UseSerialGC</p></td><td style="box-sizing: border-box; outline: 0px; padding: 8px; margin: 0px; overflow-wrap: break-word; font-size: 14px; color: rgb(79, 79, 79); line-height: 22px;"><p style="box-sizing: border-box; outline: 0px; overflow: auto hidden; line-height: 22px; overflow-wrap: break-word;">虚拟机运行在Client模式的默认值，打开此开关参数后，</p><p style="box-sizing: border-box; outline: 0px; overflow: auto hidden; line-height: 22px; overflow-wrap: break-word;">使用Serial+Serial Old收集器组合进行垃圾收集。</p></td></tr><tr style="box-sizing: border-box; outline: 0px; border-width: 1px 0px 0px; border-right-style: initial; border-bottom-style: initial; border-left-style: initial; border-right-color: initial; border-bottom-color: initial; border-left-color: initial; border-image: initial; border-top-style: solid; border-top-color: rgb(221, 221, 221); overflow-wrap: break-word;"><td style="box-sizing: border-box; outline: 0px; padding: 8px; margin: 0px; overflow-wrap: break-word; font-size: 14px; color: rgb(79, 79, 79); line-height: 22px;"><p style="box-sizing: border-box; outline: 0px; overflow: auto hidden; line-height: 22px; overflow-wrap: break-word;">UseParNewGC</p></td><td style="box-sizing: border-box; outline: 0px; padding: 8px; margin: 0px; overflow-wrap: break-word; font-size: 14px; color: rgb(79, 79, 79); line-height: 22px;"><p style="box-sizing: border-box; outline: 0px; overflow: auto hidden; line-height: 22px; overflow-wrap: break-word;">打开此开关参数后，使用ParNew+Serial Old收集器组合进行垃圾收集。</p></td></tr><tr style="box-sizing: border-box; outline: 0px; border-width: 1px 0px 0px; border-right-style: initial; border-bottom-style: initial; border-left-style: initial; border-right-color: initial; border-bottom-color: initial; border-left-color: initial; border-image: initial; border-top-style: solid; border-top-color: rgb(221, 221, 221); background-color: rgb(247, 247, 247); overflow-wrap: break-word;"><td style="box-sizing: border-box; outline: 0px; padding: 8px; margin: 0px; overflow-wrap: break-word; font-size: 14px; color: rgb(79, 79, 79); line-height: 22px;"><p style="box-sizing: border-box; outline: 0px; overflow: auto hidden; line-height: 22px; overflow-wrap: break-word;">UseConcMarkSweepGC</p></td><td style="box-sizing: border-box; outline: 0px; padding: 8px; margin: 0px; overflow-wrap: break-word; font-size: 14px; color: rgb(79, 79, 79); line-height: 22px;"><p style="box-sizing: border-box; outline: 0px; overflow: auto hidden; line-height: 22px; overflow-wrap: break-word;">打开此开关参数后，使用ParNew+CMS+Serial Old收集器组合进行垃圾收集。Serial Old作为CMS收集器出现Concurrent Mode Failure的备用垃圾收集器。</p></td></tr><tr style="box-sizing: border-box; outline: 0px; border-width: 1px 0px 0px; border-right-style: initial; border-bottom-style: initial; border-left-style: initial; border-right-color: initial; border-bottom-color: initial; border-left-color: initial; border-image: initial; border-top-style: solid; border-top-color: rgb(221, 221, 221); overflow-wrap: break-word;"><td style="box-sizing: border-box; outline: 0px; padding: 8px; margin: 0px; overflow-wrap: break-word; font-size: 14px; color: rgb(79, 79, 79); line-height: 22px;"><p style="box-sizing: border-box; outline: 0px; overflow: auto hidden; line-height: 22px; overflow-wrap: break-word;">UseParallelGC</p></td><td style="box-sizing: border-box; outline: 0px; padding: 8px; margin: 0px; overflow-wrap: break-word; font-size: 14px; color: rgb(79, 79, 79); line-height: 22px;"><p style="box-sizing: border-box; outline: 0px; overflow: auto hidden; line-height: 22px; overflow-wrap: break-word;">虚拟机运行在Server模式的默认值，打开此开关参数后，使用Parallel Scavenge+Serial Old收集器组合进行垃圾收集。</p></td></tr><tr style="box-sizing: border-box; outline: 0px; border-width: 1px 0px 0px; border-right-style: initial; border-bottom-style: initial; border-left-style: initial; border-right-color: initial; border-bottom-color: initial; border-left-color: initial; border-image: initial; border-top-style: solid; border-top-color: rgb(221, 221, 221); background-color: rgb(247, 247, 247); overflow-wrap: break-word;"><td style="box-sizing: border-box; outline: 0px; padding: 8px; margin: 0px; overflow-wrap: break-word; font-size: 14px; color: rgb(79, 79, 79); line-height: 22px;"><p style="box-sizing: border-box; outline: 0px; overflow: auto hidden; line-height: 22px; overflow-wrap: break-word;">UseParallelOldGC</p></td><td style="box-sizing: border-box; outline: 0px; padding: 8px; margin: 0px; overflow-wrap: break-word; font-size: 14px; color: rgb(79, 79, 79); line-height: 22px;"><p style="box-sizing: border-box; outline: 0px; overflow: auto hidden; line-height: 22px; overflow-wrap: break-word;">打开此开关参数后，使用Parallel Scavenge+Parallel Old收集器组合进行垃圾收集。</p></td></tr></tbody></table><p>在Java程序启动完成后，通过jps观察进程来查询到当前运行的java进程，使用</p><p>jinfo –flag UseSerialGC 进程</p><p>的方式可以定位其使用的gc策略，因为这些参数都是boolean型的常量，如果使用该种gc策略会出现＋号，否则－号。</p><p>使用-XX:+上述GC策略可以开启对应的GC策略。</p><h1 id="GC日志查看"><a href="#GC日志查看" class="headerlink" title="GC日志查看"></a>GC日志查看</h1><p>可以通过在java命令种加入参数来指定对应的gc类型，打印gc日志信息并输出至文件等策略。</p><p>GC的日志是以替换的方式(&gt;)写入的，而不是追加(&gt;&gt;)，如果下次写入到同一个文件中的话，以前的GC内容会被清空。</p><p>对应的参数列表</p><p>-XX:+PrintGC 输出GC日志<br>-XX:+PrintGCDetails 输出GC的详细日志<br>-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）<br>-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）<br>-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息<br>-Xloggc:../logs/gc.log 日志文件的输出路径</p><p>例如:eclipse.ini中配置下面代码启动后会在同一目录下生成gc.log</p><table cellpadding="0" cellspacing="0" width="852"><tbody style="box-sizing: border-box; outline: 0px; border: 0px; overflow-wrap: break-word;"><tr style="box-sizing: border-box; outline: 0px; border-width: 1px 0px 0px; border-right-style: initial; border-bottom-style: initial; border-left-style: initial; border-right-color: initial; border-bottom-color: initial; border-left-color: initial; border-image: initial; border-top-style: solid; border-top-color: rgb(221, 221, 221); overflow-wrap: break-word;" class="firstRow"><td style="box-sizing: border-box; outline: 0px; padding: 8px; margin: 0px; overflow-wrap: break-word; font-size: 14px; color: rgb(79, 79, 79); line-height: 22px;"><p style="box-sizing: border-box; outline: 0px; overflow: auto hidden; line-height: 22px; overflow-wrap: break-word;">1</p><p style="box-sizing: border-box; outline: 0px; overflow: auto hidden; line-height: 22px; overflow-wrap: break-word;">2</p><p style="box-sizing: border-box; outline: 0px; overflow: auto hidden; line-height: 22px; overflow-wrap: break-word;">3</p></td><td style="box-sizing: border-box; outline: 0px; padding: 8px; margin: 0px; overflow-wrap: break-word; font-size: 14px; color: rgb(79, 79, 79); line-height: 22px;"><p style="box-sizing: border-box; outline: 0px; overflow: auto hidden; line-height: 22px; overflow-wrap: break-word;"><code style="box-sizing: border-box; outline: 0px; border-radius: 4px; overflow-wrap: break-word; word-break: break-word;">-Xloggc:gc.log</code></p><p style="box-sizing: border-box; outline: 0px; overflow: auto hidden; line-height: 22px; overflow-wrap: break-word;"><code style="box-sizing: border-box; outline: 0px; border-radius: 4px; overflow-wrap: break-word; word-break: break-word;">-XX:+PrintGCTimeStamps</code></p><p style="box-sizing: border-box; outline: 0px; overflow: auto hidden; line-height: 22px; overflow-wrap: break-word;"><code style="box-sizing: border-box; outline: 0px; border-radius: 4px; overflow-wrap: break-word; word-break: break-word;">-XX:+PrintGCDetails</code></p></td></tr></tbody></table><p>这里使用如下的参数来进行日志的打印：</p><p>-XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:./gclogs</p><p>对于新生代回收的一行日志，其基本内容如下：</p><p>2014-07-18T16:02:17.606+0800: 611.633: [GC 611.633: [DefNew: 843458K-&gt;2K(948864K), 0.0059180 secs] 2186589K-&gt;1343132K(3057292K), 0.0059490 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</p><p>其含义大概如下：</p><p>2014-07-18T16:02:17.606+0800（当前时间戳）: 611.633（时间戳）: [GC（表示Young GC） 611.633: [DefNew（单线程Serial年轻代GC）: 843458K（年轻代垃圾回收前的大小）-&gt;2K（年轻代回收后的大小）(948864K（年轻代总大小）), 0.0059180 secs（本次回收的时间）] 2186589K（整个堆回收前的大小）-&gt;1343132K（整个堆回收后的大小）(3057292K（堆总大小）), 0.0059490 secs（回收时间）] [Times: user=0.00（用户耗时） sys=0.00（系统耗时）, real=0.00 secs（实际耗时）]</p><p>老年代回收的日志如下：</p><p>2014-07-18T16:19:16.794+0800: 1630.821: [GC 1630.821: [DefNew: 1005567K-&gt;111679K(1005568K), 0.9152360 secs]1631.736: [Tenured:<br>2573912K-&gt;1340650K(2574068K), 1.8511050 secs] 3122548K-&gt;1340650K(3579636K), [Perm : 17882K-&gt;17882K(21248K)], 2.7854350 secs] [Times: user=2.57 sys=0.22, real=2.79 secs]</p><p>gc日志中的最后貌似是系统运行完成前的快照：</p><p>Heap<br> def new generation   total 1005568K, used 111158K [0x00000006fae00000, 0x000000073f110000, 0x0000000750350000)<br>  eden space 893888K,  12% used [0x00000006fae00000, 0x0000000701710e90, 0x00000007316f0000)<br>  from space 111680K,   3% used [0x0000000738400000, 0x000000073877c9b0, 0x000000073f110000)<br>  to   space 111680K,   0% used [0x00000007316f0000, 0x00000007316f0000, 0x0000000738400000)<br> tenured generation   total 2234420K, used 1347671K [0x0000000750350000, 0x00000007d895d000, 0x00000007fae00000)<br>   the space 2234420K,  60% used [0x0000000750350000, 0x00000007a2765cb8, 0x00000007a2765e00, 0x00000007d895d000)<br> compacting perm gen  total 21248K, used 17994K [0x00000007fae00000, 0x00000007fc2c0000, 0x0000000800000000)<br>   the space 21248K,  84% used [0x00000007fae00000, 0x00000007fbf92a50, 0x00000007fbf92c00, 0x00000007fc2c0000)<br>No shared spaces configured.</p><h1 id="GC日志的离线分析"><a href="#GC日志的离线分析" class="headerlink" title="GC日志的离线分析"></a>GC日志的离线分析</h1><p>可以使用一些离线的工具来对GC日志进行分析，比如sun的gchisto( <a href="https://java.net/projects/gchisto" target="_blank" rel="noopener">https://java.net/projects/gchisto</a>)，gcviewer（ <a href="https://github.com/chewiebug/GCViewer" target="_blank" rel="noopener">https://github.com/chewiebug/GCViewer</a> ），这些都是开源的工具，用户可以直接通过版本控制工具下载其源码，进行离线分析。</p><p>下面就已gcviewer为例，简要分析一下gc日志的离线分析，gcviewer源代码工程是maven结构的，可以直接用maven进行package，这里编译的是1.34版本，本版本的快照已经上传至附件中。</p><p>需要说明的是，gcviewer支持多种参数生成的gc日志，直接通过java –jar的方式运行，加载生成的gc日志即可：</p><p><img src="http://dl2.iteye.com/upload/attachment/0099/9586/483dd971-065c-3ced-857c-83978a87939f.png" alt=""></p><p>-———————–第二种理解———————–</p><p>首先，给出一个日志输出的例子：</p><p>参数设置为：</p><p>-XX:+PrintGCDetails -XX:-UseAdaptiveSizePolicy -XX:SurvivorRatio=8 -XX:NewSize=10M -XX:MaxNewSize=10M</p><p>参数解释：</p><p>-XX:+PrintGCDetails 启用日志</p><p>-XX:-UseAdaptiveSizePolicy 禁用动态调整，使SurvivorRatio可以起作用</p><p>-XX:SurvivorRatio=8 设置Eden:Survivior=8</p><p>-XX:NewSize=10M -XX:MaxNewSize=10M 设置整个新生代的大小为10M</p><p>默认垃圾收集器为：Parallel Scavenge</p><p>输出结果为：</p><p>[GC [PSYoungGen: 4423K-&gt;320K(9216K)] 4423K-&gt;320K(58880K), 0.0011900 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]<br>[Full GC (System) [PSYoungGen: 320K-&gt;0K(9216K)] [ParOldGen: 0K-&gt;222K(49664K)] 320K-&gt;222K(58880K) [PSPermGen: 2458K-&gt;2456K(21248K)], 0.0073610 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]<br>Heap<br> PSYoungGen      total 9216K, used 491K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)<br>  eden space 8192K, 6% used [0x00000000ff600000,0x00000000ff67af50,0x00000000ffe00000)<br>  from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)<br>  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)<br> ParOldGen       total 49664K, used 222K [0x00000000c5800000, 0x00000000c8880000, 0x00000000ff600000)<br>  object space 49664K, 0% used [0x00000000c5800000,0x00000000c58378a0,0x00000000c8880000)<br> PSPermGen       total 21248K, used 2466K [0x00000000c0600000, 0x00000000c1ac0000, 0x00000000c5800000)<br>  object space 21248K, 11% used [0x00000000c0600000,0x00000000c0868b48,0x00000000c1ac0000)</p><p>前半段分析：</p><p>GC （minor ）日志</p><p><img src="https://img-blog.csdn.net/20131002100114703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXhjMTM1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>Full GC 日志</p><p><img src="https://img-blog.csdn.net/20131002100112187?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXhjMTM1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>后半段分析：</p><p><img src="https://img-blog.csdn.net/20130930164842000?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXhjMTM1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="">)<img src="https://img-blog.csdn.net/20130930164907500?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXhjMTM1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>对照上面的图，GC日志中的PSYoungGen（PS是指Parallel Scavenge）为Eden+FromSpace，而整个YoungGeneration为Eden+FromSpace+ToSpace。</p><p>  我们设置的新生代大小为10240K，这包括9216K大小的PSYoungGen和1024K大小的ToSpace。其中，PSYoungGen中的Eden:FromSpace为8:1，</p><p>这包括8192K的Eden和1024K的FromSpace。</p><p>  关于老年代和永久代的输出比较简单，不再详述。</p><p>更详细描述参见官方文档：<a href="http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html</a></p><p>  最后注意，如果新生代的空间不能刚好按比例划分，则可能有一定的误差。比如，将上述的参数中SurvivorRatio改为10，则输出如下：</p><p>[GC [PSYoungGen: 4439K-&gt;320K(9408K)] 4439K-&gt;320K(59072K), 0.0010120 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>[Full GC (System) [PSYoungGen: 320K-&gt;0K(9408K)] [ParOldGen: 0K-&gt;222K(49664K)] 320K-&gt;222K(59072K) [PSPermGen: 2458K-&gt;2456K(21248K)], 0.0095710 secs] [Times: user=0.02 sys=0.00, real=0.00 secs]<br>Heap<br> PSYoungGen      total 9408K, used 514K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)<br>  eden space 8576K, 6% used [0x00000000ff600000,0x00000000ff680b78,0x00000000ffe60000)<br>  from space 832K, 0% used [0x00000000ffe60000,0x00000000ffe60000,0x00000000fff30000)<br>  to   space 832K, 0% used [0x00000000fff30000,0x00000000fff30000,0x0000000100000000)<br> ParOldGen       total 49664K, used 222K [0x00000000c5800000, 0x00000000c8880000, 0x00000000ff600000)<br>  object space 49664K, 0% used [0x00000000c5800000,0x00000000c58378a0,0x00000000c8880000)<br> PSPermGen       total 21248K, used 2466K [0x00000000c0600000, 0x00000000c1ac0000, 0x00000000c5800000)<br>  object space 21248K, 11% used [0x00000000c0600000,0x00000000c0868b48,0x00000000c1ac0000)</p><p>  可以看到新生代的相关数值是有一定误差的</p><p>GC日志分析</p><p>　在GC日志里，一条完整的GC日志记录最后，会带有本次GC所花费的时间，如下面这一条新生代GC：</p><p>[GC [DefNew: 3298K-&gt;149K(5504K), 0.0053498 secs] 3298K-&gt;3221K(9600K), .0053750 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]</p><p>　　注意到日志中时间分为了三块：<code>user</code>， <code>sys</code>，和 <code>real</code>，三者的区别和含义如下：</p><ul><li><p>　　<code>real</code>：指的是在此次GC事件中所花费的总时间；</p></li><li><p>　　<code>user</code>：指的是CPU工作在_用户态_所花费的时间；</p></li><li><p>　　<code>sys</code>：指的是CPU工作在_内核态_所花费的时间。</p></li></ul><p>　　<code>user</code> + <code>sys</code> 就是CPU花费的实际时间，注意这个值统计了所有CPU上的时间，如果进程工作在多线程的环境下，这个值是会超出 real 所记录的值的，即 <code>user</code> + <code>sys</code> &gt;= <code>real</code></p><p>　　对于GC事件来说，无论是 Minor GC 还是 Full GC 的过程，都存在并发的GC算法，如新生代的ParNew，老年代的ParallelOld，GC过程中工作负载是由多个线程共同完成的，这也就意味着使用这些GC算法时，GC日志中我们应该观察到：<code>user</code> + <code>sys</code> &gt; <code>real</code>。譬如说：配置了<code>ParNew</code>且并发数为5的GC活动（<code>-XX:+UseParNewGC \-XX:ParallelGCThreads=5</code>）中，如果<code>user</code> + <code>sys</code>的值为 _2 seconds_，那么 <code>real</code> 的时间 就近似为 <code>400ms(2 seconds / 5)</code>。</p><p>场景1：</p><p>[Times: user=11.53 sys=1.38, real=1.03 secs]</p><p>　　垃圾回收过程是通过并发执行，因此 <code>user</code> + <code>sys</code> 远大于 <code>real</code> 。</p><p>场景2：</p><p>[Times: user=0.09 sys=0.00, real=0.09 secs]</p><p>　　因为使用了串行的垃圾回收期，所以时间应该是 <code>user</code> 和 <code>real</code> 相等。</p><p>场景3：</p><p>[Times: user=0.20 sys=0.01, real=18.45 secs]</p><p>　　这是一个异常的示例，可以看到 <code>real</code> 所显示的时间 远 大于 <code>user</code> + <code>sys</code>。一般来说，如果观察到GC日志里多次出现了场景3所示的日志，这表明JVM的GC 过程存在某些问题（等待计算资源），原因可能是下面这两种：</p><ul><li><p>　　频繁的IO操作</p></li><li><p>　　缺乏CPU资源</p></li></ul><p>繁忙的I/O操作</p><p>　　当程序存在繁忙的I/O操作（网络IO或磁盘IO）时，会让 <code>real</code> 时间大幅上升。因为在记录GC日志的时候，你的程序进行了磁盘读写，如果同一时间其他IO操作较重，则此时GC事件会延迟，进而影响了最终的 <code>real</code> 的值。注意，如果程序本身不存在的频繁的IO操作，同一机器上其他进程的频繁IO也会影响 <code>real</code> 的最终结果。Linux环境下可以使用 <code>sar</code> 监视机器上的I/O，eg. <code>sar \-d \-p 1</code>，如果频繁的IO操作的确存在，可以通过下面两种方式改进：</p><ul><li><p>　　优化程序本身的IO操作逻辑；</p></li><li><p>　　消除其他进程带来的IO影响。</p></li></ul><p>缺乏CPU资源</p><p>　　当程序本身是CPU密集型应用，或机器上其他进程占用了大量的CPU计算资源，则有可能会出现分配不到 CPU cycles的情况，这会让程序挂起，GC所花费的实际时间也将远大于 <code>user</code> + <code>sys</code> 的值。</p><p>　　可以使用 <code>top</code> 命令观察一下 进程的CPU利用率，同时辅以Profiler工具统计一段时间内进程的状态分布。如果的确是CPU资源不足，解决方法无法下面几种：</p><ul><li><p>　　优化程序内部的线程使用，确保无冗余的线程配置；</p></li><li><p>　　增加虚拟机或容器的CPU配置，提升机器总的计算能力。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java中的GC有哪几种类型？&lt;/p&gt;
&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; width=&quot;852&quot;&gt;&lt;tbody style=&quot;box-sizing: border-box; outline: 0px; border: 0px; o
      
    
    </summary>
    
    
    
      <category term="jvm" scheme="https://kanchai.club/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>注册中心ZooKeeper、Eureka、Consul 、Nacos对比</title>
    <link href="https://kanchai.club/2020/07/29/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83ZooKeeper%E3%80%81Eureka%E3%80%81Consul_%E3%80%81Nacos%E5%AF%B9%E6%AF%94/"/>
    <id>https://kanchai.club/2020/07/29/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83ZooKeeper%E3%80%81Eureka%E3%80%81Consul_%E3%80%81Nacos%E5%AF%B9%E6%AF%94/</id>
    <published>2020-07-29T02:40:53.323Z</published>
    <updated>2020-07-29T02:39:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>服务注册中心本质上是为了解耦服务提供者和服务消费者。对于任何一个微服务，原则上都应存在或者支持多个提供者，这是由微服务的分布式属性决定的。更进一步，为了支持弹性扩缩容特性，一个微服务的提供者的数量和分布往往是动态变化的，也是无法预先确定的。因此，原本在单体应用阶段常用的静态LB机制就不再适用了，需要引入额外的组件来管理微服务提供者的注册与发现，而这个组件就是服务注册中心。</p><h1 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h1><p>CAP理论是分布式架构中重要理论</p><blockquote><ul><li><p>一致性(Consistency) (所有节点在同一时间具有相同的数据)</p></li><li><p>可用性(Availability) (保证每个请求不管成功或者失败都有响应)</p></li><li><p>分隔容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作)</p></li></ul></blockquote><p>关于</p><p>P的理解，我觉得是在整个系统中某个部分，挂掉了，或者宕机了，并不影响整个系统的运作或者说使用，</p><p>而可用性是，某个系统的某个节点挂了，但是并不影响系统的接受或者发出请求，CAP 不可能都取，只能取其中2个</p><p>原因是</p><p>如果C是第一需求的话，那么会影响A的性能，因为要数据同步，不然请求结果会有差异，但是数据同步会消耗时间，期间可用性就会降低。</p><p>如果A是第一需求，那么只要有一个服务在，就能正常接受请求，但是对与返回结果变不能保证，原因是，在分布式部署的时候，数据一致的过程不可能想切线路那么快。</p><p>再如果，同事满足一致性和可用性，那么分区容错就很难保证了，也就是单点，也是分布式的基本核心，好了，明白这些理论，就可以在相应的场景选取服务注册与发现了</p><h1 id="服务注册中心解决方案"><a href="#服务注册中心解决方案" class="headerlink" title="服务注册中心解决方案"></a>服务注册中心解决方案</h1><p>设计或者选型一个服务注册中心，首先要考虑的就是服务注册与发现机制。纵观当下各种主流的服务注册中心解决方案，大致可归为三类：</p><ul><li><p>应用内：直接集成到应用中，依赖于应用自身完成服务的注册与发现，最典型的是Netflix提供的<a href="https://github.com/Netflix/eureka" target="_blank" rel="noopener">Eureka</a></p></li><li><p>应用外：把应用当成黑盒，通过应用外的某种机制将服务注册到注册中心，最小化对应用的侵入性，比如Airbnb的<a href="http://nerds.airbnb.com/smartstack-service-discovery-cloud/" target="_blank" rel="noopener">SmartStack</a>，HashiCorp的<a href="https://www.consul.io/" target="_blank" rel="noopener">Consul</a></p></li><li><p>DNS：将服务注册为DNS的SRV记录，严格来说，是一种特殊的应用外注册方式，<a href="https://github.com/skynetservices/skydns" target="_blank" rel="noopener">SkyDNS</a>是其中的代表</p></li></ul><p><em>注1：对于第一类注册方式，除了Eureka这种一站式解决方案，还可以基于ZooKeeper或者Etcd自行实现一套服务注册机制，这在大公司比较常见，但对于小公司而言显然性价比太低。</em></p><p><em>注2：由于DNS固有的缓存缺陷，本文不对第三类注册方式作深入探讨。</em></p><p>除了基本的服务注册与发现机制，从开发和运维角度，至少还要考虑如下五个方面：</p><ul><li><p>测活：服务注册之后，如何对服务进行测活以保证服务的可用性？</p></li><li><p>负载均衡：当存在多个服务提供者时，如何均衡各个提供者的负载？</p></li><li><p>集成：在服务提供端或者调用端，如何集成注册中心？</p></li><li><p>运行时依赖：引入注册中心之后，对应用的运行时环境有何影响？</p></li><li><p>可用性：如何保证注册中心本身的可用性，特别是消除单点故障？</p></li></ul><h1 id="主流注册中心产品"><a href="#主流注册中心产品" class="headerlink" title="主流注册中心产品"></a>主流注册中心产品</h1><table><thead><tr><th align="left"></th><th align="left">Nacos</th><th align="left">Eureka</th><th align="left">Consul</th><th align="left">CoreDNS</th><th align="left">Zookeeper</th></tr></thead><tbody><tr><td align="left">一致性协议</td><td align="left">CP+AP</td><td align="left">AP</td><td align="left">CP</td><td align="left">—</td><td align="left">CP</td></tr><tr><td align="left">健康检查</td><td align="left">TCP/HTTP/MYSQL/Client Beat</td><td align="left">Client Beat</td><td align="left">TCP/HTTP/gRPC/Cmd</td><td align="left">—</td><td align="left">Keep Alive</td></tr><tr><td align="left">负载均衡策略</td><td align="left">权重/</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">metadata/Selector</td><td align="left">Ribbon</td><td align="left">Fabio</td><td align="left">RoundRobin</td><td align="left">—</td><td align="left"></td></tr><tr><td align="left">雪崩保护</td><td align="left">有</td><td align="left">有</td><td align="left">无</td><td align="left">无</td><td align="left">无</td></tr><tr><td align="left">自动注销实例</td><td align="left">支持</td><td align="left">支持</td><td align="left">不支持</td><td align="left">不支持</td><td align="left">支持</td></tr><tr><td align="left">访问协议</td><td align="left">HTTP/DNS</td><td align="left">HTTP</td><td align="left">HTTP/DNS</td><td align="left">DNS</td><td align="left">TCP</td></tr><tr><td align="left">监听支持</td><td align="left">支持</td><td align="left">支持</td><td align="left">支持</td><td align="left">不支持</td><td align="left">支持</td></tr><tr><td align="left">多数据中心</td><td align="left">支持</td><td align="left">支持</td><td align="left">支持</td><td align="left">不支持</td><td align="left">不支持</td></tr><tr><td align="left">跨注册中心同步</td><td align="left">支持</td><td align="left">不支持</td><td align="left">支持</td><td align="left">不支持</td><td align="left">不支持</td></tr><tr><td align="left">SpringCloud集成</td><td align="left">支持</td><td align="left">支持</td><td align="left">支持</td><td align="left">不支持</td><td align="left">不支持</td></tr><tr><td align="left">Dubbo集成</td><td align="left">支持</td><td align="left">不支持</td><td align="left">不支持</td><td align="left">不支持</td><td align="left">支持</td></tr><tr><td align="left">K8S集成</td><td align="left">支持</td><td align="left">不支持</td><td align="left">支持</td><td align="left">支持</td><td align="left">不支持</td></tr></tbody></table><h2 id="Apache-Zookeeper-gt-CP"><a href="#Apache-Zookeeper-gt-CP" class="headerlink" title="Apache Zookeeper -&gt; CP"></a>Apache Zookeeper -&gt; CP</h2><p>与 Eureka 有所不同，Apache Zookeeper 在设计时就紧遵CP原则，即任何时候对 Zookeeper 的访问请求能得到一致的数据结果，同时系统对网络分割具备容错性，但是 Zookeeper 不能保证每次服务请求都是可达的。</p><p>从 Zookeeper 的实际应用情况来看，在使用 Zookeeper 获取服务列表时，如果此时的 Zookeeper 集群中的 Leader 宕机了，该集群就要进行 Leader 的选举，又或者 Zookeeper 集群中半数以上服务器节点不可用（例如有三个节点，如果节点一检测到节点三挂了 ，节点二也检测到节点三挂了，那这个节点才算是真的挂了），那么将无法处理该请求。所以说，Zookeeper 不能保证服务可用性。</p><p>当然，在大多数分布式环境中，尤其是涉及到数据存储的场景，数据一致性应该是首先被保证的，这也是 Zookeeper 设计紧遵CP原则的另一个原因。</p><p>但是对于服务发现来说，情况就不太一样了，针对同一个服务，即使注册中心的不同节点保存的服务提供者信息不尽相同，也并不会造成灾难性的后果。</p><p>因为对于服务消费者来说，能消费才是最重要的，消费者虽然拿到可能不正确的服务实例信息后尝试消费一下，也要胜过因为无法获取实例信息而不去消费，导致系统异常要好（淘宝的双十一，京东的618就是紧遵AP的最好参照）。</p><p>当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30~120s，而且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。</p><p>在云部署环境下， 因为网络问题使得zk集群失去master节点是大概率事件，虽然服务能最终恢复，但是漫长的选举事件导致注册长期不可用是不能容忍的。</p><h2 id="Spring-Cloud-Eureka-gt-AP"><a href="#Spring-Cloud-Eureka-gt-AP" class="headerlink" title="Spring Cloud Eureka  -&gt; AP"></a>Spring Cloud Eureka  -&gt; AP</h2><p><img src="https://img-blog.csdnimg.cn/20190823093426246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseTkxMDkwNQ==,size_16,color_FFFFFF,t_70" alt=""></p><p>Spring Cloud Netflix 在设计 Eureka 时就紧遵AP原则（尽管现在2.0发布了，但是由于其闭源的原因 ，但是目前 Ereka 1.x 任然是比较活跃的）。</p><p>Eureka Server 也可以运行多个实例来构建集群，解决单点问题，但不同于 ZooKeeper 的选举 leader 的过程，Eureka Server 采用的是Peer to Peer 对等通信。这是一种去中心化的架构，无 master/slave 之分，每一个 Peer 都是对等的。在这种架构风格中，节点通过彼此互相注册来提高可用性，每个节点需要添加一个或多个有效的 serviceUrl 指向其他节点。每个节点都可被视为其他节点的副本。  </p><p>在集群环境中如果某台 Eureka Server 宕机，Eureka Client 的请求会自动切换到新的 Eureka Server 节点上，当宕机的服务器重新恢复后，Eureka 会再次将其纳入到服务器集群管理之中。当节点开始接受客户端请求时，所有的操作都会在节点间进行复制（replicate To Peer）操作，将请求复制到该 Eureka Server 当前所知的其它所有节点中。  </p><p>当一个新的 Eureka Server 节点启动后，会首先尝试从邻近节点获取所有注册列表信息，并完成初始化。Eureka Server 通过 getEurekaServiceUrls() 方法获取所有的节点，并且会通过心跳契约的方式定期更新。</p><p>默认情况下，如果 Eureka Server 在一定时间内没有接收到某个服务实例的心跳（默认周期为30秒），Eureka Server 将会注销该实例（默认为90秒， eureka.instance.lease-expiration-duration-in-seconds 进行自定义配置）。</p><p>当 Eureka Server 节点在短时间内丢失过多的心跳时，那么这个节点就会进入自我保护模式。</p><p>Eureka的集群中，只要有一台Eureka还在，就能保证注册服务可用（保证可用性），只不过查到的信息可能不是最新的（不保证强一致性）。除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：</p><ol><li><p>Eureka不再从注册表中移除因为长时间没有收到心跳而过期的服务；</p></li><li><p>Eureka仍然能够接受新服务注册和查询请求，但是不会被同步到其它节点上（即保证当前节点依然可用）；</p></li><li><p>当网络稳定时，当前实例新注册的信息会被同步到其它节点中；</p></li></ol><p>因此，Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使得整个注册服务瘫痪。</p><h2 id="Consul："><a href="#Consul：" class="headerlink" title="Consul："></a>Consul：</h2><p>Consul 是 HashiCorp 公司推出的开源工具，用于实现分布式系统的服务发现与配置。Consul 使用 Go 语言编写，因此具有天然可移植性（支持Linux、windows和Mac OS X）。</p><p>Consul 内置了服务注册与发现框架、分布一致性协议实现、健康检查、Key/Value 存储、多数据中心方案，不再需要依赖其他工具（比如 ZooKeeper 等），使用起来也较为简单。</p><p>Consul 遵循CAP原理中的CP原则，保证了强一致性和分区容错性，且使用的是Raft算法，比zookeeper使用的Paxos算法更加简单。虽然保证了强一致性，但是可用性就相应下降了，例如服务注册的时间会稍长一些，因为 Consul 的 raft 协议要求必须过半数的节点都写入成功才认为注册成功 ；在leader挂掉了之后，重新选举出leader之前会导致Consul 服务不可用。</p><p><img src="https://img-blog.csdnimg.cn/20190823093438619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseTkxMDkwNQ==,size_16,color_FFFFFF,t_70" alt="">默认依赖于SDK</p><p> Consul本质上属于应用外的注册方式，但可以通过SDK简化注册流程。而服务发现恰好相反，默认依赖于SDK，但可以通过Consul Template（下文会提到）去除SDK依赖。</p><p><img src="https://img-blog.csdnimg.cn/20190823093459885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseTkxMDkwNQ==,size_16,color_FFFFFF,t_70" alt="">Consul Template</p><p>Consul Template</p><p>Consul，默认服务调用者需要依赖Consul SDK来发现服务，这就无法保证对应用的零侵入性。</p><p>所幸通过<a href="https://github.com/hashicorp/consul-template" target="_blank" rel="noopener">Consul Template</a>，可以定时从Consul集群获取最新的服务提供者列表并刷新LB配置（比如nginx的upstream），这样对于服务调用者而言，只需要配置一个统一的服务调用地址即可。</p><p>Consul强一致性(C)带来的是：</p><ol><li><p>服务注册相比Eureka会稍慢一些。因为Consul的raft协议要求必须过半数的节点都写入成功才认为注册成功</p></li><li><p>Leader挂掉时，重新选举期间整个consul不可用。保证了强一致性但牺牲了可用性。</p></li></ol><p>Eureka保证高可用(A)和最终一致性：</p><ol><li><p>服务注册相对要快，因为不需要等注册信息replicate到其他节点，也不保证注册信息是否replicate成功</p></li><li><p>当数据出现不一致时，虽然A, B上的注册信息不完全相同，但每个Eureka节点依然能够正常对外提供服务，这会出现查询服务信息时如果请求A查不到，但请求B就能查到。如此保证了可用性但牺牲了一致性。</p></li></ol><p>其他方面，eureka就是个servlet程序，跑在servlet容器中; Consul则是go编写而成。</p><h2 id="Nacos："><a href="#Nacos：" class="headerlink" title="Nacos："></a>Nacos：</h2><p>Nacos是阿里开源的，Nacos 支持基于 DNS 和基于 RPC 的服务发现。在Spring Cloud中使用Nacos，只需要先下载 Nacos 并启动 Nacos server，Nacos只需要简单的配置就可以完成服务的注册发现。</p><p>Nacos除了服务的注册发现之外，还支持动态配置服务。动态配置服务可以让您以中心化、外部化和动态化的方式管理所有环境的应用配置和服务配置。动态配置消除了配置变更时重新部署应用和服务的需要，让配置管理变得更加高效和敏捷。配置中心化管理让实现无状态服务变得更简单，让服务按需弹性扩展变得更容易。</p><p>一句话概括就是Nacos = Spring Cloud注册中心 + Spring Cloud配置中心。  </p><p>参考链接：</p><p><a href="https://yq.aliyun.com/articles/698930" target="_blank" rel="noopener">https://yq.aliyun.com/articles/698930</a></p><p><a href="https://nacos.io/" target="_blank" rel="noopener">https://nacos.io</a></p><p>转载来源 <a href="https://blog.csdn.net/fly910905/article/details/100023415" target="_blank" rel="noopener">https://blog.csdn.net/fly910905/article/details/100023415</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;服务注册中心本质上是为了解耦服务提供者和服务消费者。对于任何一个微服务，原则上都应存在或者支持多个提供者，这是由微服务的分布式属性决定的。更
      
    
    </summary>
    
    
    
      <category term="SpringCloud" scheme="https://kanchai.club/tags/SpringCloud/"/>
    
      <category term="微服务" scheme="https://kanchai.club/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>python实现医疗在线问答机器人</title>
    <link href="https://kanchai.club/2020/07/29/python%E5%AE%9E%E7%8E%B0%E5%8C%BB%E7%96%97%E5%9C%A8%E7%BA%BF%E9%97%AE%E7%AD%94%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    <id>https://kanchai.club/2020/07/29/python%E5%AE%9E%E7%8E%B0%E5%8C%BB%E7%96%97%E5%9C%A8%E7%BA%BF%E9%97%AE%E7%AD%94%E6%9C%BA%E5%99%A8%E4%BA%BA/</id>
    <published>2020-07-29T00:50:33.811Z</published>
    <updated>2020-07-29T00:50:05.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_words_internet</span><span class="params">(key_word)</span>:</span></span><br><span class="line">    <span class="comment"># 查找答案列表</span></span><br><span class="line">    yl_domain = <span class="string">'https://www.youlai.cn'</span></span><br><span class="line">    find_num = <span class="number">0</span></span><br><span class="line">    match_result = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> find_num &lt; <span class="number">10</span> <span class="keyword">and</span> match_result <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        find_num += <span class="number">1</span></span><br><span class="line">        print(<span class="string">'思考中:'</span> + str(find_num))</span><br><span class="line">        html = urllib2.urlopen(yl_domain + <span class="string">"/cse/search?q="</span> + key_word + <span class="string">"&amp;page="</span> + str(find_num)).read()</span><br><span class="line">        match_result = re.search(<span class="string">r'.&lt;a.*href="(.*ask/[^"]*)".*'</span>, html, re.M | re.I)</span><br><span class="line">    <span class="keyword">if</span> match_result <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        the_text = match_result.group(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 获取第一个答案详情</span></span><br><span class="line">        html = urllib2.urlopen(yl_domain + the_text).read()</span><br><span class="line">        match_result = re.search(<span class="string">r'&lt;div class=\"text\"&gt;([^div]*)&lt;/div&gt;'</span>, html, re.M | re.I | re.DOTALL)</span><br><span class="line">        <span class="keyword">if</span> match_result <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            match_result = re.search(<span class="string">r'&lt;div class=\"p_text\"&gt;([^div]*)&lt;/div&gt;'</span>, html, re.M | re.I | re.DOTALL)</span><br><span class="line">        <span class="keyword">if</span> match_result <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            match_result = re.search(<span class="string">r'&lt;div class=\"docYes\"&gt;.*&lt;p&gt;([^&lt;/p&gt;]*)&lt;/p&gt;'</span>, html, re.M | re.I | re.DOTALL)</span><br><span class="line">        <span class="keyword">if</span> match_result <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            the_text = match_result.group(<span class="number">1</span>)</span><br><span class="line">            the_text = re.sub(<span class="string">r'&lt;[^&gt;]+&gt;'</span>, <span class="string">''</span>, the_text)</span><br><span class="line">            <span class="keyword">return</span> the_text.strip().strip(<span class="string">'　'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    keyword = <span class="string">""</span>;</span><br><span class="line">    print(<span class="string">"问:"</span> + keyword)</span><br><span class="line">    print(<span class="string">"答:"</span> + find_words_internet(keyword))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
    
    
      <category term="Python" scheme="https://kanchai.club/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>一文读懂SpringCloud与Eureka，Feign，Ribbon，Hystrix，Zuul核心组件间的关系</title>
    <link href="https://kanchai.club/2020/07/29/%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82SpringCloud%E4%B8%8EEureka%EF%BC%8CFeign%EF%BC%8CRibbon%EF%BC%8CHystrix%EF%BC%8CZuul%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>https://kanchai.club/2020/07/29/%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82SpringCloud%E4%B8%8EEureka%EF%BC%8CFeign%EF%BC%8CRibbon%EF%BC%8CHystrix%EF%BC%8CZuul%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</id>
    <published>2020-07-29T00:39:20.583Z</published>
    <updated>2020-07-29T00:38:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-Cloud的主要组件"><a href="#Spring-Cloud的主要组件" class="headerlink" title="Spring Cloud的主要组件"></a>Spring Cloud的主要组件</h2><p>Spring Cloud是目前微服务架构领域的翘楚，无数的书籍博客都在讲解这个技术，实际上，Spring Cloud是一个全家桶式的技术栈，包含了很多组件。本文先从其最核心的几个组件入手，来剖析一下其底层的工作原理。也就是Eureka、Ribbon、Feign、Hystrix、Zuul这几个组件。</p><h2 id="业务场景介绍"><a href="#业务场景介绍" class="headerlink" title="业务场景介绍"></a>业务场景介绍</h2><p>先来给大家说一个业务场景，假设咱们现在开发一个电商网站，要实现支付订单的功能，流程如下：</p><ul><li><p>创建一个订单，如果用户立刻支付了这个订单，我们需要将订单状态更新为“已支付”</p></li><li><p>扣减相应的商品库存</p></li><li><p>通知仓储中心，进行发货</p></li><li><p>给用户的这次购物增加相应的积分</p></li></ul><p>针对上述流程，我们需要有订单服务、库存服务、仓储服务、积分服务。整个流程的大体思路如下：</p><p>用户针对一个订单完成支付之后，就会去找订单服务，更新订单状态<br>订单服务调用库存服务，完成相应功能<br>订单服务调用仓储服务，完成相应功能<br>订单服务调用积分服务，完成相应功能</p><p>至此，整个支付订单的业务流程结束<br>下图这张图，清晰表明了各服务间的调用过程：<br><img src="https://img-blog.csdnimg.cn/20190319153230122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM4Nzk4MjQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="Spring-Cloud组件之间如何运作"><a href="#Spring-Cloud组件之间如何运作" class="headerlink" title="Spring Cloud组件之间如何运作"></a>Spring Cloud组件之间如何运作</h2><p>Eureka组件<br>咱们来考虑第一个问题：订单服务想要调用库存服务、仓储服务，或者是积分服务，怎么调用？</p><ul><li><p>订单服务压根儿就不知道人家库存服务在哪台机器上啊！他就算想要发起一个请求，都不知道发送给谁，有心无力！</p></li><li><p>这时候，就轮到Spring Cloud Eureka出场了。Eureka是微服务架构中的注册中心，专门负责服务的注册与发现。</p></li></ul><p>通过这个图来了解Eureka是如何工作的<img src="https://img-blog.csdnimg.cn/20190319153620781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM4Nzk4MjQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如上图所示，库存服务、仓储服务、积分服务中都有一个Eureka Client组件，这个组件专门负责将这个服务的信息注册到Eureka Server中。说白了，就是告诉Eureka Server，自己在哪台机器上，监听着哪个端口。而Eureka Server是一个注册中心，里面有一个注册表，保存了各服务所在的机器和端口号。</p><p>订单服务里也有一个Eureka Client组件，这个Eureka Client组件会找Eureka Server问一下：库存服务在哪台机器啊？监听着哪个端口啊？仓储服务呢？积分服务呢？然后就可以把这些相关信息从Eureka Server的注册表中拉取到自己本地缓存起来。</p><p>这时如果订单服务想要调用库存服务，不就可以找自己本地的Eureka Client问一下库存服务在哪台机器？监听哪个端口吗？收到响应后，紧接着就可以发送一个请求过去，调用库存服务扣减库存的那个接口！同理，如果订单服务要调用仓储服务、积分服务，也是如法炮制。</p><p>Feign组件<br>现在订单服务确实知道库存服务、积分服务、仓库服务在哪里了，同时也监听着哪些端口号了，但是新问题又来了</p><ul><li><p>订单服务要自己写一大堆代码，跟其他服务建立网络连接，然后构造一个复杂的请求，接着发送请求过去，最后对返回的响应结果再写一大堆代码来处理吗？</p></li><li><p>别急，Feign早已为我们提供好了优雅的解决方案<br><img src="https://img-blog.csdnimg.cn/20190319154108621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM4Nzk4MjQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>没有底层的建立连接、构造请求、解析响应的代码，直接就是用注解定义一个 FeignClient接口，然后调用那个接口就可以了。人家Feign Client会在底层根据你的注解，跟你指定的服务建立连接、构造请求、发起靕求、获取响应、解析响应，等等。这一系列脏活累活，人家Feign全给你干了。</p></li></ul><p>Feign实现原理解析</p><ul><li><p>首先，如果你对某个接口定义了@FeignClient注解，Feign就会针对这个接口创建一个动态代理</p></li><li><p>接着你要调用哪个接口，本质就是会调用 Feign创建的动态代理，这是核心中的核心</p></li><li><p>Feign的动态代理会根据你在接口上的@RequestMapping等注解，来动态构造出你要请求的服务的地址</p></li><li><p>最后针对这个地址，发起请求、解析响应<br><img src="https://img-blog.csdnimg.cn/20190319154206707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM4Nzk4MjQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">  </p></li></ul><p>Ribbon组件<br>说完了Feign，还没完。现在新的问题又来了，如果人家库存服务部署在了3台机器上，如下所示：</p><ul><li><p>192.168.170:9090</p></li><li><p>192.168.171:9090</p></li><li><p>192.168.172:9090</p></li></ul><p>这下糟糕了，人家Feign怎么知道该请求哪台机器呢？</p><p>Ribbon就派上用场了。Ribbon就是专门解决这个问题的。它的作用是负载均衡，会帮你在每次请求时选择一台机器，均匀的把请求分发到各个机器上。</p><p>Ribbon的负载均衡默认使用的最经典的Round Robin轮询算法。这是啥？简单来说，就是如果订单服务对库存服务发起10次请求，那就先让你请求第1台机器、然后是第2台机器、第3台机器、第4台机器、第5台机器，接着再来—个循环，第1台机器、第2台机器。。。以此类推。</p><p>Hystrix组件<br>当然这些服务正常的情况下，系统是没有问题的，但是谁也不能保证做的系统就一点问题也没有，所以万一要是哪台机器的服务挂了，怎么办，服务与服务之间都是紧密联系的，会不会产生连锁反应，导致整个系统崩掉。<br><img src="https://img-blog.csdnimg.cn/2019031915502198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM4Nzk4MjQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如上图，这么多服务互相调用，要是不做任何保护的话，某一个服务挂了，就会引起连锁反应，导致别的服务也挂。比如积分服务挂了，会导致订单服务的线程全部卡在请求积分服务这里，没有一个线程可以工作，瞬间导致订单服务也挂了，别人请求订单服务全部会卡住，无法响应。</p><p>但是我们思考一下，就算积分服务挂了，订单服务也可以不用挂啊！为什么？</p><ul><li><p>我们结合业务来看：支付订单的时候，只要把库存扣减了，然后通知仓库发货就OK了</p></li><li><p>如果积分服务挂了，大不了等他恢复之后，慢慢人肉手工恢复数据！为啥一定要因为一个积分服务挂了，就直接导致订单服务也挂了呢？不可以接受！</p></li><li><p>Hystrix闪亮登场了。Hystrix是隔离、熔断以及降级的一个框架。啥意思呢？说白了，Hystrix会搞很多个小小的线程池，比如订单服务请求库存服务是一个线程池，请求仓储服务是一个线程池，请求积分服务是一个线程池。每个线程池里的线程就仅仅用于请求那个服务。</p></li></ul><p>现在有了Hystrix组件，再次发生积分服务挂了，会怎样？</p><ul><li><p>订单服务调用库存服务、仓储服务的这两个线程池都是正常工作的，所以这两个服务不会受到任何影响。</p></li><li><p>订单服务调用积分服务，如果积分服务挂了，那么这时系统会直接返回一个固定的字符串或者图片等等，不至于造成卡顿现象，影响客户体验。</p></li></ul><p>Zuul组件</p><p>业务场景：假设你后台部署了几百个服务，现在有个前端兄弟，人家请求是直接从浏览器那儿发过来的。人家要请求一下库存服务，你难道还让人家记着这服务的名字叫做inventory-service？部署在5台机器上？就算人家肯记住这一个，你后台可有几百个服务的名称和地址呢？难不成人家请求一个，就得记住一个？</p><p>解决办法：Zuul组件，一种微服务网关组件，负责网络路由的，类似于路由器的功能。所以一般微服务架构中都必然会设计一个网关在里面，像android、ios、pc前端、微信小程序、H5等等，不用去关心后端有几百个服务，就知道有一个网关，所有请求都往网关走，网关会根据请求中的一些特征，将请求转发给后端的各个服务。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后再来总结一下，上述Spring Cloud核心组件，在微服务架构中，分别扮演的角色：</p><ul><li><p>Eureka：各个服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉取注册表，从而知道其他服务在哪里</p></li><li><p>Ribbon：服务间发起请求的时候，基于Ribbon做负载均衡，从一个服务的多台机器中选择一台</p></li><li><p>Feign：基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求</p></li><li><p>Hystrix：发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题</p></li><li><p>Zuul：如果前端、移动端要调用后端系统，统一从Zuul网关进入，由Zuul网关转发请求给对应的服务<br><img src="https://img-blog.csdnimg.cn/2019031916013768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM4Nzk4MjQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><h2 id="文章转载"><a href="#文章转载" class="headerlink" title="文章转载"></a>文章转载</h2><p><a href="https://www.jianshu.com/p/31dfb595170c" target="_blank" rel="noopener">https://www.jianshu.com/p/31dfb595170c</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring-Cloud的主要组件&quot;&gt;&lt;a href=&quot;#Spring-Cloud的主要组件&quot; class=&quot;headerlink&quot; title=&quot;Spring Cloud的主要组件&quot;&gt;&lt;/a&gt;Spring Cloud的主要组件&lt;/h2&gt;&lt;p&gt;Spring Clo
      
    
    </summary>
    
    
    
      <category term="SpringCloud" scheme="https://kanchai.club/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>springboot应用部署至k8s</title>
    <link href="https://kanchai.club/2020/06/24/springboot%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E8%87%B3k8s/"/>
    <id>https://kanchai.club/2020/06/24/springboot%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E8%87%B3k8s/</id>
    <published>2020-06-24T03:32:49.774Z</published>
    <updated>2020-06-24T03:30:16.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：qingmu  </p><p>qingmu.io/2020/04/08/Spring-Boot-Operator-User-Guide/</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Kubernetes中部署spring boot应用整体上来说是一件比较繁琐的事情，而Spring Boot Operator则能带给你更清爽简单的体验。</p><p>Spring Boot Operator基于Kubernetes的custom resource definitions (CRDs)扩展API进行的开发。</p><h2 id="打包Docker镜像"><a href="#打包Docker镜像" class="headerlink" title="打包Docker镜像"></a>打包Docker镜像</h2><p>在讲部署之前我们需要先将我们的SpringBoot应用打包成标准的DockerImage。</p><p>java项目打包镜像用maven/gradle插件比较多，我的另一篇文章构建SpringBoot的Docker镜像，这里在介绍一个新的google开源的插件Jib，该插件使用起来比较方便。</p><blockquote><p>注意：jib打包的镜像会导致java应用的pid=1，在使用SpringBootOperator进行发布时候，Operator会设置kubernetes的ShareProcessNamespace参数为true（v1.10+版本都可使用）来解决该问题。</p></blockquote><p>下面就来演示一下我们通过<a href="https://start.spring.io生成一个标准的SpringBoot项目operator-demo,然后使用jib插件进行镜像打包" target="_blank" rel="noopener">https://start.spring.io生成一个标准的SpringBoot项目operator-demo,然后使用jib插件进行镜像打包</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mvn com.google.cloud.tools:jib-maven-plugin:build </span><br><span class="line">-Djib.to.auth.username&#x3D;$&#123;&#123; secrets.MY_USERNAME &#125;&#125; </span><br><span class="line">-Djib.to.auth.password&#x3D;$&#123;&#123; secrets.MY_PASSWORD &#125;&#125; </span><br><span class="line">-Djib.container.jvmFlags&#x3D;--add-opens,java.base&#x2F;sun.nio.ch&#x3D;ALL-UNNAMED </span><br><span class="line">-Djib.from.image&#x3D;freemanliu&#x2F;oprenjre:11.0.5 </span><br><span class="line">-Dimage&#x3D;registry.cn-shanghai.aliyuncs.com&#x2F;qingmuio&#x2F;operator-demo&#x2F;operator-demo:v1.0.0</span><br></pre></td></tr></table></figure><p>执行上面的命令之后我们将得到一个标准的docker镜像，该镜像会被推送到远程仓库。</p><h2 id="Operator快速体验"><a href="#Operator快速体验" class="headerlink" title="Operator快速体验"></a>Operator快速体验</h2><p>完成了镜像的构建之后,我们紧接着来安装我们的Operator到kubernetes集群，当然了首先你需要一套集群，可以参考我之前一篇文章部署高可用kubernetes，虽然版本比较老,但是新版本其实也差不多的一个思路。</p><blockquote><p><a href="https://qingmu.io/2019/05/17/Deploy-a-highly-available-cluster-with-kubeadm/" target="_blank" rel="noopener">https://qingmu.io/2019/05/17/Deploy-a-highly-available-cluster-with-kubeadm/</a></p></blockquote><h3 id="快速安装"><a href="#快速安装" class="headerlink" title="快速安装"></a>快速安装</h3><p>此处快速安装只是为了快速体验demo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;goudai&#x2F;spring-boot-operator&#x2F;master&#x2F;manifests&#x2F;deployment.yaml</span><br></pre></td></tr></table></figure><p>apply成功之后控制台输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">namespace&#x2F;spring-boot-operator-system created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io&#x2F;springbootapplications.springboot.qingmu.io created</span><br><span class="line">role.rbac.authorization.k8s.io&#x2F;spring-boot-operator-leader-election-role created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io&#x2F;spring-boot-operator-manager-role created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io&#x2F;spring-boot-operator-proxy-role created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io&#x2F;spring-boot-operator-metrics-reader created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io&#x2F;spring-boot-operator-leader-election-rolebinding created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io&#x2F;spring-boot-operator-manager-rolebinding created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io&#x2F;spring-boot-operator-proxy-rolebinding created</span><br><span class="line">service&#x2F;spring-boot-operator-controller-manager-metrics-service created</span><br><span class="line">deployment.apps&#x2F;spring-boot-operator-controller-manager created</span><br></pre></td></tr></table></figure><p>稍等片刻查看是否已经安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl  get po -n spring-boot-operator-system</span><br></pre></td></tr></table></figure><p>成功如下输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NAME                                                       READY   STATUS    RESTARTS   AGEspring-boot-operator-controller-manager-7f498596bb-wcwtn   2&#x2F;2     Running   0          2m15s</span><br></pre></td></tr></table></figure><h3 id="部署OperatorDemo应用"><a href="#部署OperatorDemo应用" class="headerlink" title="部署OperatorDemo应用"></a>部署OperatorDemo应用</h3><p>完成了Operator的部署之后，我们来部署我们第一个应用，这里我们就发布上面我们编写的springboot应用opreator-demo。</p><p>首先我们需要先编写一个Spring Boot Application 的CRD部署yaml，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Demo.yaml</span><br><span class="line">apiVersion: springboot.qingmu.io&#x2F;v1alpha1</span><br><span class="line">kind: SpringBootApplication</span><br><span class="line">metadata:</span><br><span class="line">  name: operator-demo </span><br><span class="line">spec:</span><br><span class="line">  springBoot:</span><br><span class="line">    version: v1.0.0</span><br><span class="line">#    image: registry.cn-shanghai.aliyuncs.com&#x2F;qingmuio&#x2F;operator-demo&#x2F;operator-demo:v1.0.0</span><br></pre></td></tr></table></figure><p>细心的同学可能发现了，为啥连Image都没有？这怎么发布，就name，version，就能完成发布？是的没错！就能完成发布，后面我讲详细讲到他是如何完成的。</p><p>接着我们apply一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f Demo.yaml</span><br></pre></td></tr></table></figure><p>看到console输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">springbootapplication.springboot.qingmu.io&#x2F;operator-demo created</span><br></pre></td></tr></table></figure><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>表示创建成功了，接着我们来看下我们部署的第一个应用，这里我们直接用上面的yaml中的name过滤即可。</p><p>查看pod</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~# kubectl  get po | grep operator-demo</span><br><span class="line">operator-demo-7574f4789c-mg58m             1&#x2F;1     Running   0          76s</span><br><span class="line">operator-demo-7574f4789c-ssr8v             1&#x2F;1     Running   0          76s</span><br><span class="line">operator-demo-7574f4789c-sznww             1&#x2F;1     Running   0          76s</span><br></pre></td></tr></table></figure><p>查看下我们的pid不等于1的设置是否生效,根据下面的结果可以看到通过设置ShareProcessNamespace该参数我们可以在Kubernetes层面来解决这个pid=1的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -it operator-demo-7574f4789c-mg58m bash</span><br><span class="line">bash-5.0# ps -ef</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 02:06 ?        00:00:00 &#x2F;pause</span><br><span class="line">root         6     0 26 02:06 ?        00:00:09 java --add-opens java.base&#x2F;sun.nio.ch&#x3D;ALL-UNNAMED -cp &#x2F;app&#x2F;resources:&#x2F;app&#x2F;classes:&#x2F;app&#x2F;libs&#x2F;* io.qingmu.operator.operatordemo.Oper...</span><br><span class="line">root        38     0  0 02:07 pts&#x2F;0    00:00:00 bash</span><br><span class="line">root        44    38  0 02:07 pts&#x2F;0    00:00:00 ps -ef</span><br></pre></td></tr></table></figure><p>查看svc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~# kubectl  get svc | grep operator-demo</span><br><span class="line">operator-demo             ClusterIP   10.101.128.6     &lt;none&gt;        8080&#x2F;TCP            2m52s</span><br></pre></td></tr></table></figure><p>我们来访问一下试试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@server1:~# curl -i http:&#x2F;&#x2F;10.101.128.6:8080</span><br><span class="line">HTTP&#x2F;1.1 200 </span><br><span class="line">Content-Type: text&#x2F;plain;charset&#x3D;UTF-8</span><br><span class="line">Content-Length: 9</span><br><span class="line">Date: Wed, 08 Apr 2020 08:45:46 GMT</span><br><span class="line"></span><br><span class="line">hello !!!</span><br></pre></td></tr></table></figure><p>我们来试着缩减他的副本数到1个</p><p>编辑我们的Demo.yaml，加入一个新的属性replicas</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Demo.yaml</span><br><span class="line">apiVersion: springboot.qingmu.io&#x2F;v1alpha1</span><br><span class="line">kind: SpringBootApplication</span><br><span class="line">metadata:</span><br><span class="line">  name: operator-demo </span><br><span class="line">spec:</span><br><span class="line">  springBoot:</span><br><span class="line">    version: v1.0.0</span><br><span class="line">    replicas: 1</span><br></pre></td></tr></table></figure><p>应用一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@server1:~# kubectl apply -f Demo.yaml </span><br><span class="line">springbootapplication.springboot.qingmu.io&#x2F;operator-demo configured</span><br></pre></td></tr></table></figure><p>再次查看pod，你会发现我们的pod已经缩放为一个副本了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~# kubectl  get po | grep operator-demo</span><br><span class="line">operator-demo-7574f4789c-sznww             1&#x2F;1     Running   0          8m29s</span><br></pre></td></tr></table></figure><h3 id="清理operator-demo"><a href="#清理operator-demo" class="headerlink" title="清理operator-demo"></a>清理operator-demo</h3><p>要删除该pod 我们只需要执行delete即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~# kubectl delete -f Demo.yaml </span><br><span class="line">springbootapplication.springboot.qingmu.io &quot;operator-demo&quot; deleted</span><br></pre></td></tr></table></figure><p>再次查看pod，已经没了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl  get po | grep operator-demo</span><br></pre></td></tr></table></figure><h2 id="部署自己的应用"><a href="#部署自己的应用" class="headerlink" title="部署自己的应用"></a>部署自己的应用</h2><p>部署自己私有仓库的应用需要需要先创建secret(如果已经创建跳过即可)</p><p>创建docker-registry的secret</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubectl create  </span><br><span class="line">secret docker-registry aliyun-registry-secret </span><br><span class="line">--docker-server&#x3D;registry-vpc.cn-hangzhou.aliyuncs.com </span><br><span class="line">--docker-username&#x3D;*** </span><br><span class="line">--docker-password&#x3D;*** </span><br><span class="line">--docker-email&#x3D;***</span><br></pre></td></tr></table></figure><p>自己应用的crd Yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: springboot.qingmu.io&#x2F;v1alpha1</span><br><span class="line">kind: SpringBootApplication</span><br><span class="line">metadata:</span><br><span class="line">  name: 你的应用的名称</span><br><span class="line">spec:</span><br><span class="line">  springBoot:</span><br><span class="line">    version: v1.0.0</span><br><span class="line">    replicas: 1 </span><br><span class="line">    image: 你的image地址</span><br><span class="line">    imagePullSecrets: </span><br><span class="line">      - 上面创建的secret</span><br></pre></td></tr></table></figure><h2 id="一个完整的Spring-Boot-Application-Yaml"><a href="#一个完整的Spring-Boot-Application-Yaml" class="headerlink" title="一个完整的Spring Boot Application Yaml"></a>一个完整的Spring Boot Application Yaml</h2><p>下面是一个完整的yaml属性结构，大部分属性我们都可以用默认配置的即可。推荐：<a href="http://mp.weixin.qq.com/s?__biz=MzIyNDU2ODA4OQ==&mid=2247484532&idx=1&sn=1c243934507d79db4f76de8ed0e5727f&chksm=e80db202df7a3b14fe7077b0fe5ec4de4088ce96a2cde16cbac21214956bd6f2e8f51193ee2b&scene=21#wechat_redirect" target="_blank" rel="noopener">一百期Java面试题汇总</a></p><p>不设置属性，默认使用Operator中设置的通用值详见后面的自定义安装Operator。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: springboot.qingmu.io&#x2F;v1alpha1</span><br><span class="line">kind: SpringBootApplication</span><br><span class="line">metadata:</span><br><span class="line">  name: operator-demo</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  springBoot:</span><br><span class="line">    # image 可以不设置，如果不设置默认使用 IMAGE_REPOSITORY+&#x2F;+mate.name+:+spec.springBoot.version</span><br><span class="line">    # registry.cn-shanghai.aliyuncs.com&#x2F;qingmuio + &#x2F; + operator-demo + : + v1.0.0</span><br><span class="line">    image: registry.cn-shanghai.aliyuncs.com&#x2F;qingmuio&#x2F;operator-demo:v1.0.0</span><br><span class="line">    clusterIp: &quot;&quot; </span><br><span class="line">    version: v1.0.0 </span><br><span class="line">    replicas: 1 </span><br><span class="line">    resource:</span><br><span class="line">      cpu:</span><br><span class="line">        request: 50m</span><br><span class="line">        limit: &quot;&quot; </span><br><span class="line">      memory:</span><br><span class="line">        request: 1Gi</span><br><span class="line">        limit: 1Gi </span><br><span class="line">    path:</span><br><span class="line">      liveness: &#x2F;actuator&#x2F;health </span><br><span class="line">      readiness: &#x2F;actuator&#x2F;health </span><br><span class="line">      hostLog: &#x2F;var&#x2F;applog </span><br><span class="line">      shutdown: &#x2F;spring&#x2F;shutdown </span><br><span class="line">    imagePullSecrets: </span><br><span class="line">      - aliyun-docker-registry-secret</span><br><span class="line">    env: </span><br><span class="line">      - name: EUREKA_SERVERS</span><br><span class="line">        value: http:&#x2F;&#x2F;eureka1:8761&#x2F;eureka&#x2F;,http:&#x2F;&#x2F;eureka2:8761&#x2F;eureka&#x2F;,http:&#x2F;&#x2F;eureka3:8761&#x2F;eureka&#x2F;</span><br><span class="line">    nodeAffinity: </span><br><span class="line">      key: &quot;failure-domain.beta.kubernetes.io&#x2F;zone&quot;</span><br><span class="line">      operator: &quot;In&quot;</span><br><span class="line">      values:</span><br><span class="line">        - &quot;cn-i&quot;</span><br><span class="line">        - &quot;cn-h&quot;</span><br><span class="line">        - &quot;cn-g&quot;</span><br></pre></td></tr></table></figure><h3 id="优雅停机的路径"><a href="#优雅停机的路径" class="headerlink" title="优雅停机的路径"></a>优雅停机的路径</h3><p>由于优雅停机默认是关闭的并且并不支持Get请求所以我们需要开启和搭个桥</p><p>首先在application.yml中启用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &quot;*&quot;</span><br><span class="line">  endpoint:</span><br><span class="line">    shutdown:</span><br><span class="line">      enabled: true</span><br></pre></td></tr></table></figure><p>然后桥接一个Get方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class ShutdownController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ShutdownEndpoint shutdownEndpoint;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;spring&#x2F;shutdown&quot;)</span><br><span class="line">    public Map&lt;String, String&gt; shutdown(HttpServletRequest request) &#123;</span><br><span class="line">        return shutdownEndpoint.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="node亲和的使用"><a href="#node亲和的使用" class="headerlink" title="node亲和的使用"></a>node亲和的使用</h3><p>举一个列子 我们有一个springboot应用 user-service 希望他能分布到3个可用区的6个节点上:</p><p>首先我们把机器划分多个可用区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cn-i区(node-i1,node-i02)</span><br><span class="line">cn-h区(node-g1,node-g02)</span><br><span class="line">cn-g区(node-h1,node-h02)</span><br></pre></td></tr></table></figure><p>现在我们有三个可以区 每个区有2台workload，一共6台。然后我们需要给这些机器分别打上label。</p><p>将全部的i区机器标注为cn-i</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl label node node-i1 failure-domain.beta.kubernetes.io&#x2F;zone&#x3D;cn-i</span><br><span class="line">kubectl label node node-i2 failure-domain.beta.kubernetes.io&#x2F;zone&#x3D;cn-i</span><br></pre></td></tr></table></figure><p>同理将h区的标注为h，g区同理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl label node node-h1 failure-domain.beta.kubernetes.io&#x2F;zone&#x3D;cn-i</span><br><span class="line">kubectl label node node-ih2 failure-domain.beta.kubernetes.io&#x2F;zone&#x3D;cn-i</span><br></pre></td></tr></table></figure><p>现在准备工作我们就绪了，现在我们来设置让它达到我们的调度效果，像如下编写即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spec:</span><br><span class="line">  springBoot:</span><br><span class="line">    nodeAffinity: #可以不设置 节点亲和 这里演示的是尽量将pod分散到 i h g 三个可用区，默认设置了pod反亲和</span><br><span class="line">      key: &quot;failure-domain.beta.kubernetes.io&#x2F;zone&quot;</span><br><span class="line">      operator: &quot;In&quot;</span><br><span class="line">      values:</span><br><span class="line">        - &quot;cn-i&quot;</span><br><span class="line">        - &quot;cn-h&quot;</span><br><span class="line">        - &quot;cn-g&quot;</span><br></pre></td></tr></table></figure><h2 id="Operator-自定义安装"><a href="#Operator-自定义安装" class="headerlink" title="Operator 自定义安装"></a>Operator 自定义安装</h2><p>上面我们快速的安装了好了，接着我们来讲解下如何自定义安装，以及有哪些自定义的参数，可以个性化的参数我们用环境变量的方式注入。</p><p>下面来修改Deployment完成自己个性化的配置部署，从我提供的部署yaml中拉倒最后，找到name是spring-boot-operator-controller-manager的Deployment，我们将修改它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps&#x2F;v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    control-plane: controller-manager</span><br><span class="line">  name: spring-boot-operator-controller-manager</span><br><span class="line">  namespace: spring-boot-operator-system</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">        #注意：一下配置针对通用全局的spring boot默认配置，对crd的spring boot生效，这里不配置也可以在部署的yaml中指定</span><br><span class="line"></span><br><span class="line">        # 私有仓库的地址，比如我的最终打包的镜像地址是 registry.cn-shanghai.aliyuncs.com&#x2F;qingmuio&#x2F;operator-demo&#x2F;operator-demo:v1.0.0</span><br><span class="line">        # 那么配置的值是 registry.cn-shanghai.aliyuncs.com&#x2F;qingmuio&#x2F;operator-demo</span><br><span class="line">        # 配置这个值之后，我们我们如果在发布的yaml中不写image，那么使用的image就是 IMAGE_REPOSITORY+&quot;&#x2F;&quot;+mate.name+spec.springBoot.version</span><br><span class="line">        - name: IMAGE_REPOSITORY</span><br><span class="line">          value: registry.cn-shanghai.aliyuncs.com&#x2F;qingmuio</span><br><span class="line">        # 请求CPU限制</span><br><span class="line">        - name: REQUEST_CPU</span><br><span class="line">          value: 50m</span><br><span class="line">        # 限制最大能用最大CPU java应用可以不用限制，限制不合理会导致启动异常缓慢</span><br><span class="line">        - name: LIMIT_CPU</span><br><span class="line">          value: &quot;&quot;</span><br><span class="line">        # 请求内存大小</span><br><span class="line">        - name: REQUEST_MEMORY</span><br><span class="line">          value: 500Mi</span><br><span class="line">        # 限制最大内存大小 一般和request一样大即可</span><br><span class="line">        - name: LIMIT_MEMORY</span><br><span class="line">          value: 500Mi</span><br><span class="line">        # 就绪检查Path，spring boot actuator 默认Path</span><br><span class="line">        - name: READINESS_PATH</span><br><span class="line">          value: &#x2F;actuator&#x2F;health</span><br><span class="line">        # 就绪存活Path，spring boot actuator 默认Path</span><br><span class="line">        - name: LIVENESS_PATH</span><br><span class="line">          value: &#x2F;actuator&#x2F;health</span><br><span class="line">        # 就绪存活Path，优雅停机Path</span><br><span class="line">        - name: SHUTDOWN_PATH</span><br><span class="line">          value: &#x2F;spring&#x2F;shutdown</span><br><span class="line">        # 复制级 即副本数</span><br><span class="line">        - name: REPLICAS</span><br><span class="line">          value: &quot;3&quot;</span><br><span class="line">        # 将日志外挂到主机磁盘Path，默认两者相同</span><br><span class="line">        - name: HOST_LOG_PATH</span><br><span class="line">          value: &#x2F;var&#x2F;applog</span><br><span class="line">        # 用于pull 镜像的secrets</span><br><span class="line">        - name: IMAGE_PULL_SECRETS</span><br><span class="line">          value: &quot;&quot;</span><br><span class="line">        # 用于pull 镜像的secrets</span><br><span class="line">        - name: SPRING_BOOT_DEFAULT_PORT</span><br><span class="line">          value: &quot;8080&quot;</span><br><span class="line">        # node亲和，比如我可以设置pod尽量分散在不同可用区cn-i,cn-g,cn-h区</span><br><span class="line">        - name: NODE_AFFINITY_KEY</span><br><span class="line">          value: &quot;&quot;</span><br><span class="line">        - name: NODE_AFFINITY_OPERATOR</span><br><span class="line">          value: &quot;&quot;</span><br><span class="line">        - name: NODE_AFFINITY_VALUES</span><br><span class="line">          value: &quot;&quot;</span><br><span class="line">        # 全局的环境变量，会追加到每个spring boot的每个pod中，格式 k&#x3D;v;k1&#x3D;v2,</span><br><span class="line">        # 如 EUREKA_SERVERS&#x3D;http:&#x2F;&#x2F;eureka1:8761&#x2F;eureka&#x2F;,http:&#x2F;&#x2F;eureka2:8761&#x2F;eureka&#x2F;,http:&#x2F;&#x2F;eureka3:8761&#x2F;eureka&#x2F;;k&#x3D;v</span><br><span class="line">        - name: SPRING_BOOT_ENV</span><br><span class="line">          value: &quot;&quot;</span><br><span class="line">        image: registry.cn-shanghai.aliyuncs.com&#x2F;qingmuio&#x2F;spring-boot-operator-controller:latest</span><br></pre></td></tr></table></figure><h3 id="自定义安装之后部署"><a href="#自定义安装之后部署" class="headerlink" title="自定义安装之后部署"></a>自定义安装之后部署</h3><p>yaml可以简化为如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: springboot.qingmu.io&#x2F;v1alpha1</span><br><span class="line">kind: SpringBootApplication</span><br><span class="line">metadata:</span><br><span class="line">  name: 你的应用的名称</span><br><span class="line">spec:</span><br><span class="line">  springBoot:</span><br><span class="line">    version: v1.0.0</span><br></pre></td></tr></table></figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>环境变量表格</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/06/java5-1592962224.png" alt="部署SpringBoot应用到K8S教程" title="部署SpringBoot应用到K8S教程"></p><h2 id="Github仓库"><a href="#Github仓库" class="headerlink" title="Github仓库"></a>Github仓库</h2><blockquote><p>SpringBootOperator: <a href="https://github.com/goudai/spring-boot-operator" target="_blank" rel="noopener">https://github.com/goudai/spring-boot-operator</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;作者：qingmu  &lt;/p&gt;
&lt;p&gt;qingmu.io/2020/04/08/Spring-Boot-Operator-User-Guide/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;
      
    
    </summary>
    
    
    
      <category term="架构" scheme="https://kanchai.club/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="运维" scheme="https://kanchai.club/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="部署" scheme="https://kanchai.club/tags/%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>讲讲熔断</title>
    <link href="https://kanchai.club/2020/06/02/%E8%AE%B2%E8%AE%B2%E7%86%94%E6%96%AD/"/>
    <id>https://kanchai.club/2020/06/02/%E8%AE%B2%E8%AE%B2%E7%86%94%E6%96%AD/</id>
    <published>2020-06-02T06:31:28.003Z</published>
    <updated>2020-06-02T06:31:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>当我们工作所在的系统处于分布式系统初期的时候，往往这时候每个服务都只部署了一个节点。  </p><p>那么在这样的背景下，如果某个服务A需要发布一个新版本，往往会对正在运行的其它依赖服务A的程序产生影响。甚至，一旦服务A的启动预热过程耗时过长，问题会更严重，大量请求会阻塞，产生级联影响，导致整个系统卡慢。</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2018/12/java1-1544436073.jpg" alt="如何在到处是“雷”的系统中「明哲保身」？这是第一招" title="如何在到处是“雷”的系统中「明哲保身」？这是第一招"></p><p>▲点击图片可查看大图</p><p>举个夸张的例子来形容：一幢楼的下水管是从最高楼直通到最低楼的，这个时候如果你家楼下的管道口堵住了，那么所有楼上的污水就会倒灌到你家。如果这导致你家的管道口也堵住了，之后又会倒灌到楼上一层，以此类推。  </p><p>然而实际生活中一旦你发现了这个问题，必然会想办法先避免影响到自己家，然后跑到楼下让他们赶紧疏通管道。此时，避免影响自己家的办法就可被称之为「<strong>熔断</strong>」。</p><p><strong>熔断是什么</strong></p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2018/12/java10-1544436074.png" alt="如何在到处是“雷”的系统中「明哲保身」？这是第一招" title="如何在到处是“雷”的系统中「明哲保身」？这是第一招"></p><p><strong>熔断本质上是一个过载保护机制</strong>。这一概念来源于电子工程中的断路器，可能你曾经被这个东西的“跳闸”保护过。</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2018/12/java7-1544436074.jpeg" alt="如何在到处是“雷”的系统中「明哲保身」？这是第一招" title="如何在到处是“雷”的系统中「明哲保身」？这是第一招"></p><p>▲图片来源于网络，版权归原作者所有</p><p>在互联网系统中的熔断机制是指：当下游服务因访问压力过大而响应变慢或失败，上游服务为了保护自己以及系统整体的可用性，可以暂时切断对下游服务的调用。</p><p>做熔断的思路大体上就是：<strong>一个中心思想，分四步走</strong>。</p><p><strong>熔断怎么做</strong></p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2018/12/java2-1544436074.png" alt="如何在到处是“雷”的系统中「明哲保身」？这是第一招" title="如何在到处是“雷”的系统中「明哲保身」？这是第一招"></p><p>首先，需秉持的一个中心思想是：量力而行。因为软件和人不同，没有奇迹会发生，什么样的性能撑多少流量是固定的。这是根本。</p><p>然后，这四步走分别是：</p><ol><li><p>定义一个识别是否处于“不可用”状态的策略</p></li><li><p>切断联系</p></li><li><p>定义一个识别是否处于“可用”状态的策略，并尝试探测</p></li><li><p>重新恢复正常</p></li></ol><h4 id="定义一个识别是否处于“不正常”状态的策略"><a href="#定义一个识别是否处于“不正常”状态的策略" class="headerlink" title="定义一个识别是否处于“不正常”状态的策略"></a><strong>定义一个识别是否处于“不正常”状态的策略</strong></h4><p>相信软件开发经验丰富的你也知道，识别一个系统是否正常，无非是两个点。</p><ul><li><p>是不是能调通</p></li><li><p>如果能调通，耗时是不是超过预期的长</p></li></ul><p>但是，由于分布式系统被建立在一个并不是100%可靠的网络上，所以上述的情况总有发生，因此我们不能将偶发的瞬时异常等同于系统“不可用”（避免以偏概全）。由此我们需要引入一个「<strong>时间窗口</strong>」的概念，这个时间窗口用来“放宽”判定“不可用”的区间，也意味着多给了系统几次证明自己“可用”机会。但是，如果系统还是在这个时间窗口内达到了你定义“不可用”标准，那么我们就要“断臂求生”了。</p><p>这个标准可以有两种方式来指定。</p><ul><li><p>阈值。比如，在10秒内出现100次“无法连接”或者出现100次大于5秒的请求。</p></li><li><p>百分比。比如，在10秒内有30%请求“无法连接”或者30%的请求大于5秒。</p></li></ul><p>最终会形成这样这样的一段代码。</p><p>全局变量 errorcount = 0; //有个独立的线程每隔10秒（时间窗口）重置为0。全局变量 isOpenCircuitBreaker = false;//do some thing…if(success){    return success; }else{     errorcount++;    if(errorcount == 不可用阈值){         isOpenCircuitBreaker = true;     } }</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="切断联系"><a href="#切断联系" class="headerlink" title="切断联系"></a><strong>切断联系</strong></h4><p>切断联系要尽可能的“果断”，既然已经认定了对方“不可用”，那么索性就默认“失败”，避免做无用功，也顺带能缓解对方的压力。</p><p>分布式系统中的程序间调用，一般都会通过一些RPC框架进行。</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2018/12/java5-1544436075.png" alt="如何在到处是“雷”的系统中「明哲保身」？这是第一招" title="如何在到处是“雷”的系统中「明哲保身」？这是第一招"></p><p>那么，这个时候作为客户端一方，<strong>在自己进程内通过代理发起调用之前就可以直接返回失败，不走网络</strong>。</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2018/12/java8-1544436075.png" alt="如何在到处是“雷”的系统中「明哲保身」？这是第一招" title="如何在到处是“雷”的系统中「明哲保身」？这是第一招"></p><p>这就是常说的「<strong>fail fast</strong>」机制。就是在前面提到的代码段之前增加下面的这段代码。</p><p>if(isOpenCircuitBreaker == true){    return fail; }  //do some thing…</p><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h4 id="定义一个识别是否处于“可用”状态的策略，并尝试探测"><a href="#定义一个识别是否处于“可用”状态的策略，并尝试探测" class="headerlink" title="定义一个识别是否处于“可用”状态的策略，并尝试探测"></a><strong>定义一个识别是否处于“可用”状态的策略，并尝试探测</strong></h4><p>切断联系后，功能的完整性必然会受影响，所以还是需要尽快恢复回来，以提供完整的服务能力。这事肯定不能人为去干预，及时性必然会受到影响。那么如何能够自动的识别依赖系统是否“可用”呢？这也需要你来定义一个策略。</p><p>一般来说这个策略与识别“不可用”的策略类似，只是这里是一个反向指标。</p><ul><li><p>阈值。比如，在10秒内出现100次“调用成功”并且耗时都小于1秒。</p></li><li><p>百分比。比如，在10秒内有95%请求“调用成功”并且98%的请求小于1秒。</p></li></ul><p>同样包含「时间窗口」、「阈值」以及「百分比」。</p><p>稍微不同的地方在于，大多数情况下，一个系统“不可用”的状态往往会持续一段时间，不会那么快就恢复过来。所以我们不需要像第一步中识别“不可用”那样，无时无刻的记录请求状况，而只需要在每隔一段时间之后去进行探测即可。所以，这里多了一个「<strong>间隔时间</strong>」的概念。这个间隔幅度可以是固定的，比如30秒。也可以是动态增加的，通过线性增长或者指数增长等方式。</p><p>这个用代码表述大致是这样。</p><p>全局变量 successCount = 0; //有个独立的线程每隔10秒（时间窗口）重置为0。//并且将下面的isHalfOpen设为false。全局变量 isHalfOpen = true;//有个独立的线程每隔30秒（间隔时间）重置为true。//do some thing…if(success){    if(isHalfOpen){         successCount ++;        if(successCount = 可用阈值){            isOpenCircuitBreaker = false;         }     }          return success; }else{     errorcount++;    if(errorcount == 不可用阈值){        isOpenCircuitBreaker = true;     } }</p><p>另外，<strong>尝试探测本质上是一个“试错”，要控制下“试错成本”</strong>。所以我们不可能拿100%的流量去验证，一般会有以下两种方式：</p><ol><li><p>放行一定比例的流量去验证。</p></li><li><p>如果在整个通信框架都是统一的情况下，还可以统一给每个系统增加一个专门用于验证程序健康状态检测的独立接口。这个接口额外可以多返回一些系统负载信息用于判断健康状态，如CPU、I/O的情况等。</p></li></ol><h4 id="重新恢复正常"><a href="#重新恢复正常" class="headerlink" title="重新恢复正常"></a><strong>重新恢复正常</strong></h4><p>一旦通过了衡量是否“可用”的验证，整个系统就恢复到了“正常”状态，此时需要重新开启识别“不可用”的策略。就这样，系统会形成一个循环。</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2018/12/java9-1544436075.jpg" alt="如何在到处是“雷”的系统中「明哲保身」？这是第一招" title="如何在到处是“雷”的系统中「明哲保身」？这是第一招"></p><p>▲点击图片可查看大图</p><p>这就是一个完整的熔断机制的面貌。了解了这些核心思想，用什么框架去实施就变得不是那么重要了，因为大部分都是换汤不换药。</p><p>上面聊到的这些可以说是主干部分，还有一些最佳实践可以让你在实施熔断的时候拿捏的更到位。</p><p><strong>做熔断的最佳实践</strong></p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2018/12/java8-1544436075-1.png" alt="如何在到处是“雷”的系统中「明哲保身」？这是第一招" title="如何在到处是“雷”的系统中「明哲保身」？这是第一招"></p><h4 id="什么场景最适合做熔断"><a href="#什么场景最适合做熔断" class="headerlink" title="什么场景最适合做熔断"></a><strong>什么场景最适合做熔断</strong></h4><p>一个事物在不同的场景里会发挥出不同的效果。以下是我能想到最适合熔断发挥更大优势的几个场景：</p><ul><li><p>所依赖的系统本身是一个共享系统，当前客户端只是其中的一个客户端。这是因为，如果其它客户端进行胡乱调用也会影响到你的调用。</p></li><li><p>所以依赖的系统被部署在一个共享环境中（资源未做隔离），并不独占使用。比如，和某个高负荷的数据库在同一台服务器上。</p></li><li><p>所依赖的系统是一个经常会迭代更新的服务。这点也意味着，越“敏捷”的系统越需要“熔断”。</p></li><li><p>当前所在的系统流量大小是不确定的。比如，一个电商网站的流量波动会很大，你能抗住突增的流量不代表所依赖的后端系统也能抗住。这点也反映出了我们在软件设计中带着“面向怀疑”的心态的重要性。</p></li></ul><h4 id="做熔断时还要注意的一些地方"><a href="#做熔断时还要注意的一些地方" class="headerlink" title="做熔断时还要注意的一些地方"></a><strong>做熔断时还要注意的一些地方</strong></h4><p>与所有事物一样，熔断也不是一个完美的事物，我们特别需要注意2个问题。</p><p>首先，如果所依赖的系统是多副本或者做了分区的，那么要注意其中<strong>个别节点的异常并不等于所有节点都存在异常</strong>，所以需要区别对待。</p><p>其次，<strong>熔断往往应作为最后的选择，我们应优先使用一些「降级」或者「限流」方案</strong>。因为“部分胜于无”，虽然无法提供完整的服务，但尽可能的降低影响是要持续去努力的。比如，抛弃非核心业务、给出友好提示等等，这部分内容我们会在后续的文章中展开。</p><p><strong>总结</strong></p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2018/12/java7-1544436075.png" alt="如何在到处是“雷”的系统中「明哲保身」？这是第一招" title="如何在到处是“雷”的系统中「明哲保身」？这是第一招"></p><p>本文主要聊了熔断的作用以及做法，并且总结了一些我自己的最佳实践。</p><p>上面的这些代码示例中也可以看到，熔断代码所在的位置要么在实际方法之前，要么在实际方法之后。它非常适合AOP编程思想的发挥，所以我们平常用到的熔断框架都会基于AOP去做。</p><p>熔断只是一个保护壳，在周围出现异常的时候保全自身。但是从长远来看平时定期做好压力测试才能更好的防范于未然，降低触发熔断的次数。如果清楚的知道每个系统有几斤几两，在这个基础上再把「<strong>限流</strong>」和「<strong>降级</strong>」做好，这基本就将“高压”下触发熔断的概率降到最低了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我们工作所在的系统处于分布式系统初期的时候，往往这时候每个服务都只部署了一个节点。  &lt;/p&gt;
&lt;p&gt;那么在这样的背景下，如果某个服务A需要发布一个新版本，往往会对正在运行的其它依赖服务A的程序产生影响。甚至，一旦服务A的启动预热过程耗时过长，问题会更严重，大量请求会阻塞
      
    
    </summary>
    
    
    
      <category term="架构" scheme="https://kanchai.club/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>想通关「限流」？只要这一篇</title>
    <link href="https://kanchai.club/2020/06/02/%E6%83%B3%E9%80%9A%E5%85%B3%E3%80%8C%E9%99%90%E6%B5%81%E3%80%8D%EF%BC%9F%E5%8F%AA%E8%A6%81%E8%BF%99%E4%B8%80%E7%AF%87/"/>
    <id>https://kanchai.club/2020/06/02/%E6%83%B3%E9%80%9A%E5%85%B3%E3%80%8C%E9%99%90%E6%B5%81%E3%80%8D%EF%BC%9F%E5%8F%AA%E8%A6%81%E8%BF%99%E4%B8%80%E7%AF%87/</id>
    <published>2020-06-02T06:18:42.596Z</published>
    <updated>2020-06-02T06:18:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇中我们聊到了「熔断」（<a href="http://mp.weixin.qq.com/s?__biz=MzU2NzEwMDc4OQ==&mid=2247484035&idx=1&sn=a428aea971c6e1420b81d1687f0f31d1&chksm=fca31699cbd49f8f980e6be89a09cccd9c76edfdf965bc3abbcd41ad8179151c6200500584e2&scene=21#wechat_redirect" target="_blank" rel="noopener"><em>如何在到处是“雷”的系统中「明哲保身」？这是第一招</em></a>），有熔断机制的系统，它对可用性的作用至少保证了不会全盘崩溃。</p><p>但是你可以想象一个稍微极端一点的场景，如果系统流量不是很稳定，导致频繁触发熔断的话，是不是意味着系统一直熔断的三种状态中不断切换。</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2018/12/java0-1544436084.jpg" alt="想通关「限流」？只要这一篇" title="想通关「限流」？只要这一篇"></p><p>导致的结果是每次从开启熔断到关闭熔断的期间，必然会导致大量的用户无法正常使用。系统层面的可用性大致是这样的。</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2018/12/java3-1544436084.jpg" alt="想通关「限流」？只要这一篇" title="想通关「限流」？只要这一篇"></p><p>另外，从资源利用率上也会很容易发现，波谷的这段时期资源是未充分利用的。</p><p>由此可见，光有熔断是远远不够的。</p><p>在高压下，只要系统没宕机，如果能将接收的流量持续保持在高位，但又不超过系统所能承载的上限，会是更有效率的运作模式，因为会将这里的波谷填满。</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2018/12/java4-1544436084.jpg" alt="想通关「限流」？只要这一篇" title="想通关「限流」？只要这一篇"></p><p>在如今的互联网已经作为社会基础设施的大环境下，上面的这个场景其实离我们并不是那么远，同时也会显得没那么极端。例如，层出不穷的营销玩法，一个接着一个的社会热点，以及互联网冰山之下的黑产、刷子的蓬勃发展，更加使得这个场景变的那么的需要去考虑、去顾忌。因为随时都有可能会涌入超出你预期的流量，然后压垮你的系统。</p><p>那么限流的作用就很显而易见了：<strong>只要系统没宕机，系统只是因为资源不够，而无法应对大量的请求，为了保证有限的系统资源能够提供最大化的服务能力，因而对系统按照预设的规则进行流量（</strong><em><strong>输出或输入</strong></em><strong>）限制的一种方法，确保被接收的流量不会超过系统所能承载的上限。</strong></p><p><strong>一、怎么做「限流」</strong></p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2018/12/java0-1544436085.png" alt="想通关「限流」？只要这一篇" title="想通关「限流」？只要这一篇"></p><p>从前面聊到的内容中我们也知道，限流最好能“限”在一个系统处理能力的上限附近，所以：</p><ol><li><p>通过「压力测试」等方式<strong>获得系统的能力上限</strong>在哪个水平是第一步。</p></li><li><p>其次，就是<strong>制定干预流量的策略</strong>。比如标准该怎么定、是否只注重结果还是也要注重过程的平滑性等。</p></li><li><p>最后，就是<strong>处理“被干预掉”的流量</strong>。能不能直接丢弃？不能的话该如何处理？</p></li></ol><p><strong>获得系统能力的上限</strong></p><p>第一步不是我们这次内容的重点，说起来就是对系统做一轮压测。可以在一个独立的环境进行，也可以直接在生产环境的多个节点中选择一个节点作为样本来压测，当然需要做好与其他节点的隔离。</p><p><strong>一般我们做压测为了获得2个结果，「速率」和「并发数」</strong>。前者表示在一个时间单位内能够处理的请求数量，比如xxx次请求/秒。后者表示系统在同一时刻能处理的最大请求数量，比如xxx次的并发。从指标上需要获得「最大值」、「平均值」或者「中位数」。后续限流策略需要设定的具体标准数值就是从这些指标中来的。</p><blockquote><p>题外话：从精益求精的角度来说，其他的诸如cpu、网络带宽以及内存的耗用也可以作为参照因素。</p></blockquote><p><strong>制定干预流量的策略</strong></p><p><strong>常用的策略就4种，我给它起了一个简单的定义——「两窗两桶」</strong>。两窗就是：固定窗口、滑动窗口，两桶就是：漏桶、令牌桶。</p><p><em><strong>固定窗口</strong></em></p><p>固定窗口就是定义一个“固定”的统计周期，比如1分钟或者30秒、10秒这样。然后在每个周期统计当前周期中被接收到的请求数量，经过计数器累加后如果达到设定的阈值就触发「流量干预」。直到进入下一个周期后，计数器清零，流量接收恢复正常状态。</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2018/12/java2-1544436085.jpg" alt="想通关「限流」？只要这一篇" title="想通关「限流」？只要这一篇"></p><p>这个策略最简单，写起代码来也没几行。</p><blockquote><p>全局变量 int totalCount = 0;  //有一个「固定周期」会触发的定时器将数值清零。</p><p>if(totalCount &gt; 限流阈值) {</p><pre><code>return; //不继续处理请求。</code></pre><p>}</p><p>totalCount++;</p><p>// do something…</p></blockquote><p>固定窗口有一点需要注意的是，<strong>假如请求的进入非常集中，那么所设定的「限流阈值」等同于你需要承受的最大并发数</strong>。所以，如果需要顾忌到并发问题，那么这里的「固定周期」设定的要尽可能的短。因为，这样的话「限流阈值」的数值就可以相应的减小。甚至，限流阈值就可以直接用并发数来指定。比如，假设固定周期是3秒，那么这里的阈值就可以设定为「平均并发数*3」。</p><p>不过不管怎么设定，固定窗口永远存在的缺点是：<strong>由于流量的进入往往都不是一个恒定的值，所以一旦流量进入速度有所波动，要么计数器会被提前计满，导致这个周期内剩下时间段的请求被“限制”。要么就是计数器计不满，也就是「限流阈值」设定的过大，导致资源无法充分利用</strong>。</p><p>「滑动窗口」可以改善这个问题。</p><p><strong><em>滑动窗口</em></strong></p><p>滑动窗口其实就是对固定窗口做了进一步的细分，将原先的粒度切的更细，比如1分钟的固定窗口切分为60个1秒的滑动窗口。然后统计的时间范围随着时间的推移同步后移。</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2018/12/java1-1544436085.jpg" alt="想通关「限流」？只要这一篇" title="想通关「限流」？只要这一篇"></p><p>同时，我们还可以得出一个结论是：<strong>如果固定窗口的「固定周期」已经很小了，那么使用滑动窗口的意义也就没有了</strong>。举个例子，现在的固定窗口周期已经是1秒了，再切分到毫秒级别能反而得不偿失，会带来巨大的性能和资源损耗。</p><p>滑动窗口大致的代码逻辑是这样：</p><blockquote><p>全局数组 链表[]  counterList = new 链表[切分的滑动窗口数量];  </p><p>//有一个定时器，在每一次统计时间段起点需要变化的时候就将索引0位置的元素移除，并在末端追加一个新元素。</p><p>int sum = counterList.Sum();</p><p>if(sum &gt; 限流阈值) {</p><pre><code>return; //不继续处理请求。</code></pre><p>}</p><p>int 当前索引 = 当前时间的秒数 % 切分的滑动窗口数量;</p><p>counterList[当前索引]++;</p><p>// do something…</p></blockquote><p>虽然说滑动窗口可以改善这个问题，但是本质上还是预先划定时间片的方式，属于一种“预测”，意味着几乎肯定无法做到100%的物尽其用。</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2018/12/java6-1544436086.jpg" alt="想通关「限流」？只要这一篇" title="想通关「限流」？只要这一篇"></p><p>但是，「桶」模式可以做的更好，因为「桶」模式中多了一个缓冲区（_桶本身_）。</p><p><em><strong>漏桶</strong></em></p><p>首先聊聊「漏桶」吧。<strong>漏桶模式的核心是固定“出口”的速率</strong>，不管进来多少量，出去的速率一直是这么多。如果涌入的量多到桶都装不下了，那么就进行「流量干预」。</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2018/12/java9-1544436087.jpg" alt="想通关「限流」？只要这一篇" title="想通关「限流」？只要这一篇"></p><p>整个实现过程我们来分解一下。</p><ol><li><p>控制流出的速率。这个其实可以使用前面提到的两个“窗口”的思路来实现。如果当前速率小于阈值则直接处理请求，否则不直接处理请求，进入缓冲区，并增加当前水位。</p></li><li><p>缓冲的实现可以做一个短暂的休眠或者记录到一个容器中再做异步的重试。</p></li><li><p>最后控制桶中的水位不超过最大水位。这个很简单，就是一个全局计数器，进行加加减减。</p></li></ol><p>这样一来，你会发现本质就是：<strong>通过一个缓冲区将不平滑的流量“整形”成平滑的（</strong><em><strong>高于均值的流量暂存下来补足到低于均值的时期</strong></em><strong>），以此最大化计算处理资源的利用率</strong>。</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2018/12/java7-1544436087.jpg" alt="想通关「限流」？只要这一篇" title="想通关「限流」？只要这一篇"></p><p>实现代码的简化表示如下：</p><blockquote><p>全局变量 int unitSpeed;  //出口当前的流出速率。每隔一个速率计算周期（比如1秒）会触发定时器将数值清零。  </p><p>全局变量 int waterLevel; //当前缓冲区的水位线。</p><p>if(unitSpeed &lt; 速率阈值) {</p><pre><code>unitSpeed++;//do something...</code></pre><p>}</p><p>else{</p><pre><code>if\(waterLevel &gt; 水位阈值\)\{    return; //不继续处理请求。\}waterLevel++;while\(unitSpeed &gt;= 速率阈值\)\{    sleep\(一小段时间\)。\}unitSpeed++;waterLevel--;//do something...</code></pre><p>}</p></blockquote><p>更优秀的「漏桶」策略已经可以在流量的总量充足的情况下发挥你所预期的100%处理能力，但这还不是极致。</p><p>你应该知道，一个程序所在的运行环境中，往往不单单只有这个程序本身，会存在一些系统进程甚至是其它的用户进程。也就是说，程序本身的处理能力是会被干扰的，是会变化的。所以，你可以预估某一个阶段内的平均值、中位数，但无法预估具体某一个时刻的程序处理能力。又因此，你必然会使用相对悲观的标准去作为阈值，防止程序超负荷。</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2018/12/java9-1544436088.jpg" alt="想通关「限流」？只要这一篇" title="想通关「限流」？只要这一篇"></p><p>那么从资源利用率来说，有没有更优秀的方案呢？有，这就是「令牌桶」。</p><p><em><strong>令牌桶</strong></em></p><p><strong>令牌桶模式的核心是固定“进口”速率</strong>。先拿到令牌，再处理请求，拿不到令牌就被「流量干预」。因此，<strong>当大量的流量进入时，只要令牌的生成速度大于等于请求被处理的速度，那么此刻的程序处理能力就是极限</strong>。</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2018/12/java5-1544436088.jpg" alt="想通关「限流」？只要这一篇" title="想通关「限流」？只要这一篇"></p><p>也来分解一下它的实现过程。</p><ol><li><p>控制令牌生成的速率，并放入桶中。这个其实就是单独一个线程在不断的生成令牌。</p></li><li><p>控制桶中待领取的令牌水位不超过最大水位。这个和「漏桶」一样，就是一个全局计数器，进行加加减减。</p></li></ol><p>大致的代码简化表示如下（_看上去像「固定窗口」的反向逻辑_）：</p><blockquote><p>全局变量 int tokenCount = 令牌数阈值; //可用令牌数。有一个独立的线程用固定的频率增加这个数值，但不大于「令牌数阈值」。  </p><p>if(tokenCount == 0){</p><pre><code>return; //不继续处理请求。</code></pre><p>}</p><p>tokenCount–;</p><p>//do something…</p></blockquote><p>聪明的你可能也会想到，这样一来<strong>令牌桶的容量大小理论上就是程序需要支撑的最大并发数</strong>。的确如此，假设同一时刻进入的流量将令牌取完，但是程序来不及处理，将会导致事故发生。</p><p>所以，没有真正完美的策略，只有合适的策略。因此，根据不同的场景能够识别什么是最合适的策略是更需要锻炼的能力。下面z哥分享一些我个人的经验。</p><p><strong>二、**</strong>做「限流」的最佳实践**</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2018/12/java3-1544436088.png" alt="想通关「限流」？只要这一篇" title="想通关「限流」？只要这一篇"></p><p><strong>四种策略该如何选择？</strong>  </p><p>首先，<strong>固定窗口</strong>。一般来说，<strong>如非时间紧迫，不建议选择这个方案</strong>，太过生硬。但是，为了能快速止损眼前的问题可以作为临时应急的方案。</p><p>其次，<strong>滑动窗口</strong>。这个方案<strong>适用于对异常结果「高容忍」的场景</strong>，毕竟相比“两窗”少了一个缓冲区。但是，胜在实现简单。</p><p>然后，<strong>漏桶</strong>。z哥觉得这个方案<strong>最适合作为一个通用方案</strong>。虽说资源的利用率上不是极致，但是「宽进严出」的思路在保护系统的同时还留有一些余地，使得它的适用场景更广。</p><p>最后，<strong>令牌桶</strong>。当你<strong>需要尽可能的压榨程序的性能</strong>（_此时桶的最大容量必然会大于等于程序的最大并发能力_），并且所处的场景流量进入波动不是很大（_不至于一瞬间取完令牌，压垮后端系统_）。</p><p><strong>分布式系统中带来的新挑战</strong></p><p>一个成熟的分布式系统大致是这样的。</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2018/12/java7-1544436089.jpg" alt="想通关「限流」？只要这一篇" title="想通关「限流」？只要这一篇"></p><p>每一个上游系统都可以理解为是其下游系统的客户端。然后我们回想一下前面的内容，可能你发现了，前面聊的「限流」都没有提到到底是在客户端做限流还是服务端做，甚至看起来更倾向是建立在服务端的基础上做。但是你知道，在一个分布式系统中，一个服务端本身就可能存在多个副本，并且还会提供给多个客户端调用，甚至其自身也会作为客户端角色。那么，在如此交错复杂的一个环境中，该如何下手做限流呢？我的思路是通过「<strong>一纵一横</strong>」来考量。</p><p><strong><em>纵</em></strong></p><p>都知道「限流」是一个保护措施，那么可以将它想象成一个盾牌。另外，一个请求在系统中的处理过程是链式的。那么，正如古时候军队打仗一样，盾牌兵除了有小部分在老大周围保护，剩下的全在最前线。因为<strong>盾的位置越前，能受益的范围越大</strong>。</p><p>分布式系统中最前面的是什么？接入层。如果你的系统有接入层，比如用nginx做的反向代理。那么可以通过它的ngx_http_limit_conn_module以及ngx_http_limit_req_module来做限流，是很成熟的一个解决方案。</p><p>如果没有接入层，那么只能在应用层以AOP的思路去做了。但是，由于应用是分散的，出于成本考虑你需要针对性的去做限流。比如ToC的应用必然比ToB的应用更需要做，高频的缓存系统必然比低频的报表系统更需要做，Web应用由于存在Filter的机制做起来必然比Service应用更方便。</p><p>那么应用间的限流到底是做到客户端还是服务端呢？</p><p>z哥的观点是，从效果上客户端模式肯定是优于服务端模式的，因为当处于被限流状态的时候，客户端模式连建立连接的动作都省了。另一个潜在的好处是，与集中式的服务端模式相比，可以把少数的服务端程序的压力分散掉。但是在客户端做成本也更高，因为它是去中心化的，假如需要多个节点之间的数据共通的话，是一个很麻烦的事情。</p><p>所以，最终z哥建议你：如果<strong>考虑成本就服务端模式，考虑效果就客户端模式</strong>。当然也不是绝对，比如一个服务端的流量大部分都来源于某一个客户端，那么就可以直接在这个客户端做限流，这也不失为一个好方案。</p><p>数据库层面的话，一般连接字符串中本身就会包含「最大连接数」的概念，就可以起到限流的作用。如果想做更精细的控制就只能做到统一封装的数据库访问层框架中了。</p><p>聊完了「纵」，那么「横」是什么呢？</p><p><em><strong>横</strong></em></p><p>不管是多个客户端，还是同一个服务端的多个副本。每个节点的性能必然会存在差异，如何设立合适的阈值？以及如何让策略的变更尽可能快的在集群中的多个节点生效？说起来很简单，引入一个性能监控平台和配置中心。但这些真真要做好不容易，后续我们再展开这块内容。</p><p><strong>三、总结</strong></p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2018/12/java9-1544436089.png" alt="想通关「限流」？只要这一篇" title="想通关「限流」？只要这一篇"></p><p>限流就好比保险丝，根据你制定的标准，达到了就拉闸。</p><p>不过，触发限流后的措施除了直接丢弃请求之外，还有一个方式是「降级」，那么降级有哪些方式呢？我们下一篇再聊吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在上一篇中我们聊到了「熔断」（&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NzEwMDc4OQ==&amp;mid=2247484035&amp;idx=1&amp;sn=a428aea971c6e1420b81d1687f0f31d1&amp;chksm=f
      
    
    </summary>
    
    
    
      <category term="架构" scheme="https://kanchai.club/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>浅谈微服务</title>
    <link href="https://kanchai.club/2020/05/12/%E6%B5%85%E8%B0%88%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>https://kanchai.club/2020/05/12/%E6%B5%85%E8%B0%88%E5%BE%AE%E6%9C%8D%E5%8A%A1/</id>
    <published>2020-05-12T00:59:59.760Z</published>
    <updated>2020-05-12T00:59:06.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>来源：后端技术杂谈</p><p><a href="http://www.rowkey.me/blog/2019/05/30/msa/" target="_blank" rel="noopener">www.rowkey.me/blog/2019/05/30/msa/</a></p></blockquote><p>这几年在Java工程师招聘时，会看到很多人的简历都写着使用了Spring Cloud做微服务实现，使用Docker做自动化部署，并且也会把这些做为自己的亮点。而比较有趣的这其中以小公司出来的人为绝大多数，大的公司出来的人简历上倒是很少提这些东西。</p><p>对于我自己来说，从15年就开始关注这一块，看过马丁.福勒最开始的关于微服务的论文、也看过不少对微服务的论证的英文文章和书，也研究过Spring Cloud、Sofa等开源实现以及Service mesh。考虑到我们公司研发团队人力不足、基础设施不完善，当初是没有推行微服务的。但随着看到上述的那种简历越来越多，有时候我也会疑问：难道真的不用微服务就落后了吗？公司的同事如果不掌握这些就真的没有竞争力了吗。而随着最近公司业务的逐步提升，研发人员越来越多，借着在梳理公司的微服务落地计划时，也梳理了一下微服务的相关知识点，也是本文的主要内容。</p><p>开篇之前先声明我对微服务的几点态度:</p><blockquote><p>★</p><ol><li>架构模式有很多，微服务不是唯一的选择也不是什么银弹。国内绝大多数中小公司引入微服务都是在盲目追新，也能看出做此种技术选型的工程师基础架构素质的不足。</li><li>“你必须长的足够高才能使用微服务”。微服务基础设施，尤其是容器技术、自动化部署、自动化测试这些不完备，微服务形同虚设，不会带来什么质的提升。</li><li>微服务架构的关键不在于具体的实现，而在于如何合理地划分服务边界以及组织架构是否相匹配。不考虑研发团队的规模和组成就盲目上微服务是不良的技术选型。</li><li>Spring Boot是Spring全家桶的上层封装，并不是什么崭新的技术，也不是什么值得觉得成为自己杀手锏的技术。</li><li>Spring Cloud中Spring Cloud Netflix的组件是经过生产环境验证的，其他的则建议慎重选择。</li></ol><p>”</p></blockquote><h2 id="微服务是什么"><a href="#微服务是什么" class="headerlink" title="微服务是什么"></a>微服务是什么</h2><p>微服务起源于2005年Peter Rodgers博士在云端运算博览会提出的微Web服务(Micro-Web-Service)，根本思想类似于Unix的管道设计理念。2014年，由Martin Fowler 与 James Lewis共同提出了微服务的概念，定义了微服务架构风格是一种通过一套小型服务来开发单个应用的方法，每个服务运行在自己的进程中，并通过轻量级的机制进行通讯（HTTP API）。关键的三点是<strong>small、automated以及lightweight</strong>。</p><p>对比SOA，微服务可以看做是SOA的子集，是轻量级的SOA，粒度更细的服务，独立进程、数据分离，更注重<strong>敏捷、持续交付、DevOps以及去中心化实践</strong>。其共同的<strong>架构原理</strong>：</p><ul><li>单一职责</li><li>关注分离：控制与逻辑相分离</li><li>模块化和分而治之</li></ul><p><strong>特点</strong>：</p><ul><li>用服务进行组件化</li><li>围绕业务能力进行组织</li><li>是产品而非项目</li><li>端点智能化和哑管道: 控制逻辑都在端点，管道仅仅是传输</li><li>全自动化部署</li><li>语言和数据的去中心化控制</li><li>面向失败设计</li><li>渐进式设计</li></ul><p>综合来看，其优缺点如下：</p><p><strong>优点</strong>：</p><ul><li>模块的强边界</li><li>独立部署</li><li>技术选型的多样性</li></ul><p><strong>缺点</strong>：</p><ul><li>分布式带来编程复杂度，远程调用的消耗</li><li>舍弃强一致性，实现最终一致性</li><li>操作复杂性要求有一个成熟的运维团队或者运维基础设施</li></ul><h2 id="为什么要采用微服务"><a href="#为什么要采用微服务" class="headerlink" title="为什么要采用微服务"></a>为什么要采用微服务</h2><p>是否选择微服务取决于你要设计的系统的复杂度。微服务是用来把控复杂系统的，但是随之而来的就是引入了微服务本身的复杂度。需要解决包括自动化部署、监控、容错处理、最终一致性等其他分布式系统面临的问题。即使已经有一些普遍使用的解决方案，但是仍然是有不小的成本的。</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/03/java10-1583638183.jpg" alt="鸟瞰微服务架构" title="鸟瞰微服务架构"></p><p>生产力和复杂度的关系如图所示，可见系统越复杂，微服务带来的收益越大。此外，无论是单体应用还是微服务，团队的技能都需要能够把控住。</p><p>马丁.福勒的一个观点是：除非管理单体应用的成本已经太复杂了（太大导致很难修改和部署），否则都不要考虑微服务。大部分应用都应该选择单体架构，做好单体应用的模块化而不是拆分成服务。</p><p>因此，<strong>系统一开始采用单体架构，做好模块化，之后随着系统变得越来越复杂、模块/服务间的边界越来越清晰，再重构为微服务架构是一个合理的架构演化路径。</strong></p><p><strong>四个可以考虑上微服务的情况</strong>：</p><ol><li>多人开发一个模块/项目，提交代码频繁出现大量冲突。</li><li>模块间严重耦合，互相依赖，每次变动需要牵扯多个团队，单次上线需求太多，风险大。</li><li>主要业务和次要业务耦合，横向扩展流程复杂。</li><li>熔断降级全靠if-else。</li></ol><p><strong>微服务的三个阶段</strong>：</p><ol><li>微服务1.0：仅使用注册发现，基于SpringCloud或者Dubbo进行开发。</li><li>微服务2.0：使用了熔断、限流、降级等服务治理策略，并配备完整服务工具和平台。</li><li>微服务3.0：Service Mesh将服务治理作为通用组件，下沉到平台层实现，应用层仅仅关注业务逻辑，平台层可以根据业务监控自动调度和参数调整，实现AIOps和智能调度。</li></ol><h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><ul><li>快速的环境提供能力：依赖于云计算、容器技术，快速交付环境。</li><li>基本的监控能力：包括基础的技术监控和业务监控。</li><li>快速的应用部署能力：需要部署管道提供快速的部署能力。</li><li>Devops文化：需要具有良好的持续交付能力，包括全链路追踪、快速环境提供和部署等，还需要快速的反应能力（对问题、故障的快速响应），开发和运维的协同工作。</li></ul><p>此外，根据康威定律和逆康威定律（技术架构倒逼组织架构改进），组织架构也是一个很关键的因素。对应于微服务架构，组织架构需要遵循以下原则：</p><ol><li>一个微服务由一个团队维护，团队成员以三人为宜。</li><li>单个团队的任务和发展是独立的，不受其他因素影响。</li><li>团队是功能齐全、全栈、自治的，扁平、自我管理。</li></ol><h3 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h3><p>微服务的推行需要依赖于很多底层基础设施，包括提供微服务的编译、集成、打包、部署、配置等工作，采用PaaS平台解决微服务从开发到运行的全生命周期管理，同时提供异构环境管理、容器资源隔离与互通、服务伸缩漂移、服务升级与回退、服务熔断与降级、服务注册与发现。</p><ol><li><p>最基本的基础设施</p><ul><li>进程间通讯机制：微服务是独立进程的，需要确定之间的通讯方式。</li><li>服务发现+服务路由: 提供服务注册中心，服务提供者和消费者通过服务发现获取服务的信息从而调用服务，实现服务的负载均衡等。</li><li>服务容错：微服务架构中，由于服务非常多，往往是一个服务挂了，整个请求链路的服务都受到影响，因此需要服务容错，在服务调用失败的时候能够处理错误或者快速失败，包括熔断、fallback、重试、流控和服务隔离等。</li><li>分布式事务支持：随着业务拆分为服务，那么有时候不可避免的就是跨服务的事务，即分布式事务的问题。原则是尽量避免分布式事务，如果无法避免那么可以使用消息系统或者CQRS和Event Sourcing方案来实现最终一致性。如果需要强一致性，则有两阶段提交、三阶段提交、TCC等分布式事务解决方案。</li></ul></li><li><p>提升外部服务对接效率和内部开发效率</p><ul><li>API网关: 负责外部系统的访问，负责跨横切面的公共层面的工作，包括安全、日志、权限控制、传输加密、请求转发、流量控制等。典型的网关功能即对外暴露一个域名xx.com，根据第一级目录做反向路由xx.com/user，xx.com/trade。每一级目录，如user、trade对应一个服务的域名。此外，API网关也可以有服务编排的功能（不推荐）。</li><li>接口框架: 规范服务之间通讯使用的数据格式、解析包、自解释文档，便于服务使用方快速上手等。</li></ul></li><li><p>提升测试和运维效率</p><ul><li>持续集成：这一部分并非是微服务特定的，对于之前的单体应用，此部分一般来说也是必要的。主要是指通过自动化手段，持续地对代码进程编译构建、自动化测试，以得到快速有效的质量反馈，从而保证代码的顺利交付。自动化测试包括代码级别的单元测试、单个系统的集成测试、系统间的接口测试。</li><li>自动化部署：微服务架构，节点数动辄上百上千，自动化部署能够提高部署速度和部署频率，从而保证持续交付。包括版本管理、资源管理、部署操作、回滚操作等功能。而对于微服务的部署方式，包括<strong>蓝绿部署、滚动部署以及金丝雀部署</strong>。</li><li>配置中心: 运行时配置管理能够解决动态修改配置并批量生效的问题。包括配置版本管理、配置项管理、节点管理、配置同步等。</li><li>持续交付：包括持续集成、自动化部署等流程。目的就是小步迭代，快速交付。</li></ul></li><li><p>进一步提升运维效率</p><ul><li>服务监控: 微服务架构下节点数目众多，需要监控的机器、网络、进程、接口等的数量大大增加，需要一个强大的监控系统，能够提供实时搜集信息进行分析以及实时分析之上的预警。包括监控服务的<strong>请求次数、响应时间分布、最大/最小响应值、错误码分布</strong>等</li><li>服务跟踪：跟踪一个请求的完整路径，包括<strong>请求发起时间、响应时间、响应码、请求参数、返回结果</strong>等信息，也叫做全链路跟踪。通常的服务监控可以和服务监控做在一起，宏观信息由服务跟踪呈现，微观单个服务/节点的信息由服务监控呈现。服务跟踪目前的实现理论基本都是Google的Dapper论文。</li><li>服务安全：内网之间的微服务调用原则上讲应该是都可以互相访问写，一般并不需要权限控制，但有时候限于业务要求，会对接口、数据等方面有安全控制的要求。此部分可以以配置的方式存在于服务注册中心中，和服务绑定，在请求时由做为服务提供者的服务节点进行安全策略控制。配置则可以存储在配置中心以方便动态修改。</li></ul></li></ol><p>在微服务数量很少的情况下，以上基础设施的优先级自上而下降低。否则，仅仅依赖人工操作，则投入产出比会很低。</p><p>还需要提到的是Docker容器技术。虽然这个对于微服务并不是必须的，但是容器技术<strong>轻量级、灵活、与应用依存、屏蔽环境差异</strong>的特性对于持续交付的实现是至关重要的，即使对于传统的单体应用也能够给其带来交付效率的大幅提升。</p><h3 id="架构设计模式"><a href="#架构设计模式" class="headerlink" title="架构设计模式"></a>架构设计模式</h3><p>在引入微服务之后，传统的单体应用变为了一个一个服务，之前一个应用直接提供接口给客户端访问的架构不再适用。微服务架构下，针对不同设备的接口做为BFF层（Backend For Frontend），也叫做用户体验适配层，负责聚合、编排微服务的数据转换成前端需要的数据。服务之间的调用则在允许的情况下（允许延迟）尽可能使用异步消息传递方式，如此形成<strong>面向用户体验的微服务架构设计模式</strong>。如下图所示：</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/03/java4-1583638183.jpg" alt="鸟瞰微服务架构" title="鸟瞰微服务架构"></p><p><strong>Client -&gt; API Gateway -&gt; BFF（Backend For Frontend） -&gt; Downstream Microservices</strong></p><ul><li>后台采用微服务架构，微服务可以采用不同的编程语言和不同的存储机制。</li><li>前台采用BFF模式对不同的用户体验（如桌面浏览器，Native App，平板响应式Web）进行适配。</li><li>BFF、API Orchestration Layer，Edge Service Layer，Device Wrapper Layer是相同的概念。</li><li>BFF不能过多，过多会造成代码逻辑重复冗余。</li><li>可以将网关承担的功能，如Geoip、限流、安全认证等跨横切面功能和BFF做在同一层，虽然增加了BFF层的复杂性，但能够得到性能优势。</li></ul><h3 id="服务拆分"><a href="#服务拆分" class="headerlink" title="服务拆分"></a>服务拆分</h3><p>微服务架构最核心的环节，主要是对服务的<strong>横向拆分</strong>。服务拆分就是讲一个完整的业务系统解耦为服务，<strong>服务需要职责单一，之间没有耦合关系，能够独立开发和维护</strong>。</p><p>服务拆分不是一蹴而就的，需要在开发过程中不断地理清边界。在完全理清服务之前，尽量推迟对服务的拆分，尤其是对数据库的拆分。</p><p><strong>拆分方法</strong>如下：</p><ul><li>基于业务逻辑拆分</li><li>基于可扩展拆分</li><li>基于可靠性拆分</li><li>基于性能拆分</li></ul><p>其中，对于无法修改的遗留系统，采用绞杀者模式：在遗留系统外面增加新的功能做成微服务方式，而不是直接修改原有系统，逐步的实现对老系统替换。</p><p><strong>拆分过程需要遵守的规范</strong>如下：</p><ul><li>先少后多、先粗后细（粒度）</li><li>服务纵向拆分最多三层，两次调用：Controller、组合服务、基础服务</li><li>仅仅单向调用，禁止循环调用</li><li>串行调用改为并行调用或者异步化</li><li>接口应该幂等</li><li>接口数据定义严禁内嵌，透传</li><li>规范化工程名</li><li>先拆分服务，等服务粒度确定后再拆分数据库。</li></ul><h3 id="微服务框架"><a href="#微服务框架" class="headerlink" title="微服务框架"></a>微服务框架</h3><p>上面讲述了微服务架构的众多基础设施，如果每一个基础设施都需要自己开发的话是非常巨大的开发工作。目前市面上已经有不少开源的微服务框架可以选择。</p><ol><li><p>Spring Boot</p><p>Spring Boot是用来简化新Spring应用的初始搭建以及开发过程的。其虽然不是微服务框架，但其设计的初衷本质就是微应用的底层框架，因此非常适合用于微服务基础设施的开发以及微服务的应用开发。尤其对于Spring技术栈的团队来说，基于Spring Boot开发微服务框架和应用是自然而然的一个选择。</p></li><li><p>Dubbo&amp;&amp;Motan</p><p>Dubbo阿里开源的服务治理框架。其出现在微服务理念兴起之前，可以看做是SOA框架的集大成之作。但其仅仅包含了微服务基础设施的部分功能，诸如熔断、服务跟踪、网关等都没有实现。</p><p>Motan则是微博开源的类似Dubbo的RPC框架，与Dubbo相比更轻量级。</p><ul><li>服务发现 ：服务发布、订阅、通知</li><li>高可用策略 ：失败重试（Failover）、快速失败（Failfast）、资源隔离 - 负载均衡 ：最少活跃连接、一致性 Hash、随机请求、轮询等</li><li>扩展性 ：支持 SPI 扩展（service provider interface）</li><li>其他 ：调用统计、访问日志等</li></ul></li><li><p>Spring Cloud</p><p>Spring Cloud是基于Spring Boot实现的微服务框架，也可以看做一套微服务实现规范。基本涵盖了微服务基础设施的方方面面，包括配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等。其基于Spring生态，社区支持非常好。但其很多组件都没有经过生产环境验证，需要慎重选择。</p><p>Spring Cloud Netflix是Spring Cloud的一个子项目，是Spring对Netflix OSS的集成实现。基于Netflix的大规模使用，其中的已经被广泛使用的组件包括：</p><p>此外，另一个子项目Spring Cloud Alibaba则是Alibaba开源的基于Spring Boot的微服务框架，主要是对阿里云服务的支持。</p><ul><li>Eureka：服务注册和服务发现</li><li>Ribbon：弹性而智能的进程间和服务通讯机制，客户端负载均衡</li><li>Hystrix：熔断器，在运行时提供延迟和容错的隔离</li><li>Zuul: 服务网关</li></ul></li><li><p>Service Mesh</p><p>上述的微服务框架都是侵入式的，服务化的过程都需要进行代码改造。Service Mesh则是下一代微服务架构，最明显的特征就是无入侵。采用sidecar模式来解决系统架构微服务化后的服务间通信和治理问题。</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/03/java8-1583638184.png" alt="鸟瞰微服务架构" title="鸟瞰微服务架构"></p><p>如上图所示，目前主流的开源实现包括：</p><ul><li>Linkerd和Envoy：以 sidecar 为核心，关注如何做好proxy，并完成一些通用控制平面的功能。缺乏对这些sidecar的管理和控制。</li><li>Istio和Conduit：目前最为流行的Service Mesh实现方案，集中在更加强大的控制平面(sidecar被称为数据平面)功能。前者由Google和IBM合作，并使用了Envoy作为sidecar部分的实现；后者则是Linkerd作者的作品。相比起来，Istio有巨头背景，功能强大，但可用性和易用性一直不高，Conduit则相对简单、功能聚焦。</li></ul></li></ol><p>限于Service Mesh带来的性能延迟的开销以及sidecar对分布复杂性的增加，其对大规模部署(微服务数目多)、异构复杂(交互协议/开发语言类型多)的微服务架构带来的收益会更大。</p><p>6. Sofastack</p><p>   蚂蚁金服开源的构建金融级分布式架构的一套中间件。包     括微服务开发框架、RPC框架、服务注册中心、全链路追     踪、服务监控、Service Mesh等一整套分布式应用开发     工具。</p><p>   特别值得一提的是SOFAMesh。其是对下一代微服务架       构Service Mesh的大规模落地方案实践，基于 Istio改     进和扩展而来，应该是国内最为成熟的开源Service         Mesh方案。</p><p>此外，需要提到<strong>Kubernetes(K8s)</strong>，其本身提供了部分的微服务特性支持（通过域名做服务发现），对代码无侵入。但服务调用、熔断这些都需要自己实现。</p><p>综上，目前公司技术团队技术栈是Spring，并且已有服务的实现都是基于Dubbo，因此选择Spring Cloud Netflix做为基础的微服务框架，对其中不成熟或者缺乏的组件，选择业界更为成熟的组件替代即可。</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/03/java7-1583638184.jpg" alt="鸟瞰微服务架构" title="鸟瞰微服务架构"></p><ul><li>API网关：Zuul</li><li>服务注册中心：Dubbo</li><li>配置中心：disconf</li><li>服务监控&amp;&amp;全链路追踪：CAT</li><li>服务开发框架：Spring Boot</li><li>日志监控、告警：ELK + Elasalert</li><li>流量控制：Sentinel</li><li>消息队列：Kafka</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>What’s so bad about monoliths anyway…?!</li><li>Microservice</li><li>MicroservicePremium</li><li>Microservice Trade-Offs</li><li>MicroservicePrerequisites</li><li>MonolithFirst</li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI2MzM3MzkyMg==&mid=2247486544&idx=1&sn=999be8b4f06150b96d9a46ada6bb9ded&chksm=eabd995dddca104bd3c6262d491572f7be9b2a763a43a388f66bd0e90e4bd60e5037727107e4&mpshare=1&scene=21&srcid=0201lT7ZBVBGmTki8bYnmDgl#wechat_redirect" target="_blank" rel="noopener">服务怎么拆？</a></li><li>BFF@SoundCloud</li><li>Service Mesh 及其主流开源实现解析</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;来源：后端技术杂谈&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.rowkey.me/blog/2019/05/30/msa/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.rowkey.me/blog/2019/
      
    
    </summary>
    
    
    
      <category term="JAVA" scheme="https://kanchai.club/tags/JAVA/"/>
    
      <category term="spring" scheme="https://kanchai.club/tags/spring/"/>
    
      <category term="微服务" scheme="https://kanchai.club/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>springmvc实现参数处理，rsa解密数据</title>
    <link href="https://kanchai.club/2020/05/09/springmvc%E5%AE%9E%E7%8E%B0%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86%EF%BC%8Crsa%E8%A7%A3%E5%AF%86%E6%95%B0%E6%8D%AE/"/>
    <id>https://kanchai.club/2020/05/09/springmvc%E5%AE%9E%E7%8E%B0%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86%EF%BC%8Crsa%E8%A7%A3%E5%AF%86%E6%95%B0%E6%8D%AE/</id>
    <published>2020-05-09T07:28:21.503Z</published>
    <updated>2020-05-09T07:28:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>用于实现类似@RequestBody的作用，前后端在没有https的情况下，利用rsa非对称加密，实现数据安全性</p><ol><li><p>首先创建注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RSA加密数据解密</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 李涛</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 2019年06月19日 10:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.PARAMETER&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestEncrypt &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用spring参数处理器，实现接口，拦截该注解的参数，处理并返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理加密数据,参数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 李涛</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 2019年06月19日 10:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerMethodArgumentCustomer</span> <span class="keyword">implements</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(HandlerMethodArgumentCustomer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ISysSignSV sysSignSV;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (parameter.hasParameterAnnotation(RequestEncrypt<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">HttpServletRequest nativeRequest = webRequest.getNativeRequest(HttpServletRequest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">String contentType = nativeRequest.getContentType();</span><br><span class="line"><span class="keyword">if</span> (!contentType.equals(MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">&amp;&amp; !contentType.equals(MediaType.APPLICATION_JSON_UTF8_VALUE)</span><br><span class="line">) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> MediaTypeNotSupportedStatusException(<span class="string">"期望请求为application/json"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加密数据</span></span><br><span class="line"><span class="keyword">byte</span>[] body = ServletUtils.getRequestBody();</span><br><span class="line">String jsonData = IOUtils.toString(body);</span><br><span class="line"><span class="keyword">if</span> (body.length == <span class="number">0</span> || StringUtils.isBlank(jsonData) || jsonData.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取当前登录用户的公私钥。如果没空，在header里取</span></span><br><span class="line">Object appKeyObj = ShiroUtil.getSession().getAttribute(Global.APP_KEY);</span><br><span class="line">Object appSercetObj = ShiroUtil.getSession().getAttribute(Global.APP_SERCET);</span><br><span class="line">String appKey = appKeyObj == <span class="keyword">null</span> ? <span class="keyword">null</span> : String.valueOf(appKeyObj);</span><br><span class="line">String appSercet = appSercetObj == <span class="keyword">null</span> ? <span class="keyword">null</span> : String.valueOf(appSercetObj);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.isBlank(appKey) || StringUtils.isBlank(appSercet)) &#123;</span><br><span class="line">appKey = ServletUtils.getHeader(<span class="string">"appKey"</span>);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.isBlank(appKey)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 获取私钥</span></span><br><span class="line">SysSign sysSign = sysSignSV.findByModel(SysSignModel.builder().appKey(appKey).includeColumns(<span class="string">"app_secret"</span>).build());</span><br><span class="line">appSercet = sysSign.getAppSecret();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">RSA rs = <span class="keyword">new</span> RSA(appSercet, appKey);</span><br><span class="line"><span class="keyword">byte</span>[] decrypt = rs.decrypt(jsonData, KeyType.PrivateKey);</span><br><span class="line">jsonData = IOUtils.toString(decrypt);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">LOG.error(<span class="string">"Rsa加密数据解密异常"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> JSONObject.parseObject(jsonData, parameter.getParameterType());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将参数处理器，加入到spring的拦截器调用链</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向MVC中添加自定义组件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HandlerMethodArgumentCustomer handlerMethodArgumentCustomer;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; resolvers)</span> </span>&#123;</span><br><span class="line">        resolvers.add(handlerMethodArgumentCustomer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用于实现类似@RequestBody的作用，前后端在没有https的情况下，利用rsa非对称加密，实现数据安全性&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先创建注解&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
    
    
      <category term="轮子" scheme="https://kanchai.club/tags/%E8%BD%AE%E5%AD%90/"/>
    
      <category term="JAVA" scheme="https://kanchai.club/tags/JAVA/"/>
    
      <category term="spring" scheme="https://kanchai.club/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>解决PropertySource不能读取yml的问题</title>
    <link href="https://kanchai.club/2020/05/09/%E8%A7%A3%E5%86%B3PropertySource%E4%B8%8D%E8%83%BD%E8%AF%BB%E5%8F%96yml%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://kanchai.club/2020/05/09/%E8%A7%A3%E5%86%B3PropertySource%E4%B8%8D%E8%83%BD%E8%AF%BB%E5%8F%96yml%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-05-09T07:19:57.986Z</published>
    <updated>2020-05-09T07:19:22.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决PropertySource不能读取yml的问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 李涛</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 2020年03月26日 17:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YamlConfigFactory</span>  <span class="keyword">extends</span> <span class="title">DefaultPropertySourceFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">String sourceName = name != <span class="keyword">null</span> ? name : resource.getResource().getFilename();</span><br><span class="line"><span class="keyword">if</span> (!resource.getResource().exists()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> PropertiesPropertySource(sourceName, <span class="keyword">new</span> Properties());</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sourceName.endsWith(<span class="string">".yml"</span>) || sourceName.endsWith(<span class="string">".yaml"</span>)) &#123;</span><br><span class="line">Properties propertiesFromYaml = loadYml(resource);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> PropertiesPropertySource(sourceName, propertiesFromYaml);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.createPropertySource(name, resource);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Properties <span class="title">loadYml</span><span class="params">(EncodedResource resource)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">YamlPropertiesFactoryBean factory = <span class="keyword">new</span> YamlPropertiesFactoryBean();</span><br><span class="line">factory.setResources(resource.getResource());</span><br><span class="line">factory.afterPropertiesSet();</span><br><span class="line"><span class="keyword">return</span> factory.getObject();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户自定义配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 李涛</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 2019年07月05日 16:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@PropertySource</span>(value=<span class="string">"classpath:file-table-config.yml"</span>,factory = YamlConfigFactory<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConfigurationProperties</span>(<span class="title">prefix</span> </span>= <span class="string">"config"</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileTableConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 表达式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String corn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 表和资源字段</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; tables;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
    
      <category term="轮子" scheme="https://kanchai.club/tags/%E8%BD%AE%E5%AD%90/"/>
    
      <category term="JAVA" scheme="https://kanchai.club/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>超长JVM总结</title>
    <link href="https://kanchai.club/2020/05/08/%E8%B6%85%E9%95%BFJVM%E6%80%BB%E7%BB%93/"/>
    <id>https://kanchai.club/2020/05/08/%E8%B6%85%E9%95%BFJVM%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-08T08:08:34.062Z</published>
    <updated>2020-05-08T08:08:21.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM"></a>什么是JVM</h3><p>JVM 是可运行 Java 代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收，堆 和 一个存储方法域。JVM 是运行在操作系统之上的，它与硬件没有直接的交互。</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/04/java7-1588125197.png" alt="超长JVM总结,面试必备" title="超长JVM总结,面试必备">在这里插入图片描述</p><p>我们都知道 Java 源文件，通过编译器，能够生产相应的.Class 文件，也就是字节码文件，而字节码文件又通过 Java 虚拟机中的解释器，编译成特定机器上的机器码 。  </p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/04/java9-1588125197.png" alt="超长JVM总结,面试必备" title="超长JVM总结,面试必备">在这里插入图片描述</p><p>每一种平台的解释器是不同的，但是实现的虚拟机是相同的，这也就是 Java 为什么能够跨平台的原因了 ，当一个程序从开始运行，这时虚拟机就开始实例化了，多个程序启动就会存在多个虚拟机实例。程序退出或者关闭，则虚拟机实例消亡，多个虚拟机实例之间数据不能共享。  </p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/04/java8-1588125198.jpeg" alt="超长JVM总结,面试必备" title="超长JVM总结,面试必备">在这里插入图片描述</p><h6 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h6><p>这里所说的线程指程序执行过程中的一个线程实体。JVM 允许一个应用并发执行多个线程 。Hotspot JVM 中的 Java 线程与原生操作系统线程有直接的映射关系。当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。Java 线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它们分配到任何可用的 CPU 上。当原生线程初始化完毕，就会调用 Java 线程的 run() 方法。当线程结束时，会释放原生线程和 Java 线程的所有资源。</p><ul><li><p>Hotspot JVM 后台运行的系统线程主要有下面几个：</p></li><li><p><strong>虚拟机线程</strong>:这个线程等待 JVM 到达安全点操作出现。这些操作必须要在独立的线程里执行，因为当堆修改无法进行时，线程都需要 JVM位于安全点。这些操作的类型有：stop-the-world 垃圾回收、线程栈dump、线程暂停、线程偏向锁（biased  locking）解除。</p></li><li><p><strong>周期性任务线程</strong>:这线程负责定时器事件（也就是中断），用来调度周期性操作的执行。</p></li><li><p><strong>GC 线程</strong>  :这些线程支持 JVM 中不同的垃圾回收活动。</p></li><li><p><strong>编译器线程</strong>:这些线程在运行时将字节码动态编译成本地平台相关的机器码。</p></li><li><p><strong>信号分发线程</strong>:这个线程接收发送到 JVM 的信号并调用适当的 JVM 方法处理。</p></li></ul><h3 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h3><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/04/java9-1588125198.png" alt="超长JVM总结,面试必备" title="超长JVM总结,面试必备">在这里插入图片描述</p><ul><li><p>JVM 内存区域主要分为线程私有区域【<strong>程序计数器、虚拟机栈、本地方法区</strong>】、线程共享区域【<strong>JAVA 堆、方法区</strong>】、直接内存。<br>-<strong>线程私有数据区域生命周期与线程相同</strong>, 依赖用户线程的启动/结束 而 创建/销毁(在 HotspotVM 内, 每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的生/死对应)。</p></li><li><p><strong>线程共享区域</strong>随虚拟机的启动/关闭而创建/销毁。</p></li></ul><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/04/java3-1588125198.png" alt="超长JVM总结,面试必备" title="超长JVM总结,面试必备">在这里插入图片描述</p><h6 id="程序计数器-线程私有）"><a href="#程序计数器-线程私有）" class="headerlink" title="程序计数器( 线程私有）"></a>程序计数器( 线程私有）</h6><ul><li><p>一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有”的内存。</p></li><li><p>正在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址）。如果还是 Native 方法，则为空。</p></li><li><p>这个内存区域是唯一一个在虚拟机中没有规定任OutOfMemoryError 情况的区域。</p></li></ul><h6 id="JAVA虚拟机栈-线程私有"><a href="#JAVA虚拟机栈-线程私有" class="headerlink" title="JAVA虚拟机栈( 线程私有)"></a>JAVA虚拟机栈( 线程私有)</h6><ul><li><p><strong>是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息</strong>。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p></li><li><p>栈帧（ Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接(Dynamic Linking)、 方法返回值和异常分派（ Dispatch Exception）。<strong>栈帧随着方法调用而创建，随着方法结束而销毁</strong>——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。  </p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/04/java0-1588125198.png" alt="超长JVM总结,面试必备" title="超长JVM总结,面试必备">在这里插入图片描述</p></li></ul><h6 id="本地方法区-线程私有）"><a href="#本地方法区-线程私有）" class="headerlink" title="本地方法区(线程私有）"></a>本地方法区(线程私有）</h6><ul><li>本地方法区和 <strong>Java Stack</strong> 作用类似, 区别是虚拟机栈为执行 Java 方法服务, 而<strong>本地方法栈则为Native 方法服务</strong>, 如果一个 VM 实现使用 C-linkage 模型来支持 Native 调用, 那么该栈将会是一个C 栈，但 HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一。</li></ul><h6 id="堆（Heap-线程共享）运行时数据区"><a href="#堆（Heap-线程共享）运行时数据区" class="headerlink" title="堆（Heap- 线程共享）运行时数据区"></a>堆（Heap- 线程共享）运行时数据区</h6><ul><li>是被线程共享的一块内存区域，创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。由于现代 VM 采用分代收集算法, 因此 Java 堆从 GC 的角度还可以细分为: <strong>新生代( Eden 区 、 From Survivor 区 和 To Survivor 区 )和老年代</strong>(jdk1.7)。</li></ul><h6 id="方法区-永久代-（线程共享）"><a href="#方法区-永久代-（线程共享）" class="headerlink" title="方法区/ 永久代 （线程共享）"></a>方法区/ 永久代 （线程共享）</h6><ul><li>即我们常说的永久代(Permanent Generation), 用于存储被 <strong>JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>. HotSpot VM把GC分代收集扩展至方法区, 即使用Java堆的永久代来实现方法区, 这样 HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存,而不必为方法区开发专门的内存管理器(永久带的内存回收的主要目标是针对常量池的回收和类型的卸载, 因此收益一般很小)。</li></ul><h6 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h6><ul><li>（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。Java 虚拟机对 Class 文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。</li></ul><h6 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h6><ul><li>直接内存并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用: 在 JDK 1.4 引入的 NIO 提供了基于 Channel 与 Buffer 的 IO 方式, 它可以使用 Native 函数库直接分配堆外内存, 然后使用DirectByteBuffer 对象作为这块内存的引用进行操作， 这样就避免了在 Java堆和 Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能。</li></ul><h3 id="JVM运行时内存-jdk1-7"><a href="#JVM运行时内存-jdk1-7" class="headerlink" title="JVM运行时内存(jdk1.7)"></a>JVM运行时内存(jdk1.7)</h3><ul><li><p>Java 堆从 GC 的角度还可以细分为: <strong>新生代</strong>( Eden 区 、 From Survivor 区 和 To Survivor 区 )和<strong>老年代</strong>  </p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/04/java2-1588125198.jpeg" alt="超长JVM总结,面试必备" title="超长JVM总结,面试必备">在这里插入图片描述</p></li></ul><h6 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h6><p>是用来存放新生的对象。一般占据堆的1/3空间。由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾回收。新生代又分为 Eden 区、ServivorFrom、ServivorTo 三个区。</p><ul><li><p>Eden区：Java新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当Eden区内存不够的时候就会触发MinorGC，对新生代区进行一次垃圾回收。</p></li><li><p>ServivorFrom：上一次 GC 的幸存者，作为这一次 GC 的被扫描者。</p></li><li><p>ServivorTo：保留了一次 MinorGC 过程中的幸存者。</p></li><li><p>MinorGC 的过程：（复制-&gt;清空-&gt;互换）MinorGC 采用复制算法。</p></li><li><p><strong>eden 、 servicorFrom  复制到 ServicorTo，年龄+1</strong><br>  首先，把 Eden和 ServivorFrom区域中存活的对象复制到 ServicorTo区域（如果有对象的年龄以及达到了老年的(默认15岁，可以通过-XXMaxTenuringThreshold设置)，则赋值到老年代区），同时把这些对象的年龄+1（如果 ServicorTo 不够位置了就放到老年区）。</p></li><li><p><strong>清空 eden 、 servicorFrom</strong>**<br> 清空 Eden 和 ServicorFrom 中的对象；</p></li><li><p><strong>ServicorTo 和 ServicorFrom 互换</strong><br> 最后，ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom区。</p></li></ul><h6 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h6><ul><li><p>主要存放应用程序中生命周期长的内存对象。</p></li><li><p>老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。</p></li><li><p>MajorGC 采用<strong>标记清除算法</strong>：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC 的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常。</p></li></ul><h6 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h6><p>-指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息,Class 在被加载的时候被放入永久区域，它和和存放实例的区域不同,<strong>GC 不会在主程序运行期对永久区域进行清理</strong>。所以这也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常。</p><h6 id="JAVA8-与元数据"><a href="#JAVA8-与元数据" class="headerlink" title="JAVA8 与元数据"></a>JAVA8 与元数据</h6><p>在Java8中，<strong>永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代</strong>。元空间的本质和永久代类似，元空间与永久代之间最大的区别在于：<strong>元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制</strong>。类的元数据放入 nativememory, 字符串池和类的静态变量放入 java 堆中，这样可以加载多少类的元数据就不再由MaxPermSize 控制, 而由系统的实际可用空间来控制。</p><h3 id="垃圾回收与算法"><a href="#垃圾回收与算法" class="headerlink" title="垃圾回收与算法"></a>垃圾回收与算法</h3><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/04/java3-1588125198-1.png" alt="超长JVM总结,面试必备" title="超长JVM总结,面试必备">在这里插入图片描述</p><h4 id="如何确定垃圾"><a href="#如何确定垃圾" class="headerlink" title="如何确定垃圾"></a>如何确定垃圾</h4><h6 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h6><ul><li>在 Java 中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单说，即一个对象如果没有任何与之关联的引用，即他们的引用计数都不为 0，则说明对象不太可能再被用到，那么这个对象就是可回收对象。</li></ul><h6 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h6><ul><li>为了解决引用计数法的循环引用问题，Java 使用了可达性分析的方法。通过一系列的“GC roots”对象作为起点搜索<strong>。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的</strong>。要注意的是，不可达对象不等价于可回收对象，<strong>不可达对象变为可回收对象至少要经过两次标记过程</strong>。两次标记后仍然是可回收对象，则将面临回收。</li></ul><h4 id="标记清除算法（-Mark-Sweep-）"><a href="#标记清除算法（-Mark-Sweep-）" class="headerlink" title="标记清除算法（ Mark-Sweep ）"></a>标记清除算法（ Mark-Sweep ）</h4><ol><li><p>最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。如图  </p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/04/java0-1588125198.jpeg" alt="超长JVM总结,面试必备" title="超长JVM总结,面试必备">在这里插入图片描述</p></li></ol><pre><code>从图中我们就可以发现，该算法最大的问题是内存碎片化严重，后续可能发生大对象不能找到可利用空间的问题。</code></pre><h4 id="复制算法（copying-）"><a href="#复制算法（copying-）" class="headerlink" title="复制算法（copying ）"></a>复制算法（copying ）</h4><ul><li><p>为了解决 Mark-Sweep 算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉，如图：  </p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/04/java6-1588125198.jpeg" alt="超长JVM总结,面试必备" title="超长JVM总结,面试必备">在这里插入图片描述</p></li></ul><p>  这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话，Copying 算法的效率会大大降低。</p><h4 id="标记整理算法-Mark-Compact"><a href="#标记整理算法-Mark-Compact" class="headerlink" title="标记整理算法(Mark-Compact)"></a>标记整理算法(Mark-Compact)</h4><p>结合了以上两个算法，为了避免缺陷而提出。标记阶段和 Mark-Sweep 算法相同，标<strong>记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象</strong>。如图：  </p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/04/java0-1588125198-1.jpeg" alt="超长JVM总结,面试必备" title="超长JVM总结,面试必备">在这里插入图片描述</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><ul><li>分代收集法是目前大部分 JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生(YoungGeneration)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。</li></ul><h5 id="新生代与复制算法"><a href="#新生代与复制算法" class="headerlink" title="新生代与复制算法"></a>新生代与复制算法</h5><ul><li><p>目前大部分 JVM 的 GC 对于新生代都采取 Copying 算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照 1：1 来划分新生代。一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。  </p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/04/java2-1588125198-1.jpeg" alt="超长JVM总结,面试必备" title="超长JVM总结,面试必备">在这里插入图片描述</p></li></ul><h5 id="老年代与标记复制算法"><a href="#老年代与标记复制算法" class="headerlink" title="老年代与标记复制算法"></a>老年代与标记复制算法</h5><p>而老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法。</p><ul><li><p>JAVA 虚拟机提到过的处于<strong>方法区的永生代(Permanet Generation)，它用来存储 class 类，常量，方法描述等</strong>。对永生代的回收主要包括废弃常量和无用的类。</p></li><li><p>对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space(Survivor 目前存放对象的那一块)，少数情况会直接分配到老生代。</p></li><li><p>当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC，进行 GC 后，EdenSpace 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 FromSpace 进行清理。</p></li><li><p>如果 To Space 无法足够存储某个对象，则将这个对象存储到老生代。</p></li><li><p>在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环。</p></li><li><p>当对象在 Survivor 区躲过一次 GC 后，其年龄就会+1。默认情况下年龄到达 15 的对象会被移到老生代中。</p></li></ul><h3 id="GC-分代收集算法-VS-分区收集算法"><a href="#GC-分代收集算法-VS-分区收集算法" class="headerlink" title="GC  分代收集算法 VS  分区收集算法"></a>GC  分代收集算法 VS  分区收集算法</h3><h4 id="分代收集算法-1"><a href="#分代收集算法-1" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>当前主流 JVM 垃圾收集都采用”分代收集”(Generational Collection)算法, 这种算法会根据对象存活周期的不同将内存划分为几块, 如 JVM 中的 <strong>新生代、老年代、永久代</strong>，这样就可以根据各年代特点分别采用最适当的 GC 算法。</p><ul><li><p><strong>在新生代-复制算法</strong><br>每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量存活对象的复制成本就可以完成收集。</p></li><li><p><strong>在老年代-标记整理算法</strong><br>因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“<strong>标记—清理”或“标记—整理”</strong>算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存。</p></li></ul><h4 id="分区收集算法"><a href="#分区收集算法" class="headerlink" title="分区收集算法"></a>分区收集算法</h4><p><strong>分区算法则将整个堆空间划分为连续的不同小区间, 每个小区间独立使用, 独立回收. 这样做的好处是可以控制一次回收多少个小区间</strong> , 根据目标停顿时间, 每次合理地回收若干个小区间(而不是整个堆), 从而减少一次 GC 所产生的停顿。</p><h3 id="GC-垃圾收集器"><a href="#GC-垃圾收集器" class="headerlink" title="GC 垃圾收集器"></a>GC 垃圾收集器</h3><p>Java 堆内存被划分为新生代和年老代两部分，新生代主要使用复制和标记-清除垃圾回收 算法 ,年老代主要使用标记-整理垃圾回收算法，因此 java 虚拟中针对新生代和年老代分别提供了多种不同的垃圾收集器，JDK1.6 中 Sun HotSpot 虚拟机的垃圾收集器如下：  </p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/04/java5-1588125198.jpeg" alt="超长JVM总结,面试必备" title="超长JVM总结,面试必备">在这里插入图片描述</p><h4 id="Serial-垃圾收集器-（单线程、-复制算法-）"><a href="#Serial-垃圾收集器-（单线程、-复制算法-）" class="headerlink" title="Serial  垃圾收集器 （单线程、 复制算法 ）"></a>Serial  垃圾收集器 （单线程、 复制算法 ）</h4><ul><li><strong>Serial（英文连续）是最基本垃圾收集器，使用复制算法</strong>，曾经是JDK1.3.1之前新生代唯一的垃圾收集器。Serial 是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。Serial 垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限定单个 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此 <strong>Serial垃圾收集器依然是 java 虚拟机运行在 Client 模式下默认的新生代垃圾收集器。</strong></li></ul><h4 id="ParNew-垃圾收集器-（Serial-多线程-）"><a href="#ParNew-垃圾收集器-（Serial-多线程-）" class="headerlink" title="ParNew  垃圾收集器 （Serial+ 多线程 ）"></a>ParNew  垃圾收集器 （Serial+ 多线程 ）</h4><ul><li><strong>ParNew 垃圾收集器其实是 Serial 收集器的多线程版本，也使用复制算法</strong>，除了使用多线程进行垃圾收集之外，其余的行为和 Serial 收集器完全一样，ParNew 垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。ParNew 收集器默认开启和 CPU 数目相同的线程数，可以通过-XX:ParallelGCThreads 参数来限制垃圾收集器的线程数。【Parallel：平行的】ParNew虽然是除了多线程外和Serial收集器几乎完全一样，<strong>但是ParNew垃圾收集器是很多java虚拟机运行在 Server 模式下新生代的默认垃圾收集器。</strong></li></ul><h4 id="Parallel-Scavenge-收集器-（多线程复制算法、高效）"><a href="#Parallel-Scavenge-收集器-（多线程复制算法、高效）" class="headerlink" title="Parallel Scavenge  收集器 （多线程复制算法、高效）"></a>Parallel Scavenge  收集器 （多线程复制算法、高效）</h4><ul><li>Parallel Scavenge 收集器也是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃圾收集器，<strong>它重点关注的是程序达到一个可控制的吞吐量</strong>（Thoughput，CPU 用于运行用户代码的时间/CPU 总消耗时间，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)），高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。<strong>自适应调节策略也是 ParallelScavenge 收集器与 ParNew 收集器的一个重要区别。</strong></li></ul><h4 id="Serial-Old-收集器-单线程标记整理算法）"><a href="#Serial-Old-收集器-单线程标记整理算法）" class="headerlink" title="Serial Old  收集器 (单线程标记整理算法）"></a>Serial Old  收集器 (单线程标记整理算法）</h4><p>Serial Old 是 Serial 垃圾收集器年老代版本，它同样是个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在 Client 默认的 java 虚拟机默认的年老代垃圾收集器。在 Server 模式下，主要有两个用途：  </p><ol><li>在 JDK1.5 之前版本中与新生代的 Parallel Scavenge 收集器搭配使用。  </li><li>作为年老代中使用 CMS 收集器的后备垃圾收集方案。<br>新生代 Serial 与年老代 Serial Old 搭配垃圾收集过程图：</li></ol><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/04/java6-1588125198-1.jpeg" alt="超长JVM总结,面试必备" title="超长JVM总结,面试必备">在这里插入图片描述</p><p>新生代 Parallel Scavenge 收集器与 ParNew 收集器工作原理类似，都是多线程的收集器，都使用的是复制算法，在垃圾收集过程中都需要暂停所有的工作线程。新生代 ParallelScavenge/ParNew 与年老代 Serial Old 搭配垃圾收集过程图：                   </p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/04/java5-1588125198-1.jpeg" alt="超长JVM总结,面试必备" title="超长JVM总结,面试必备">在这里插入图片描述</p><h4 id="Parallel-Old-收集器（多线程标记整理算法）"><a href="#Parallel-Old-收集器（多线程标记整理算法）" class="headerlink" title="Parallel Old  收集器（多线程标记整理算法）"></a>Parallel Old  收集器（多线程标记整理算法）</h4><p>Parallel Old收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法，在JDK1.6才开始提供。在 JDK1.6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量，Parallel Old 正是为了在年老代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，可以优先考虑新生代 Parallel Scavenge和年老代 Parallel Old 收集器的搭配策略。新生代 Parallel Scavenge 和年老代 Parallel Old 收集器搭配运行过程图：  </p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/04/java7-1588125198.jpeg" alt="超长JVM总结,面试必备" title="超长JVM总结,面试必备">在这里插入图片描述</p><h4 id="CMS-收集器-（多线程标记清除算法）"><a href="#CMS-收集器-（多线程标记清除算法）" class="headerlink" title="CMS  收集器 （多线程标记清除算法）"></a>CMS  收集器 （多线程标记清除算法）</h4><p>Concurrent mark sweep(CMS)收集器是一种年老代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。CMS 工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下 4 个阶段：<br> <strong>1.初始标记</strong>：只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。<br> <strong>2.并发标记：</strong> 进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。<br> <strong>3.重新标记：</strong> 为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。<br> <strong>4.并发清除：</strong> 清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并<br>发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看<strong>CMS 收集器的内存回收和用户线程是一起并发地执行。</strong>  </p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/04/java7-1588125198-1.jpeg" alt="超长JVM总结,面试必备" title="超长JVM总结,面试必备">在这里插入图片描述</p><h4 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1  收集器"></a>G1  收集器</h4><p>Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器，G1 收<br>集器两个最突出的改进是：</p><ol><li><p>基于标记-整理算法，不产生内存碎片。</p></li><li><p>可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。<br><strong>G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域</strong>，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，<strong>优先回收垃圾最多的区域</strong>。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是JVM&quot;&gt;&lt;a href=&quot;#什么是JVM&quot; class=&quot;headerlink&quot; title=&quot;什么是JVM&quot;&gt;&lt;/a&gt;什么是JVM&lt;/h3&gt;&lt;p&gt;JVM 是可运行 Java 代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收，堆 
      
    
    </summary>
    
    
    
      <category term="JAVA" scheme="https://kanchai.club/tags/JAVA/"/>
    
      <category term="JVM" scheme="https://kanchai.club/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>秒杀系统设计的 5 个要点：前端三板斧＋后端两条路！</title>
    <link href="https://kanchai.club/2020/05/08/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%9A%84_5_%E4%B8%AA%E8%A6%81%E7%82%B9%EF%BC%9A%E5%89%8D%E7%AB%AF%E4%B8%89%E6%9D%BF%E6%96%A7%EF%BC%8B%E5%90%8E%E7%AB%AF%E4%B8%A4%E6%9D%A1%E8%B7%AF%EF%BC%81/"/>
    <id>https://kanchai.club/2020/05/08/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%9A%84_5_%E4%B8%AA%E8%A6%81%E7%82%B9%EF%BC%9A%E5%89%8D%E7%AB%AF%E4%B8%89%E6%9D%BF%E6%96%A7%EF%BC%8B%E5%90%8E%E7%AB%AF%E4%B8%A4%E6%9D%A1%E8%B7%AF%EF%BC%81/</id>
    <published>2020-05-08T07:54:28.590Z</published>
    <updated>2020-05-08T07:53:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：cfyme</p><p><a href="https://www.tuicool.com/articles/JzQvUb" target="_blank" rel="noopener">https://www.tuicool.com/articles/JzQvUb</a></p></blockquote><h2 id="秒杀系统涉及到的知识点："><a href="#秒杀系统涉及到的知识点：" class="headerlink" title="秒杀系统涉及到的知识点："></a>秒杀系统涉及到的知识点：</h2><ul><li><p>高并发，cache，锁机制</p></li><li><p>基于缓存架构redis,Memcached的先进先出队列。</p></li><li><p>稍微大一点的秒杀，肯定是分布式的集群的，并发来自于多个节点的JVM，synchronized所有在JVM上加锁是不行了</p></li><li><p>数据库压力</p></li><li><p>秒杀超卖问题</p></li><li><p>如何防止用户来刷， 黑名单？IP限制？</p></li><li><p>利用memcached的带原子性特性的操作做并发控制.</p></li></ul><h2 id="秒杀简单设计方案如："><a href="#秒杀简单设计方案如：" class="headerlink" title="秒杀简单设计方案如："></a>秒杀简单设计方案如：</h2><p>比如有10件商品要秒杀，可以放到缓存中，读写时不要加锁。当并发量大的时候，可能有25个人秒杀成功，这样后面的就可以直接抛秒杀结束的静态页面。进去的25个人中有15个人是不可能获得商品的。所以可以根据进入的先后顺序只能前10个人购买成功。后面15个人就抛商品已秒杀完。</p><h2 id="假设我们的秒杀场景："><a href="#假设我们的秒杀场景：" class="headerlink" title="假设我们的秒杀场景："></a>假设我们的秒杀场景：</h2><p>比如某商品10件物品待秒. 假设有100台web服务器(假设web服务器是Nginx + Tomcat),n台app服务器,n个数据库</p><ol><li><p>第一步 如果Java层做过滤, 可以在每台web服务器的业务处理模块里做个计数器AtomicInteger(10)=待秒商品总数,decreaseAndGet()&gt;＝0的继续做后续处理, &lt;0的直接返回秒杀结束页面.<code>这样经过第一步的处理只剩下100台*10个=1000个请求</code>.</p></li><li><p>第二步, memcached 里以商品id作为key的value放个10, 每个web服务器在接到每个请求的同时, 向memcached服务器发起请求, 利用memcached的decr(key,1)操作返回值&gt;=0的继续处理, 其余的返回秒杀失败页面.<code>这样经过第二步的处理只剩下100台中最快速到达的10个请求</code>.</p></li><li><p>第三步, 向App服务器发起下单操作事务.</p></li><li><p>第四步, App服务器向商品所在的数据库请求减库存操作,</p></li></ol><p>(操作数据库时可以 <code>update table set count=count-1 where id=商品id and count&gt;0;</code> update 成功记录数为1, 再向订单数据库添加订单记录, 都成功后提交整个事务, 否则的话提示秒杀失败. 用户进入支付流程.</p><h2 id="在看看淘宝的秒杀："><a href="#在看看淘宝的秒杀：" class="headerlink" title="在看看淘宝的秒杀："></a>在看看淘宝的秒杀：</h2><h3 id="1、前端"><a href="#1、前端" class="headerlink" title="1、前端"></a>1、前端</h3><p>面对高并发的抢购活动，前端常用的三板斧是【扩容】【静态化】【限流】</p><ul><li><strong>扩容</strong></li></ul><p>加机器，这是最简单的方法，通过增加前端池的整体承载量来抗峰值。</p><ul><li><strong>静态化</strong></li></ul><p>将活动页面上的所有可以静态的元素全部静态化，并尽量减少动态元素。通过CDN来抗峰值。</p><ul><li><strong>限流</strong></li></ul><p>一般都会采用IP级别的限流，即针对某一个IP，限制单位时间内发起请求数量。</p><p>或者活动入口的时候增加游戏或者问题环节进行消峰操作。</p><ul><li><strong>有损服务</strong></li></ul><p>最后一招，在接近前端池承载能力的水位上限的时候，随机拒绝部分请求来保护活动整体的可用性。</p><h3 id="2、后端"><a href="#2、后端" class="headerlink" title="2、后端"></a>2、后端</h3><p>那么后端的数据库在高并发和超卖下会遇到什么问题呢</p><ul><li><p>首先MySQL自身对于高并发的处理性能就会出现问题，一般来说，MySQL的处理性能会随着并发thread上升而上升，但是到了一定的并发度之后会出现明显的拐点，之后一路下降，最终甚至会比单thread的性能还要差。</p></li><li><p>其次，超卖的根结在于减库存操作是一个事务操作，需要先select，然后insert，最后update -1。最后这个-1操作是不能出现负数的，但是当多用户在有库存的情况下并发操作，出现负数这是无法避免的。</p></li><li><p>最后，当减库存和高并发碰到一起的时候，由于操作的库存数目在同一行，就会出现争抢InnoDB行锁的问题，导致出现互相等待甚至死锁，从而大大降低MySQL的处理性能，最终导致前端页面出现超时异常。</p></li></ul><h2 id="针对上述问题，如何解决呢？淘宝的高大上解决方案："><a href="#针对上述问题，如何解决呢？淘宝的高大上解决方案：" class="headerlink" title="针对上述问题，如何解决呢？淘宝的高大上解决方案："></a>针对上述问题，如何解决呢？淘宝的高大上解决方案：</h2><ul><li><p>关闭死锁检测，提高并发处理性能。</p></li><li><p>修改源代码，将排队提到进入引擎层前，降低引擎层面的并发度。</p></li><li><p>组提交，降低server和引擎的交互次数，降低IO消耗。</p></li></ul><h3 id="解决方案1："><a href="#解决方案1：" class="headerlink" title="解决方案1："></a>解决方案1：</h3><p>将存库从MySQL前移到Redis中，所有的写操作放到内存中，由于Redis中不存在锁故不会出现互相等待，并且由于Redis的写性能和读性能都远高于MySQL，这就解决了高并发下的性能问题。然后通过队列等异步手段，将变化的数据异步写入到DB中。</p><p><strong>优点：</strong>解决性能问题</p><p><strong>缺点：</strong>没有解决超卖问题，同时由于异步写入DB，存在某一时刻DB和Redis中数据不一致的风险。</p><h3 id="解决方案2："><a href="#解决方案2：" class="headerlink" title="解决方案2："></a>解决方案2：</h3><p>引入队列，然后将所有写DB操作在单队列中排队，完全串行处理。当达到库存阀值的时候就不在消费队列，并关闭购买功能。这就解决了超卖问题。</p><p><strong>优点：</strong>解决超卖问题，略微提升性能。</p><p><strong>缺点：</strong>性能受限于队列处理机处理性能和DB的写入性能中最短的那个，另外多商品同时抢购的时候需要准备多条队列。</p><h3 id="解决方案3："><a href="#解决方案3：" class="headerlink" title="解决方案3："></a>解决方案3：</h3><p>将写操作前移到MC中，同时利用MC的轻量级的锁机制CAS来实现减库存操作。</p><p><strong>优点：</strong>读写在内存中，操作性能快，引入轻量级锁之后可以保证同一时刻只有一个写入成功，解决减库存问题。</p><p><strong>缺点：</strong>没有实测，基于CAS的特性不知道高并发下是否会出现大量更新失败？不过加锁之后肯定对并发性能会有影响。</p><h3 id="解决方案4："><a href="#解决方案4：" class="headerlink" title="解决方案4："></a>解决方案4：</h3><p>将提交操作变成两段式，先申请后确认。然后利用Redis的原子自增操作，同时利用Redis的事务特性来发号，保证拿到小于等于库存阀值的号的人都可以成功提交订单。然后数据异步更新到DB中。</p><p><strong>优点：</strong>解决超卖问题，库存读写都在内存中，故同时解决性能问题。</p><p><strong>缺点：</strong>由于异步写入DB，可能存在数据不一致。另可能存在少买，也就是如果拿到号的人不真正下订单，可能库存减为0，但是订单数并没有达到库存阀值。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>1、前端三板斧【扩容】【限流】【静态化】</p><p>2、后端两条路【内存】+【排队】</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;作者：cfyme&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tuicool.com/articles/JzQvUb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.tuicool.com/art
      
    
    </summary>
    
    
    
      <category term="架构" scheme="https://kanchai.club/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="系统设计" scheme="https://kanchai.club/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>大白话带你梳理一下Dubbo的那些事儿</title>
    <link href="https://kanchai.club/2020/04/26/%E5%A4%A7%E7%99%BD%E8%AF%9D%E5%B8%A6%E4%BD%A0%E6%A2%B3%E7%90%86%E4%B8%80%E4%B8%8BDubbo%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    <id>https://kanchai.club/2020/04/26/%E5%A4%A7%E7%99%BD%E8%AF%9D%E5%B8%A6%E4%BD%A0%E6%A2%B3%E7%90%86%E4%B8%80%E4%B8%8BDubbo%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</id>
    <published>2020-04-26T02:39:56.223Z</published>
    <updated>2020-04-26T02:20:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>首先声明，本文并不是什么代码实战类型的文章，适合于想对dubbo有更加全面认识的读者阅读，文章不会过于深奥，只是将一系列的知识点串通起来，帮助读者温故而知新。</em></p><h2 id="RPC服务的介绍"><a href="#RPC服务的介绍" class="headerlink" title="RPC服务的介绍"></a>RPC服务的介绍</h2><p>相信有过一些分布式开发经历的读者都有用过一些RPC框架，通过框架包装好之后提供的API接口调用远程服务，体验感觉起来就和调用本地服务一样轻松。<strong>这么方便好用的技术框架，在实际的开发过程中是如何包装的呢?</strong></p><p>很早的时候，国外的工程师设计了一种能够通过A计算机调用B计算机上边应用程序的技术，这种技术不需要开发人员对于网络通讯了解过多，并且调用其他机器上边程序的时候和调用本地的程序一样方便好用。</p><p>A机器发起请求去调用B机器程序的时候会被挂起，B机器接收到A机器发起的请求参数之后会做一定的参数转换，最后将对应的程序结果返回给A，这就是最原始的RPC服务调用了。</p><h2 id="RPC调用的优势"><a href="#RPC调用的优势" class="headerlink" title="RPC调用的优势"></a>RPC调用的优势</h2><h3 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h3><p><strong>不需要开发者对于网络通信做过多的设置</strong>，例如我们在使用http协议进行远程接口调用的时候，总是会需要编写较多的http协议参数（header，context，Accept-Language,Accept-Encode等等），这些处理对于开发人员来说，实际上都并不是特别友好。但是RPC服务调用框架通常都将这类解析进行了对应的封装，大大降低了开发人员的使用难度。</p><h3 id="高效"><a href="#高效" class="headerlink" title="高效"></a>高效</h3><p>在网络传输方面，RPC更多是处于应用层和传输层之间。这里我们需要先理清楚一个问题，网络分层。RPC是处于会话层的部分，相比处于应用层的HTTP而言，<strong>RPC要比Rest服务调用更加轻便。</strong></p><h2 id="常见的远程调用技术"><a href="#常见的远程调用技术" class="headerlink" title="常见的远程调用技术"></a>常见的远程调用技术</h2><h3 id="rmi"><a href="#rmi" class="headerlink" title="rmi"></a>rmi</h3><p>利用java.rmi包实现，<strong>基于Java远程方法协议(Java Remote Method Protocol) 和java的原生序列化</strong>。</p><h3 id="Hessian"><a href="#Hessian" class="headerlink" title="Hessian"></a>Hessian</h3><p><strong>是一个轻量级的remoting onhttp工具</strong>，使用简单的方法提供了RMI的功能。基于HTTP协议，采用二进制编解码。</p><h3 id="protobuf-rpc-pro"><a href="#protobuf-rpc-pro" class="headerlink" title="protobuf-rpc-pro"></a>protobuf-rpc-pro</h3><p><strong>是一个Java类库</strong>，提供了基于 Google 的 Protocol Buffers 协议的远程方法调用的框架。基于 Netty 底层的 NIO 技术。支持 TCP 重用/ keep-alive、SSL加密、RPC 调用取消操作、嵌入式日志等功能。</p><h3 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h3><p><strong>是一种可伸缩的跨语言服务的软件框架</strong>。它拥有功能强大的代码生成引擎，无缝地支持C + +，C#，Java，Python和PHP和Ruby。thrift允许你定义一个描述文件，描述数据类型和服务接口。依据该文件，编译器方便地生成RPC客户端和服务器通信代码。</p><p>最初由facebook开发用做系统内部语言之间的RPC通信，2007年由facebook贡献到apache基金 ，现在是apache下的opensource之一 。支持多种语言之间的RPC方式的通信：php语言client可以构造一个对象，调用相应的服务方法来调用java语言的服务，跨越语言的C/S RPC调用。底层通讯基于SOCKET。</p><h3 id="Avro"><a href="#Avro" class="headerlink" title="Avro"></a>Avro</h3><p><strong>出自Hadoop之父Doug Cutting</strong>, 在Thrift已经相当流行的情况下推出Avro的目标不仅是提供一套类似Thrift的通讯中间件,更是要建立一个新的，标准性的云计算的数据交换和存储的Protocol。支持HTTP，TCP两种协议。</p><h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><p><strong>Dubbo是 阿里巴巴公司开源的一个高性能优秀的服务框架**</strong>，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。**</p><p>上边我们说到了RPC的远程调用发展历史，那么下边我们一起来深入探讨一下RPC的服务。</p><p>首先我们来看看OSI的网络协议内容。</p><h2 id="OSI的七层网络模型"><a href="#OSI的七层网络模型" class="headerlink" title="OSI的七层网络模型"></a>OSI的七层网络模型</h2><p>对于OSI的七层网络模型我绘制了下边的这么一张图：  </p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/01/java1-1578536515.png" alt="大白话带你梳理一下Dubbo的那些事儿" title="大白话带你梳理一下Dubbo的那些事儿">  </p><p><strong>下边是我个人对于这七层协议的理解：</strong></p><ul><li><p><strong>应用层</strong> 主要是对于服务接口的格式多定义，例如提供一定的终端接口暴露给外部应用调用。</p></li><li><p><strong>表示层</strong> 处理一些数据传输的格式转换，例如说编码的统一，加密和解密处理。</p></li><li><p><strong>会话层</strong> 管理用户的会话和对话，建立不同机器之间的会话连接。</p></li><li><p><strong>传输层</strong> 向网络层提供可靠有序的数据包信息。</p></li><li><p><strong>网络层</strong> 真正发送数据包信息的层面，提供流和拥塞控制，从而降低网络的资源损耗。</p></li><li><p><strong>数据链路层</strong> 封装对应的数据包，检测和纠正数据包传输信息。</p></li><li><p><strong>物理层</strong> 通过网络通讯设备发送数据</p></li></ul><h2 id="HTTP-amp-RPC"><a href="#HTTP-amp-RPC" class="headerlink" title="HTTP &amp; RPC"></a>HTTP &amp; RPC</h2><p>HTTP主要是位于TCP/IP协议栈的应用层部分，首先需要构建三次握手的链接，接着才能进行数据信息的请求发送，最后进行四次挥手断开链接。</p><p>RPC在请求的过程中跨越了传输层和应用层，这是因为它本身是依赖于Socket的原因。（再深入的原因我也不知道）。减少了上边几层的封装，RPC的请求效率自然是要比HTTP高效很多。</p><p><strong>那么一个完整的RPC调用应该包含哪些部分呢？</strong></p><p>通常我们将一个完整的RPC架构分为了以下几个核心组件：</p><ul><li><p>Server</p></li><li><p>Client</p></li><li><p>Server Stub</p></li><li><p>Client Stub</p></li></ul><p>这四个模块中我稍微说下stub吧。这个单词翻译过来称之为存根。</p><p>*<em>Client Stub *</em>就是将客户端请求的参数，服务名称，服务地址进行打包，统一发送给server方。</p><p>*<em>Server Stub *</em>我用通俗易懂的语言来解释就是服务端接收到Client发送的数据之后进行消息解包，调用本地方法。（看过netty拆包机制应该会对这块比较了解）。</p><h2 id="Dubbo的核心属性"><a href="#Dubbo的核心属性" class="headerlink" title="Dubbo的核心属性"></a>Dubbo的核心属性</h2><p>其实Dubbo配置里面的核心内容就是 _<strong>服务暴露，服务发现，服务治理</strong>_。</p><h3 id="什么是服务暴露，服务发现，服务治理？"><a href="#什么是服务暴露，服务发现，服务治理？" class="headerlink" title="什么是服务暴露，服务发现，服务治理？"></a>什么是服务暴露，服务发现，服务治理？</h3><p>下边我们用一段xml的配置来进行讲解：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"dubbo-invoker-provider"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"qos.port"</span> <span class="attr">value</span>=<span class="string">"22222"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dubbo:application</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.sise.user.service.UserServiceImpl"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.sise.user.service.UserService"</span> <span class="attr">ref</span>=<span class="string">"userService"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在dubbo的配置文件里面，通常我们所说的<strong>dubbo:service</strong> 可以理解为服务暴露，<strong>dubbo:refernce</strong> 为服务发现，<strong>mock</strong>是服务治理，<strong>timeout</strong>属于服务治理的一种（性能调优）.</p><p>假设dubbo里面希望将一些公共的配置抽取出来，我们可以通过properties文件进行配置，dubbo在加载配置文件的优先顺序如下：</p><ol><li><p>优先会读取JVM -D启动参数后边的内容</p></li><li><p>读取xml配置文件</p></li><li><p>读取properties配置文件内容</p></li></ol><p>dubbo默认会读取dubbo.properties配置文件的信息，例如下边这种配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dubbo.application.name&#x3D;dubbo-user-service</span><br><span class="line">dubbo.registry.address&#x3D;zookeeper:&#x2F;&#x2F;127.0.0.1:2181</span><br></pre></td></tr></table></figure><p>假设我们的dubbo配置文件不命名为dubbo.properties（假设命名为了my-dubbo.properties）的时候，可以在启动参数的后边加上这么一段指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Ddubbo.properties.file&#x3D;my-dubbo.properties</span><br></pre></td></tr></table></figure><p>那么在应用程序启动之后，对应的工程就会读取指定的配置文件，这样就可以将一些共用的dubbo配置给抽取了出来。</p><h2 id="XML和配置类的映射"><a href="#XML和配置类的映射" class="headerlink" title="XML和配置类的映射"></a>XML和配置类的映射</h2><p>在工作中，我们通常都会通过配置xml的方式来设定一个服务端暴露的服务接口和消费端需要调用的服务信息，这些配置的xml实际上在dubbo的源码中都会被解析为对应的实体类对象。</p><p>例如说我们常用到的reference配置类，下边我贴出一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sise.user.config;</span><br><span class="line"><span class="keyword">import</span> com.sise.user.service.UserService;</span><br><span class="line"><span class="keyword">import</span> com.sise.user.service.UserServiceImpl;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.config.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dubbo里面的自定义配置类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> idea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2019/12/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboSelfDefConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * dubbo的服务暴露</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationConfig applicationConfig = <span class="keyword">new</span> ApplicationConfig();</span><br><span class="line">        applicationConfig.setName(<span class="string">"dubbo-server-config"</span>);</span><br><span class="line">        RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</span><br><span class="line">        registryConfig.setAddress(<span class="string">"zookeeper://127.0.0.1:2181"</span>);</span><br><span class="line">        ProtocolConfig protocolConfig = <span class="keyword">new</span> ProtocolConfig();</span><br><span class="line">        protocolConfig.setName(<span class="string">"dubbo"</span>);</span><br><span class="line">        protocolConfig.setPort(<span class="number">20880</span>);</span><br><span class="line">        protocolConfig.setThreads(<span class="number">200</span>);</span><br><span class="line">        UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        ServiceConfig&lt;UserService&gt; serviceConfig = <span class="keyword">new</span> ServiceConfig&lt;&gt;();</span><br><span class="line">        serviceConfig.setApplication(applicationConfig);</span><br><span class="line">        serviceConfig.setRegistry(registryConfig);</span><br><span class="line">        serviceConfig.setProtocol(protocolConfig);</span><br><span class="line">        serviceConfig.setInterface(UserService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        serviceConfig.setRef(userService);</span><br><span class="line">        serviceConfig.export();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationConfig applicationConfig = <span class="keyword">new</span> ApplicationConfig();</span><br><span class="line">        applicationConfig.setName(<span class="string">"dubbo-client-config"</span>);</span><br><span class="line">        RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</span><br><span class="line">        registryConfig.setAddress(<span class="string">"zookeeper://127.0.0.1:2181"</span>);</span><br><span class="line">        ReferenceConfig&lt;UserService&gt; referenceConfig = <span class="keyword">new</span> ReferenceConfig&lt;&gt;();</span><br><span class="line">        referenceConfig.setApplication(applicationConfig);</span><br><span class="line">        referenceConfig.setRegistry(registryConfig);</span><br><span class="line">        referenceConfig.setInterface(UserService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        UserService localRef = referenceConfig.get();</span><br><span class="line">        localRef.echo(<span class="string">"idea"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException </span>&#123;</span><br><span class="line">        DubboSelfDefConfig d = <span class="keyword">new</span> DubboSelfDefConfig();</span><br><span class="line">        d.consumer();</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码里面，通过案例可以发现有这些信息内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UserService localRef = referenceConfig.get();</span><br><span class="line">localRef.echo(<span class="string">"idea"</span>);</span><br></pre></td></tr></table></figure><p>这两行语句是获取具体服务的核心之处，由于我在别处定义了一个叫做UserService 的公共服务接口，因此在服务引用的过程中可以进行转换。</p><h2 id="Dubbo2-7的三大新特新"><a href="#Dubbo2-7的三大新特新" class="headerlink" title="Dubbo2.7的三大新特新"></a>Dubbo2.7的三大新特新</h2><p>Dubbo的github官方地址为 <a href="https://github.com/apache/dubbo" target="_blank" rel="noopener">https://github.com/apache/dubbo</a>  </p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/01/java9-1578536515.png" alt="大白话带你梳理一下Dubbo的那些事儿" title="大白话带你梳理一下Dubbo的那些事儿">在这里插入图片描述</p><p>Dubbo 目前有如图所示的 5 个分支，其中 2.7.1-release 只是一个临时分支，忽略不计，对其他 4 个分支而言，我归纳了一下，分别有如下信息：</p><ul><li><p>2.5.x 近期已经通过投票，Dubbo 社区即将停止对其的维护。</p></li><li><p>2.6.x 为长期支持的版本，也是 Dubbo 贡献给 Apache 之前的版本，其包名前缀为：com.alibaba，JDK 版本对应 1.6。</p></li><li><p>3.x-dev 是前瞻性的版本，对 Dubbo 进行一些高级特性的补充，如支持 rx 特性。</p></li><li><p>master 为长期支持的版本，版本号为 2.7.x，也是 Dubbo 贡献给 Apache 的开发版本，其包名前缀为：org.apache，JDK 版本对应 1.8。</p></li></ul><h2 id="Dubbo-2-7-新特性"><a href="#Dubbo-2-7-新特性" class="headerlink" title="Dubbo 2.7 新特性"></a>Dubbo 2.7 新特性</h2><p>Dubbo 2.7.x 作为 Apache 的孵化版本，除了代码优化之外，还新增了许多重磅的新特性，本文将会介绍其中最典型的2个新特性：</p><ul><li><p><strong>异步化改造</strong></p></li><li><p><strong>三大中心改造</strong></p></li></ul><h3 id="异步化改造"><a href="#异步化改造" class="headerlink" title="异步化改造"></a>异步化改造</h3><p>1.异步化调用的方式，在Dubbo2.7版本里面提供了异步化调用的功能，相关案例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Reference</span>(async = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/testStr"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testStr</span><span class="params">(String param)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.testEcho(param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是通过这种异步发送的方式我们通常都是获取不到响应值的，所以这里的return为null。</p><p>如果在低于2.7版本的dubbo框架中希望获取到异步返回的响应值还是需要通过RPC上下文来提取信息。</p><p>代码案例如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/futureGet"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">futureGet</span><span class="params">(String param)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">       userService.testEcho(param);</span><br><span class="line">       Future&lt;String&gt; future= RpcContext.getContext().getFuture();</span><br><span class="line">       String result = future.get();</span><br><span class="line">       System.out.println(<span class="string">"this is :"</span>+result);</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过RPC上下文的方式可以取到对应的响应值,但是这种方式需要有所等待，因此此时的效率会有所降低。假设我们将dubbo的版本提升到了2.7.1之后，通过使用CompletableFuture来进行接口优化的话，这部分的代码实现就会有所变化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> idea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/12/31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> V1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">      <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span> </span>;</span><br><span class="line">      <span class="function"><span class="keyword">default</span> CompletableFuture&lt;String&gt; <span class="title">sayAsyncHello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> CompletableFuture.completedFuture(sayHello(name));</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sise.consumer.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sise.dubbo.service.DemoService;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.config.annotation.Reference;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> idea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/12/31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> V1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/demo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/testDemo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testDemo</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"【testDemo】 this is :"</span>+name);</span><br><span class="line">        <span class="keyword">return</span> demoService.sayHello(name);</span><br><span class="line">    &#125;.</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/testAsyncDemo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testAsyncDemo</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"【testAsyncDemo】 this is :"</span>+name);</span><br><span class="line">        CompletableFuture&lt;String&gt; future = demoService.sayAsyncHello(name);</span><br><span class="line">        AtomicReference&lt;String&gt; result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//通过一条callback线程来处理响应的数据信息</span></span><br><span class="line">        future.whenComplete((retValue,exception)-&gt;&#123;</span><br><span class="line">           <span class="keyword">if</span>(exception==<span class="keyword">null</span>)&#123;</span><br><span class="line">               System.out.println(retValue);</span><br><span class="line">               result.set(retValue);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               exception.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"通过一条callback线程来处理响应的数据信息,所以这个时候获取不到信息响应"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的调用是借助了callback线程来帮我们处理原先的数据内容，关于dubbo里面的异步化调用，我借用了官方的一张图来进行展示：  </p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/01/java7-1578536515.png" alt="大白话带你梳理一下Dubbo的那些事儿" title="大白话带你梳理一下Dubbo的那些事儿">  </p><p>我们上边讲解的众多方法都只是针对于dubbo的客户端异步化，并没有讲解关于服务端的异步化处理，这是因为结合dubbo的业务线程池模型来思考，服务端的异步化处理比较鸡肋（因为dubbo内部服务端的线程池本身就是异步化调用的了）。</p><p>当然dubbo 2.6 里面对于接口异步化调用的配置到了2.7版本依旧有效。</p><h3 id="三大中心的改造"><a href="#三大中心的改造" class="headerlink" title="三大中心的改造"></a>三大中心的改造</h3><p><strong>注册中心</strong></p><p>在dubbo2.7之前，dubbo主要还是由consumer，provider ，register组成，然而在2.7版本之后，dubbo的注册中心被拆解为了三个中心，分别是原先的<strong>注册中心</strong>和<strong>元数据中心</strong>以及<strong>配置中心</strong>。</p><p><strong>元数据配置</strong></p><p>在dubbo2.7版本中，将原先注册在zk上边的过多数据进行了注册拆分，这样能够保证减少对于zk端的压力。具体配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">“zookeeper://127.0.0.1:2181”</span> <span class="attr">simplified</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>简化了相应配置之后，dubbo也只会上传一些必要的服务治理数据了，简化版本的服务数据只剩下下边这些信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dubbo://30.5.120.185:20880/com.sise.TestService?</span><br><span class="line">application=test-provider&amp;</span><br><span class="line">dubbo=2.0.2&amp;</span><br><span class="line">release=2.7.0&amp;</span><br><span class="line">timestamp=1554982201973</span><br></pre></td></tr></table></figure><p>对于其他的元数据信息将会被存储到一些元数据中心里面，例如说redis，nacos，zk等</p><p>元数据配置改造主要解决的问题是：推送量大 -&gt; 存储数据量大 -&gt; 网络传输量大 -&gt; 延迟严重</p><h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><p>dubbo2.7开始支持多种分布式配置中心的组件。例如说：zk，Spring Cloud Config, Apollo, Nacos，关于这部分的配置网上的资料也比较多，我就不在这里细说了。</p><p><strong>END</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;首先声明，本文并不是什么代码实战类型的文章，适合于想对dubbo有更加全面认识的读者阅读，文章不会过于深奥，只是将一系列的知识点串通起来，帮助读者温故而知新。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;RPC服务的介绍&quot;&gt;&lt;a href=&quot;#RPC服务的介绍&quot; class=
      
    
    </summary>
    
    
    
      <category term="Dubbo" scheme="https://kanchai.club/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo 面试18问</title>
    <link href="https://kanchai.club/2020/04/26/Dubbo_%E9%9D%A2%E8%AF%9518%E9%97%AE/"/>
    <id>https://kanchai.club/2020/04/26/Dubbo_%E9%9D%A2%E8%AF%9518%E9%97%AE/</id>
    <published>2020-04-26T02:39:56.093Z</published>
    <updated>2020-04-26T02:38:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="dubbo是什么"><a href="#dubbo是什么" class="headerlink" title="dubbo是什么"></a>dubbo是什么</h2><p>dubbo是一个分布式框架，远程服务调用的分布式框架，其核心部分包含：</p><ul><li><p><strong>集群容错</strong>：提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</p></li><li><p><strong>远程通讯</strong>：提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。</p></li><li><p><strong>自动发现</strong>：基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</p></li></ul><h2 id="dubbo能做什么"><a href="#dubbo能做什么" class="headerlink" title="dubbo能做什么"></a>dubbo能做什么</h2><p>透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。</p><p>服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</p><h3 id="1、默认使用的是什么通信框架，还有别的选择吗"><a href="#1、默认使用的是什么通信框架，还有别的选择吗" class="headerlink" title="1、默认使用的是什么通信框架，还有别的选择吗?"></a>1、默认使用的是什么通信框架，还有别的选择吗?</h3><p>答：默认也推荐使用 netty 框架，还有 mina。</p><h3 id="2、服务调用是阻塞的吗？"><a href="#2、服务调用是阻塞的吗？" class="headerlink" title="2、服务调用是阻塞的吗？"></a>2、服务调用是阻塞的吗？</h3><p>答：默认是阻塞的，可以异步调用，没有返回值的可以这么做。</p><h3 id="3、一般使用什么注册中心？还有别的选择吗？"><a href="#3、一般使用什么注册中心？还有别的选择吗？" class="headerlink" title="3、一般使用什么注册中心？还有别的选择吗？"></a>3、一般使用什么注册中心？还有别的选择吗？</h3><p>答：推荐使用 zookeeper 注册中心，还有 Multicast注册中心, Redis注册中心, Simple注册中心.</p><p>ZooKeeper的节点是通过像树一样的结构来进行维护的，并且每一个节点通过路径来标示以及访问。除此之外，每一个节点还拥有自身的一些信息，包括：数据、数据长度、创建时间、修改时间等等。</p><h3 id="4、默认使用什么序列化框架，你知道的还有哪些？"><a href="#4、默认使用什么序列化框架，你知道的还有哪些？" class="headerlink" title="4、默认使用什么序列化框架，你知道的还有哪些？"></a>4、默认使用什么序列化框架，你知道的还有哪些？</h3><p>答：默认使用 Hessian 序列化，还有 Duddo、FastJson、Java 自带序列化。hessian是一个采用二进制格式传输的服务框架，相对传统soap web service，更轻量，更快速。</p><p><strong>Hessian原理与协议简析：</strong></p><p>http的协议约定了数据传输的方式，hessian也无法改变太多：</p><ul><li><p>hessian中client与server的交互，基于http-post方式。</p></li><li><p>hessian将辅助信息，封装在http header中，比如“授权token”等，我们可以基于http-header来封装关于“安全校验”“meta数据”等。hessian提供了简单的”校验”机制。</p></li><li><p>对于hessian的交互核心数据，比如“调用的方法”和参数列表信息，将通过post请求的body体直接发送，格式为字节流。</p></li><li><p>对于hessian的server端响应数据，将在response中通过字节流的方式直接输出。</p></li></ul><p>hessian的协议本身并不复杂，在此不再赘言；所谓协议(protocol)就是约束数据的格式，client按照协议将请求信息序列化成字节序列发送给server端，server端根据协议，将数据反序列化成“对象”，然后执行指定的方法，并将方法的返回值再次按照协议序列化成字节流，响应给client，client按照协议将字节流反序列化成”对象”。</p><h3 id="5、服务提供者能实现失效踢出是什么原理？"><a href="#5、服务提供者能实现失效踢出是什么原理？" class="headerlink" title="5、服务提供者能实现失效踢出是什么原理？"></a>5、服务提供者能实现失效踢出是什么原理？</h3><p>答：服务失效踢出基于 zookeeper 的临时节点原理。</p><h3 id="6、服务上线怎么不影响旧版本？"><a href="#6、服务上线怎么不影响旧版本？" class="headerlink" title="6、服务上线怎么不影响旧版本？"></a>6、服务上线怎么不影响旧版本？</h3><p>答：采用多版本开发，不影响旧版本。在配置中添加version来作为版本区分</p><h3 id="7、如何解决服务调用链过长的问题？"><a href="#7、如何解决服务调用链过长的问题？" class="headerlink" title="7、如何解决服务调用链过长的问题？"></a>7、如何解决服务调用链过长的问题？</h3><p>答：可以结合 zipkin 实现分布式服务追踪。</p><h3 id="8、说说核心的配置有哪些？"><a href="#8、说说核心的配置有哪些？" class="headerlink" title="8、说说核心的配置有哪些？"></a>8、说说核心的配置有哪些？</h3><p>核心配置有</p><ul><li><p>dubbo:service/</p></li><li><p>dubbo:reference/</p></li><li><p>dubbo:protocol/</p></li><li><p>dubbo:registry/</p></li><li><p>dubbo:application/</p></li><li><p>dubbo:provider/</p></li><li><p>dubbo:consumer/</p></li><li><p>dubbo:method/</p></li></ul><h3 id="9、dubbo-推荐用什么协议？"><a href="#9、dubbo-推荐用什么协议？" class="headerlink" title="9、dubbo 推荐用什么协议？"></a>9、dubbo 推荐用什么协议？</h3><p>答：默认使用 dubbo 协议。</p><h3 id="10、同一个服务多个注册的情况下可以直连某一个服务吗？"><a href="#10、同一个服务多个注册的情况下可以直连某一个服务吗？" class="headerlink" title="10、同一个服务多个注册的情况下可以直连某一个服务吗？"></a>10、同一个服务多个注册的情况下可以直连某一个服务吗？</h3><p>答：可以直连，修改配置即可，也可以通过 telnet 直接某个服务。</p><h3 id="11、dubbo-在安全机制方面如何解决的？"><a href="#11、dubbo-在安全机制方面如何解决的？" class="headerlink" title="11、dubbo 在安全机制方面如何解决的？"></a>11、dubbo 在安全机制方面如何解决的？</h3><p>dubbo 通过 token 令牌防止用户绕过注册中心直连，然后在注册中心管理授权，dubbo 提供了黑白名单，控制服务所允许的调用方。</p><h3 id="12、集群容错怎么做？"><a href="#12、集群容错怎么做？" class="headerlink" title="12、集群容错怎么做？"></a>12、集群容错怎么做？</h3><p>答：读操作建议使用 Failover 失败自动切换，默认重试两次其他服务器。写操作建议使用 Failfast 快速失败，发一次调用失败就立即报错。</p><h3 id="13、在使用过程中都遇到了些什么问题？如何解决的？"><a href="#13、在使用过程中都遇到了些什么问题？如何解决的？" class="headerlink" title="13、在使用过程中都遇到了些什么问题？如何解决的？"></a>13、在使用过程中都遇到了些什么问题？如何解决的？</h3><p><strong>1.同时配置了 XML 和 properties 文件，则 properties 中的配置无效</strong></p><p>只有 XML 没有配置时，properties 才生效。</p><p><strong>2.dubbo 缺省会在启动时检查依赖是否可用，不可用就抛出异常，阻止 spring 初始化完成，check 属性默认为 true。</strong></p><p>测试时有些服务不关心或者出现了循环依赖，将 check 设置为 false</p><p><strong>3.为了方便开发测试，线下有一个所有服务可用的注册中心，这时，如果有一个正在开发中的服务提供者注册，可能会影响消费者不能正常运行。</strong></p><p>解决：让服务提供者开发方，只订阅服务，而不注册正在开发的服务，通过直连测试正在开发的服务。设置 dubbo:registry 标签的 register 属性为 false。</p><p><strong>4.spring 2.x 初始化死锁问题。</strong></p><p>在 spring 解析到 dubbo:service 时，就已经向外暴露了服务，而 spring 还在接着初始化其他 bean，如果这时有请求进来，并且服务的实现类里有调用applicationContext.getBean() 的用法。getBean 线程和 spring 初始化线程的锁的顺序不一样，导致了线程死锁，不能提供服务，启动不了。</p><p>解决：不要在服务的实现类中使用 applicationContext.getBean(); 如果不想依赖配置顺序，可以将 dubbo:provider 的 deplay 属性设置为 - 1，使 dubbo 在容器初始化完成后再暴露服务。</p><p><strong>5.服务注册不上</strong></p><p>检查 dubbo 的 jar 包有没有在 classpath 中，以及有没有重复的 jar 包</p><p>检查暴露服务的 spring 配置有没有加载</p><p>在服务提供者机器上测试与注册中心的网络是否通</p><p><strong>6.出现 RpcException: No provider available for remote service 异常，表示没有可用的服务提供者，</strong></p><ul><li><p>检查连接的注册中心是否正确</p></li><li><p>到注册中心查看相应的服务提供者是否存在</p></li><li><p>检查服务提供者是否正常运行</p></li></ul><p><strong>7.出现” 消息发送失败” 异常</strong></p><p>通常是接口方法的传入传出参数未实现 Serializable 接口。</p><h3 id="14、dubbo-和-dubbox-之间的区别？"><a href="#14、dubbo-和-dubbox-之间的区别？" class="headerlink" title="14、dubbo 和 dubbox 之间的区别？"></a>14、dubbo 和 dubbox 之间的区别？</h3><p>答：dubbox 是当当网基于 dubbo 上做了一些扩展，如加了服务可 restful 调用，更新了开源组件等。</p><h3 id="15、你还了解别的分布式框架吗？"><a href="#15、你还了解别的分布式框架吗？" class="headerlink" title="15、你还了解别的分布式框架吗？"></a>15、你还了解别的分布式框架吗？</h3><p>答：别的还有 spring 的 spring cloud，facebook 的 thrift，twitter 的 finagle 等。</p><h3 id="16、Dubbo-支持哪些协议，每种协议的应用场景，优缺点？"><a href="#16、Dubbo-支持哪些协议，每种协议的应用场景，优缺点？" class="headerlink" title="16、Dubbo 支持哪些协议，每种协议的应用场景，优缺点？"></a>16、Dubbo 支持哪些协议，每种协议的应用场景，优缺点？</h3><p><strong>dubbo</strong>：单一长连接和 NIO 异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议 TCP，异步，Hessian 序列化；</p><p><strong>rmi</strong>：采用 JDK 标准的 rmi 协议实现，传输参数和返回参数对象需要实现 Serializable 接口，使用 java 标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议 TCP。多个短连接，TCP 协议传输，同步传输，适用常规的远程服务调用和 rmi 互操作。在依赖低版本的 Common-Collections 包，java 序列化存在安全漏洞；</p><p><strong>webservice</strong>：基于 WebService 的远程调用协议，集成 CXF 实现，提供和原生 WebService 的互操作。多个短连接，基于 HTTP 传输，同步传输，适用系统集成和跨语言调用；</p><p><strong>http</strong>：基于 Http 表单提交的远程调用协议，使用 Spring 的 HttpInvoke 实现。多个短连接，传输协议 HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器 JS 调用；</p><p><strong>hessian</strong>：集成 Hessian 服务，基于 HTTP 通讯，采用 Servlet 暴露服务，Dubbo 内嵌 Jetty 作为服务器时默认实现，提供与 Hession 服务互操作。多个短连接，同步 HTTP 传输，Hessian 序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件；</p><p><strong>memcache</strong>：基于 memcached 实现的 RPC 协议 redis：基于 redis 实现的 RPC 协议</p><h3 id="17、Dubbo-集群的负载均衡有哪些策略"><a href="#17、Dubbo-集群的负载均衡有哪些策略" class="headerlink" title="17、Dubbo 集群的负载均衡有哪些策略　　"></a>17、Dubbo 集群的负载均衡有哪些策略　　</h3><p>Dubbo 提供了常见的集群策略实现，并预扩展点予以自行实现。</p><p><strong>Random LoadBalance</strong>：随机选取提供者策略，有利于动态调整提供者权重。截面碰撞率高，调用次数越多，分布越均匀；</p><p><strong>RoundRobin LoadBalance</strong>：轮循选取提供者策略，平均分布，但是存在请求累积的问题；</p><p><strong>LeastActive LoadBalance:</strong>：最少活跃调用策略，解决慢提供者接收更少的请求；</p><p><strong>ConstantHash LoadBalance:</strong>：一致性 Hash 策略，使相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避免引起提供者的剧烈变动；</p><h3 id="18-服务调用超时问题怎么解决"><a href="#18-服务调用超时问题怎么解决" class="headerlink" title="18. 服务调用超时问题怎么解决"></a>18. 服务调用超时问题怎么解决</h3><p>dubbo在调用服务不成功时，默认是会重试两次的。这样在服务端的处理时间超过了设定的超时时间时，就会有重复请求，比如在发邮件时，可能就会发出多份重复邮件，执行注册请求时，就会插入多条重复的注册数据，那么怎么解决超时问题呢？如下</p><p>对于核心的服务中心，去除dubbo超时重试机制，并重新评估设置超时时间。业务处理代码必须放在服务端，客户端只做参数验证和服务调用，不涉及业务流程处理 全局配置实例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">delay</span>=<span class="string">"-1"</span> <span class="attr">timeout</span>=<span class="string">"6000"</span> <span class="attr">retries</span>=<span class="string">"0"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>当然Dubbo的重试机制其实是非常好的QOS保证，它的路由机制，是会帮你把超时的请求路由到其他机器上，而不是本机尝试，所以 dubbo的重试机器也能一定程度的保证服务的质量。但是请一定要综合线上的访问情况，给出综合的评估。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;dubbo是什么&quot;&gt;&lt;a href=&quot;#dubbo是什么&quot; class=&quot;headerlink&quot; title=&quot;dubbo是什么&quot;&gt;&lt;/a&gt;dubbo是什么&lt;/h2&gt;&lt;p&gt;dubbo是一个分布式框架，远程服务调用的分布式框架，其核心部分包含：&lt;/p&gt;
&lt;ul&gt;
&lt;
      
    
    </summary>
    
    
    
      <category term="Dubbo" scheme="https://kanchai.club/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Mysql去重sql</title>
    <link href="https://kanchai.club/2020/04/21/Mysql%E5%8E%BB%E9%87%8Dsql/"/>
    <id>https://kanchai.club/2020/04/21/Mysql%E5%8E%BB%E9%87%8Dsql/</id>
    <published>2020-04-21T05:37:24.474Z</published>
    <updated>2020-04-21T02:18:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>替换变量table_name 和 group_by</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DELETE</span><br><span class="line">FROM</span><br><span class="line">$&#123;table_name&#125;</span><br><span class="line">WHERE ID NOT IN (</span><br><span class="line">SELECT</span><br><span class="line">*</span><br><span class="line">FROM</span><br><span class="line">(</span><br><span class="line">SELECT</span><br><span class="line">Max(ID)</span><br><span class="line">FROM</span><br><span class="line">    $&#123;table_name&#125;</span><br><span class="line">GROUP BY</span><br><span class="line">$&#123;group_by&#125;</span><br><span class="line">bb</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;替换变量table_name 和 group_by&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cla
      
    
    </summary>
    
    
    
      <category term="mysql" scheme="https://kanchai.club/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>OpenResty下载与安装(Linux&amp;Windos)</title>
    <link href="https://kanchai.club/2020/04/21/OpenResty%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85(Linux&amp;Windos)/"/>
    <id>https://kanchai.club/2020/04/21/OpenResty%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85(Linux&amp;Windos)/</id>
    <published>2020-04-21T01:13:42.651Z</published>
    <updated>2020-04-21T01:13:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OpenResty下载与安装"><a href="#OpenResty下载与安装" class="headerlink" title="OpenResty下载与安装"></a>OpenResty下载与安装</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h5 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OpenResty&#x3D;1.15.8.2 </span><br><span class="line">linux.centos&#x3D;7</span><br><span class="line">windows&#x3D;10</span><br></pre></td></tr></table></figure><h5 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h5><ul><li>OpenResty 官网:<a href="http://openresty.org/cn/" target="_blank" rel="noopener">http://openresty.org/cn/</a></li><li>OpenResty 下载及安装说明地址：<a href="http://openresty.org/cn/download.html" target="_blank" rel="noopener">http://openresty.org/cn/download.html</a></li></ul><h2 id="Win-10-安装"><a href="#Win-10-安装" class="headerlink" title="Win 10 安装"></a>Win 10 安装</h2><p>解压即安装，双击 nginx.exe 即运行；</p><p>或者进入安装目录，执行 start nginx.exe 即运行；</p><h2 id="Linux-Tar-安装"><a href="#Linux-Tar-安装" class="headerlink" title="Linux Tar 安装"></a>Linux Tar 安装</h2><p>官方源码安装指南：<a href="http://openresty.org/cn/installation.html" target="_blank" rel="noopener">http://openresty.org/cn/installation.html</a></p><h5 id="安装依赖环境"><a href="#安装依赖环境" class="headerlink" title="安装依赖环境"></a>安装依赖环境</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install pcre-devel openssl-devel gcc curl</span><br></pre></td></tr></table></figure><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># .&#x2F;configure 默认 --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;openresty</span><br><span class="line"># .&#x2F;configure --help 查看更多的选项。</span><br><span class="line">.&#x2F;configure</span><br></pre></td></tr></table></figure><h5 id="编译与安装"><a href="#编译与安装" class="headerlink" title="编译与安装"></a>编译与安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 编译</span><br><span class="line">make </span><br><span class="line"># 安装</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h5 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 方式一：进入 openresty安装目录&#x2F;bin 目录，执行</span><br><span class="line">.&#x2F;openresty</span><br><span class="line"># 方式二：进入 openresty安装目录&#x2F;nginx&#x2F;sbin 目录，执行</span><br><span class="line">.&#x2F;nginx</span><br></pre></td></tr></table></figure><h2 id="Linux-Yum-安装"><a href="#Linux-Yum-安装" class="headerlink" title="Linux Yum 安装"></a>Linux Yum 安装</h2><h5 id="添加-OpenResty-仓库"><a href="#添加-OpenResty-仓库" class="headerlink" title="添加 OpenResty 仓库"></a>添加 OpenResty 仓库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line">sudo yum-config-manager --add-repo https:&#x2F;&#x2F;openresty.org&#x2F;package&#x2F;centos&#x2F;openresty.repo</span><br></pre></td></tr></table></figure><h5 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 下载与安装</span><br><span class="line">sudo yum install -y openresty</span><br><span class="line"># 更新</span><br><span class="line">sudo yum check-update</span><br></pre></td></tr></table></figure><p>注：默认安装目录：/usr/local/openresty</p><h5 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 方式一：进入 openresty安装目录&#x2F;bin 目录，执行</span><br><span class="line">.&#x2F;openresty</span><br><span class="line"># 方式二：进入 openresty安装目录&#x2F;&#x2F;nginx&#x2F;sbin 目录，执行</span><br><span class="line">.&#x2F;nginx</span><br></pre></td></tr></table></figure><h5 id="安装-OpenResty-命令工具"><a href="#安装-OpenResty-命令工具" class="headerlink" title="安装 OpenResty 命令工具"></a>安装 OpenResty 命令工具</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y openresty-resty</span><br></pre></td></tr></table></figure><p>命令行工具 opm 在 openresty-opm 包里，而 restydoc 工具在 openresty-doc 包里头</p><h5 id="附录-configure-选项"><a href="#附录-configure-选项" class="headerlink" title="附录-configure 选项"></a>附录-configure 选项</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></td><td class="code"><pre><span class="line">root@localhost openresty-1.15.8.2]# .&#x2F;configure --help</span><br><span class="line">  --help                             this message</span><br><span class="line"></span><br><span class="line">  --prefix&#x3D;PATH                      set the installation prefix (default to &#x2F;usr&#x2F;local&#x2F;openresty)</span><br><span class="line"></span><br><span class="line">  --with-debug                       enable debug logging</span><br><span class="line">  --with-dtrace-probes               enable dtrace USDT probes</span><br><span class="line">  --with-dtrace&#x3D;PATH                 set dtrace utility pathname</span><br><span class="line"></span><br><span class="line">  --with-no-pool-patch               enable the no-pool patch for debugging memory issues</span><br><span class="line"></span><br><span class="line">  -jN                                pass -jN option to make while building the bundled</span><br><span class="line">                                     Lua 5.1 interpreter or LuaJIT 2.1</span><br><span class="line"></span><br><span class="line">  --without-http_echo_module         disable ngx_http_echo_module</span><br><span class="line">  --without-http_xss_module          disable ngx_http_xss_module</span><br><span class="line">  --without-http_coolkit_module      disable ngx_http_coolkit_module</span><br><span class="line">  --without-http_set_misc_module     disable ngx_http_set_misc_module</span><br><span class="line">  --without-http_form_input_module   disable ngx_http_form_input_module</span><br><span class="line">  --without-http_encrypted_session_module</span><br><span class="line">                                     disable ngx_http_encrypted_session_module</span><br><span class="line">  --without-http_srcache_module      disable ngx_http_srcache_module</span><br><span class="line">  --without-http_lua_module          disable ngx_http_lua_module</span><br><span class="line">  --without-http_lua_upstream_module disable ngx_http_lua_upstream_module</span><br><span class="line">  --without-http_headers_more_module disable ngx_http_headers_more_module</span><br><span class="line">  --without-http_array_var_module    disable ngx_http_array_var_module</span><br><span class="line">  --without-http_memc_module         disable ngx_http_memc_module</span><br><span class="line">  --without-http_redis2_module       disable ngx_http_redis2_module</span><br><span class="line">  --without-http_redis_module        disable ngx_http_redis_module</span><br><span class="line">  --without-http_rds_json_module     disable ngx_http_rds_json_module</span><br><span class="line">  --without-http_rds_csv_module      disable ngx_http_rds_csv_module</span><br><span class="line">  --without-stream_lua_module        disable ngx_stream_lua_module</span><br><span class="line">  --without-ngx_devel_kit_module     disable ngx_devel_kit_module</span><br><span class="line">  --without-http_ssl_module          disable ngx_http_ssl_module</span><br><span class="line">  --without-stream_ssl_module        disable ngx_stream_ssl_module</span><br><span class="line"></span><br><span class="line">  --with-http_iconv_module           enable ngx_http_iconv_module</span><br><span class="line">  --with-http_drizzle_module         enable ngx_http_drizzle_module</span><br><span class="line">  --with-http_postgres_module        enable ngx_http_postgres_module</span><br><span class="line"></span><br><span class="line">  --without-lua_cjson                disable the lua-cjson library</span><br><span class="line">  --without-lua_tablepool            disable the lua-tablepool library (and by consequence, the</span><br><span class="line">                                     lua-resty-shell library)</span><br><span class="line">  --without-lua_redis_parser         disable the lua-redis-parser library</span><br><span class="line">  --without-lua_rds_parser           disable the lua-rds-parser library</span><br><span class="line">  --without-lua_resty_dns            disable the lua-resty-dns library</span><br><span class="line">  --without-lua_resty_memcached      disable the lua-resty-memcached library</span><br><span class="line">  --without-lua_resty_redis          disable the lua-resty-redis library</span><br><span class="line">  --without-lua_resty_mysql          disable the lua-resty-mysql library</span><br><span class="line">  --without-lua_resty_upload         disable the lua-resty-upload library</span><br><span class="line">  --without-lua_resty_upstream_healthcheck</span><br><span class="line">                                     disable the lua-resty-upstream-healthcheck library</span><br><span class="line">  --without-lua_resty_string         disable the lua-resty-string library</span><br><span class="line">  --without-lua_resty_websocket      disable the lua-resty-websocket library</span><br><span class="line">  --without-lua_resty_limit_traffic  disable the lua-resty-limit-traffic library</span><br><span class="line">  --without-lua_resty_lock           disable the lua-resty-lock library</span><br><span class="line">  --without-lua_resty_lrucache       disable the lua-resty-lrucache library</span><br><span class="line">  --without-lua_resty_signal         disable the lua-resty-signal library (and by consequence,</span><br><span class="line">                                     the lua-resty-shell library)</span><br><span class="line">  --without-lua_resty_shell          disable the lua-resty-shell library</span><br><span class="line">  --without-lua_resty_core           disable the lua-resty-core library</span><br><span class="line"></span><br><span class="line">  --with-luajit                      enable and build the bundled LuaJIT 2.1 (the default)</span><br><span class="line">  --with-luajit&#x3D;DIR                  use the external LuaJIT 2.1 installation specified by DIR</span><br><span class="line">  --with-luajit-xcflags&#x3D;FLAGS        Specify extra C compiler flags for LuaJIT 2.1</span><br><span class="line">  --without-luajit-lua52             Turns off the LuaJIT extensions from Lua 5.2 that may break</span><br><span class="line">                                     backward compatibility.</span><br><span class="line">  --without-luajit-gc64              Turns off the LuaJIT GC64 mode (which is enabled by default</span><br><span class="line">                                     on x86_64)</span><br><span class="line"></span><br><span class="line">  --with-libdrizzle&#x3D;DIR              specify the libdrizzle 1.0 (or drizzle) installation prefix</span><br><span class="line">  --with-libpq&#x3D;DIR                   specify the libpq (or postgresql) installation prefix</span><br><span class="line">  --with-pg_config&#x3D;PATH              specify the path of the pg_config utility</span><br><span class="line"></span><br><span class="line">Options directly inherited from nginx</span><br><span class="line"></span><br><span class="line">  --sbin-path&#x3D;PATH                   set nginx binary pathname</span><br><span class="line">  --modules-path&#x3D;PATH                set modules path</span><br><span class="line">  --conf-path&#x3D;PATH                   set nginx.conf pathname</span><br><span class="line">  --error-log-path&#x3D;PATH              set error log pathname</span><br><span class="line">  --pid-path&#x3D;PATH                    set nginx.pid pathname</span><br><span class="line">  --lock-path&#x3D;PATH                   set nginx.lock pathname</span><br><span class="line">  --tapset-prefix&#x3D;PATH               set systemtap tapset directory prefix</span><br><span class="line">  --stap-nginx-path&#x3D;PATH             set stap-nginx pathname</span><br><span class="line"></span><br><span class="line">  --user&#x3D;USER                        set non-privileged user for</span><br><span class="line">                                     worker processes</span><br><span class="line">  --group&#x3D;GROUP                      set non-privileged group for</span><br><span class="line">                                     worker processes</span><br><span class="line"></span><br><span class="line">  --build&#x3D;NAME                       set build name</span><br><span class="line">  --builddir&#x3D;DIR                     set the build directory</span><br><span class="line"></span><br><span class="line">  --with-select_module               enable select module</span><br><span class="line">  --without-select_module            disable select module</span><br><span class="line">  --with-poll_module                 enable poll module</span><br><span class="line">  --without-poll_module              disable poll module</span><br><span class="line"></span><br><span class="line">  --with-threads                     enable thread pool support</span><br><span class="line"></span><br><span class="line">  --with-file-aio                    enable file AIO support</span><br><span class="line">  --with-ipv6                        enable IPv6 support</span><br><span class="line"></span><br><span class="line">  --with-http_v2_module              enable ngx_http_v2_module</span><br><span class="line">  --with-http_realip_module          enable ngx_http_realip_module</span><br><span class="line">  --with-http_addition_module        enable ngx_http_addition_module</span><br><span class="line">  --with-http_xslt_module            enable ngx_http_xslt_module</span><br><span class="line">  --with-http_xslt_module&#x3D;dynamic    enable dynamic ngx_http_xslt_module</span><br><span class="line">  --with-http_image_filter_module    enable ngx_http_image_filter_module</span><br><span class="line">  --with-http_image_filter_module&#x3D;dynamic</span><br><span class="line">                                     enable dynamic ngx_http_image_filter_module</span><br><span class="line">  --with-http_geoip_module           enable ngx_http_geoip_module</span><br><span class="line">  --with-http_geoip_module&#x3D;dynamic   enable dynamic ngx_http_geoip_module</span><br><span class="line">  --with-http_sub_module             enable ngx_http_sub_module</span><br><span class="line">  --with-http_dav_module             enable ngx_http_dav_module</span><br><span class="line">  --with-http_flv_module             enable ngx_http_flv_module</span><br><span class="line">  --with-http_mp4_module             enable ngx_http_mp4_module</span><br><span class="line">  --with-http_gunzip_module          enable ngx_http_gunzip_module</span><br><span class="line">  --with-http_gzip_static_module     enable ngx_http_gzip_static_module</span><br><span class="line">  --with-http_auth_request_module    enable ngx_http_auth_request_module</span><br><span class="line">  --with-http_random_index_module    enable ngx_http_random_index_module</span><br><span class="line">  --with-http_secure_link_module     enable ngx_http_secure_link_module</span><br><span class="line">  --with-http_degradation_module     enable ngx_http_degradation_module</span><br><span class="line">  --with-http_slice_module           enable ngx_http_slice_module</span><br><span class="line">  --with-http_stub_status_module     enable ngx_http_stub_status_module</span><br><span class="line"></span><br><span class="line">  --without-http_charset_module      disable ngx_http_charset_module</span><br><span class="line">  --without-http_gzip_module         disable ngx_http_gzip_module</span><br><span class="line">  --without-http_ssi_module          disable ngx_http_ssi_module</span><br><span class="line">  --without-http_userid_module       disable ngx_http_userid_module</span><br><span class="line">  --without-http_access_module       disable ngx_http_access_module</span><br><span class="line">  --without-http_auth_basic_module   disable ngx_http_auth_basic_module</span><br><span class="line">  --without-http_autoindex_module    disable ngx_http_autoindex_module</span><br><span class="line">  --without-http_geo_module          disable ngx_http_geo_module</span><br><span class="line">  --without-http_map_module          disable ngx_http_map_module</span><br><span class="line">  --without-http_split_clients_module disable ngx_http_split_clients_module</span><br><span class="line">  --without-http_referer_module      disable ngx_http_referer_module</span><br><span class="line">  --without-http_rewrite_module      disable ngx_http_rewrite_module</span><br><span class="line">  --without-http_proxy_module        disable ngx_http_proxy_module</span><br><span class="line">  --without-http_fastcgi_module      disable ngx_http_fastcgi_module</span><br><span class="line">  --without-http_uwsgi_module        disable ngx_http_uwsgi_module</span><br><span class="line">  --without-http_scgi_module         disable ngx_http_scgi_module</span><br><span class="line">  --without-http_memcached_module    disable ngx_http_memcached_module</span><br><span class="line">  --without-http_limit_conn_module   disable ngx_http_limit_conn_module</span><br><span class="line">  --without-http_limit_req_module    disable ngx_http_limit_req_module</span><br><span class="line">  --without-http_empty_gif_module    disable ngx_http_empty_gif_module</span><br><span class="line">  --without-http_browser_module      disable ngx_http_browser_module</span><br><span class="line">  --without-http_upstream_hash_module</span><br><span class="line">                                     disable ngx_http_upstream_hash_module</span><br><span class="line">  --without-http_upstream_ip_hash_module</span><br><span class="line">                                     disable ngx_http_upstream_ip_hash_module</span><br><span class="line">  --without-http_upstream_least_conn_module</span><br><span class="line">                                     disable ngx_http_upstream_least_conn_module</span><br><span class="line">  --without-http_upstream_keepalive_module</span><br><span class="line">                                     disable ngx_http_upstream_keepalive_module</span><br><span class="line"></span><br><span class="line">  --without-http_upstream_zone_module</span><br><span class="line">                                     disable ngx_http_upstream_zone_module</span><br><span class="line">  --with-http_perl_module            enable ngx_http_perl_module</span><br><span class="line">  --with-http_perl_module&#x3D;dynamic    enable dynamic ngx_http_perl_module</span><br><span class="line">  --with-perl_modules_path&#x3D;PATH      set Perl modules path</span><br><span class="line">  --with-perl&#x3D;PATH                   set perl binary pathname</span><br><span class="line"></span><br><span class="line">  --http-log-path&#x3D;PATH               set http access log pathname</span><br><span class="line">  --http-client-body-temp-path&#x3D;PATH  set path to store</span><br><span class="line">                                     http client request body temporary files</span><br><span class="line">  --http-proxy-temp-path&#x3D;PATH        set path to store</span><br><span class="line">                                     http proxy temporary files</span><br><span class="line">  --http-fastcgi-temp-path&#x3D;PATH      set path to store</span><br><span class="line">                                     http fastcgi temporary files</span><br><span class="line">  --http-uwsgi-temp-path&#x3D;PATH        set path to store</span><br><span class="line">                                     http uwsgi temporary files</span><br><span class="line">  --http-scgi-temp-path&#x3D;PATH         set path to store</span><br><span class="line">                                     http scgi temporary files</span><br><span class="line"></span><br><span class="line">  --without-http                     disable HTTP server</span><br><span class="line">  --without-http-cache               disable HTTP cache</span><br><span class="line"></span><br><span class="line">  --with-mail                        enable POP3&#x2F;IMAP4&#x2F;SMTP proxy module</span><br><span class="line">  --with-mail&#x3D;dynamic                enable dynamic POP3&#x2F;IMAP4&#x2F;SMTP proxy module</span><br><span class="line">  --with-mail_ssl_module             enable ngx_mail_ssl_module</span><br><span class="line">  --without-mail_pop3_module         disable ngx_mail_pop3_module</span><br><span class="line">  --without-mail_imap_module         disable ngx_mail_imap_module</span><br><span class="line">  --without-mail_smtp_module         disable ngx_mail_smtp_module</span><br><span class="line"></span><br><span class="line">  --without-stream                   disable TCP&#x2F;UDP proxy module</span><br><span class="line">  --without-stream_ssl_module        disable ngx_stream_ssl_module</span><br><span class="line"></span><br><span class="line">  --with-stream                      enable TCP&#x2F;UDP proxy module (default on)</span><br><span class="line">  --with-stream&#x3D;dynamic              enable dynamic TCP&#x2F;UDP proxy module</span><br><span class="line">  --with-stream_ssl_module           enable ngx_stream_ssl_module (default on)</span><br><span class="line">  --with-stream_realip_module        enable ngx_stream_realip_module</span><br><span class="line">  --with-stream_geoip_module         enable ngx_stream_geoip_module</span><br><span class="line">  --with-stream_geoip_module&#x3D;dynamic enable dynamic ngx_stream_geoip_module</span><br><span class="line">  --with-stream_ssl_preread_module   enable ngx_stream_ssl_preread_module</span><br><span class="line">  --without-stream_limit_conn_module disable ngx_stream_limit_conn_module</span><br><span class="line">  --without-stream_access_module     disable ngx_stream_access_module</span><br><span class="line">  --without-stream_geo_module        disable ngx_stream_geo_module</span><br><span class="line">  --without-stream_map_module        disable ngx_stream_map_module</span><br><span class="line">  --without-stream_split_clients_module</span><br><span class="line">                                     disable ngx_stream_split_clients_module</span><br><span class="line">  --without-stream_return_module     disable ngx_stream_return_module</span><br><span class="line">  --without-stream_upstream_hash_module</span><br><span class="line">                                     disable ngx_stream_upstream_hash_module</span><br><span class="line">  --without-stream_upstream_least_conn_module</span><br><span class="line">                                     disable ngx_stream_upstream_least_conn_module</span><br><span class="line">  --without-stream_upstream_zone_module</span><br><span class="line">                                     disable ngx_stream_upstream_zone_module</span><br><span class="line"></span><br><span class="line">  --with-google_perftools_module     enable ngx_google_perftools_module</span><br><span class="line">  --with-cpp_test_module             enable ngx_cpp_test_module</span><br><span class="line"></span><br><span class="line">  --add-module&#x3D;PATH                  enable external module</span><br><span class="line">  --add-dynamic-module&#x3D;PATH          enable dynamic external module</span><br><span class="line"></span><br><span class="line">  --with-cc&#x3D;PATH                     set C compiler pathname</span><br><span class="line">  --with-cpp&#x3D;PATH                    set C preprocessor pathname</span><br><span class="line">  --with-cc-opt&#x3D;OPTIONS              set additional C compiler options</span><br><span class="line">  --with-ld-opt&#x3D;OPTIONS              set additional linker options</span><br><span class="line">  --with-cpu-opt&#x3D;CPU                 build for the specified CPU, valid values:</span><br><span class="line">                                     pentium, pentiumpro, pentium3, pentium4,</span><br><span class="line">                                     athlon, opteron, sparc32, sparc64, ppc64</span><br><span class="line"></span><br><span class="line">  --without-pcre                     disable PCRE library usage</span><br><span class="line">  --with-pcre                        force PCRE library usage</span><br><span class="line">  --with-pcre&#x3D;DIR                    set path to PCRE library sources</span><br><span class="line">  --with-pcre-opt&#x3D;OPTIONS            set additional make options for PCRE</span><br><span class="line">  --with-pcre-conf-opt&#x3D;OPTIONS       set additional configure options for PCRE</span><br><span class="line">  --with-pcre-jit                    build PCRE with JIT compilation support</span><br><span class="line"></span><br><span class="line">  --with-zlib&#x3D;DIR                    set path to zlib library sources</span><br><span class="line">  --with-zlib-opt&#x3D;OPTIONS            set additional build options for zlib</span><br><span class="line">  --with-zlib-asm&#x3D;CPU                use zlib assembler sources optimized</span><br><span class="line">                                     for the specified CPU, valid values:</span><br><span class="line">                                     pentium, pentiumpro</span><br><span class="line"></span><br><span class="line">  --with-libatomic                   force libatomic_ops library usage</span><br><span class="line">  --with-libatomic&#x3D;DIR               set path to libatomic_ops library sources</span><br><span class="line"></span><br><span class="line">  --with-openssl&#x3D;DIR                 set path to OpenSSL library sources</span><br><span class="line">  --with-openssl-opt&#x3D;OPTIONS         set additional build options for OpenSSL</span><br><span class="line"></span><br><span class="line">  --dry-run                          dry running the configure, for testing only</span><br><span class="line">  --platform&#x3D;PLATFORM                forcibly specify a platform name, for testing only</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「SIMBA1949」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;simba1949&#x2F;java&#x2F;article&#x2F;details&#x2F;103333599</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OpenResty下载与安装&quot;&gt;&lt;a href=&quot;#OpenResty下载与安装&quot; class=&quot;headerlink&quot; title=&quot;OpenResty下载与安装&quot;&gt;&lt;/a&gt;OpenResty下载与安装&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot;
      
    
    </summary>
    
    
    
      <category term="nginx" scheme="https://kanchai.club/tags/nginx/"/>
    
      <category term="devops" scheme="https://kanchai.club/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>synchronized与Lock的区别与使用？</title>
    <link href="https://kanchai.club/2020/04/21/synchronized%E4%B8%8ELock%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://kanchai.club/2020/04/21/synchronized%E4%B8%8ELock%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2020-04-21T01:04:22.356Z</published>
    <updated>2020-04-21T01:03:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h2><p>昨天在学习别人分享的面试经验时，看到Lock的使用。想起自己在上次面试也遇到了synchronized与Lock的区别与使用。</p><p>于是，我整理了两者的区别和使用情况，同时，对synchronized的使用过程一些常见问题的总结，最后是参照源码和说明文档，对Lock的使用写了几个简单的Demo。请大家批评指正。</p><h2 id="技术点："><a href="#技术点：" class="headerlink" title="技术点："></a>技术点：</h2><h3 id="1、线程与进程："><a href="#1、线程与进程：" class="headerlink" title="1、线程与进程："></a>1、线程与进程：</h3><p>在开始之前先把进程与线程进行区分一下，一个程序最少需要一个进程，而一个进程最少需要一个线程。关系是线程–&gt;进程–&gt;程序的大致组成结构。所以线程是程序执行流的最小单位，而进程是系统进行资源分配和调度的一个独立单位。以下我们所有讨论的都是建立在线程基础之上。</p><h3 id="2、Thread的几个重要方法："><a href="#2、Thread的几个重要方法：" class="headerlink" title="2、Thread的几个重要方法："></a>2、Thread的几个重要方法：</h3><p>我们先了解一下Thread的几个重要方法。</p><ul><li><p>start()方法，调用该方法开始执行该线程；</p></li><li><p>stop()方法，调用该方法强制结束该线程执行；</p></li><li><p>join方法，调用该方法等待该线程结束。</p></li><li><p>sleep()方法，调用该方法该线程进入等待。</p></li><li><p>run()方法，调用该方法直接执行线程的run()方法，但是线程调用start()方法时也会运行run()方法，区别就是一个是由线程调度运行run()方法，一个是直接调用了线程中的run()方法！！</p></li></ul><p>看到这里，可能有些人就会问啦，那wait()和notify()呢？要注意，其实wait()与notify()方法是Object的方法，不是Thread的方法！！同时，wait()与notify()会配合使用，分别表示线程挂起和线程恢复。</p><p>这里还有一个很常见的问题，顺带提一下：wait()与sleep()的区别，简单来说wait()会释放对象锁而sleep()不会释放对象锁。这些问题有很多的资料，不再赘述。</p><h3 id="3、线程状态："><a href="#3、线程状态：" class="headerlink" title="3、线程状态："></a>3、线程状态：</h3><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/04/java8-1586835150.png" alt="【72期】面试官：对并发熟悉吗？说一下synchronized与Lock的区别与使用" title="【72期】面试官：对并发熟悉吗？说一下synchronized与Lock的区别与使用"></p><p>线程总共有5大状态，通过上面第二个知识点的介绍，理解起来就简单了。  </p><ul><li><p>新建状态：新建线程对象，并没有调用start()方法之前</p></li><li><p>就绪状态：调用start()方法之后线程就进入就绪状态，但是并不是说只要调用start()方法线程就马上变为当前线程，在变为当前线程之前都是为就绪状态。值得一提的是，线程在睡眠和挂起中恢复的时候也会进入就绪状态哦。</p></li><li><p>运行状态：线程被设置为当前线程，开始执行run()方法。就是线程进入运行状态</p></li><li><p>阻塞状态：线程被暂停，比如说调用sleep()方法后线程就进入阻塞状态</p></li><li><p>死亡状态：线程执行结束</p></li></ul><h3 id="4、锁类型"><a href="#4、锁类型" class="headerlink" title="4、锁类型"></a>4、锁类型</h3><ul><li><p>可重入锁：在执行对象中所有同步方法不用再次获得锁</p></li><li><p>可中断锁：在等待获取锁过程中可中断</p></li><li><p>公平锁：按等待获取锁的线程的等待时间进行获取，等待时间长的具有优先获取锁权利</p></li><li><p>读写锁：对资源读取和写入的时候拆分为2部分处理，读的时候可以多线程一起读，写的时候必须同步地写</p></li></ul><h2 id="synchronized与Lock的区别"><a href="#synchronized与Lock的区别" class="headerlink" title="synchronized与Lock的区别"></a>synchronized与Lock的区别</h2><p>1、我把两者的区别分类到了一个表中，方便大家对比：</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/04/java3-1586835150.png" alt="【72期】面试官：对并发熟悉吗？说一下synchronized与Lock的区别与使用" title="【72期】面试官：对并发熟悉吗？说一下synchronized与Lock的区别与使用"></p><p>或许，看到这里还对LOCK所知甚少，那么接下来，我们进入LOCK的深入学习。</p><h2 id="Lock详细介绍与Demo"><a href="#Lock详细介绍与Demo" class="headerlink" title="Lock详细介绍与Demo"></a>Lock详细介绍与Demo</h2><p>以下是Lock接口的源码，笔者修剪之后的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires the lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires the lock unless the current thread is</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires the lock only if it is free at the time of invocation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires the lock if it is free within the given waiting time and the</span></span><br><span class="line"><span class="comment">     * current thread has not been &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Releases the lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从Lock接口中我们可以看到主要有个方法，这些方法的功能从注释中可以看出：</p><ul><li><p>lock()：获取锁，如果锁被暂用则一直等待</p></li><li><p>unlock()：释放锁</p></li><li><p>tryLock(): 注意返回类型是boolean，如果获取锁的时候锁被占用就返回false，否则返回true</p></li><li><p>tryLock(long time, TimeUnit unit)：比起tryLock()就是给了一个时间期限，保证等待参数时间</p></li><li><p>lockInterruptibly()：用该锁的获得方式，如果线程在获取锁的阶段进入了等待，那么可以中断此线程，先去做别的事</p></li></ul><p>通过 以上的解释，大致可以解释在上个部分中“锁类型(lockInterruptibly())”，“锁状态(tryLock())”等问题，还有就是前面子所获取的过程我所写的“大致就是可以尝试获得锁，线程可以不会一直等待”用了“可以”的原因。</p><p>下面是Lock一般使用的例子，注意ReentrantLock是Lock接口的实现。</p><h4 id="lock-："><a href="#lock-：" class="headerlink" title="lock()："></a>lock()：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.brickworkers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要参与同步的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Thread thread)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程名"</span>+thread.getName() + <span class="string">"获得了锁"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程名"</span>+thread.getName() + <span class="string">"释放了锁"</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LockTest lockTest = <span class="keyword">new</span> LockTest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程1</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                lockTest.method(Thread.currentThread());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                lockTest.method(Thread.currentThread());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行情况：线程名t1获得了锁</span></span><br><span class="line"><span class="comment">//         线程名t1释放了锁</span></span><br><span class="line"><span class="comment">//         线程名t2获得了锁</span></span><br><span class="line"><span class="comment">//         线程名t2释放了锁</span></span><br></pre></td></tr></table></figure><h4 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock():"></a>tryLock():</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.brickworkers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要参与同步的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Thread thread)</span></span>&#123;</span><br><span class="line"><span class="comment">/*        lock.lock();</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            System.out.println("线程名"+thread.getName() + "获得了锁");</span></span><br><span class="line"><span class="comment">        &#125;catch(Exception e)&#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125; finally &#123;</span></span><br><span class="line"><span class="comment">            System.out.println("线程名"+thread.getName() + "释放了锁");</span></span><br><span class="line"><span class="comment">            lock.unlock();</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(lock.tryLock())&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程名"</span>+thread.getName() + <span class="string">"获得了锁"</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程名"</span>+thread.getName() + <span class="string">"释放了锁"</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是"</span>+Thread.currentThread().getName()+<span class="string">"有人占着锁，我就不要啦"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LockTest lockTest = <span class="keyword">new</span> LockTest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程1</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                lockTest.method(Thread.currentThread());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                lockTest.method(Thread.currentThread());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果： 线程名t2获得了锁</span></span><br><span class="line"><span class="comment">//         我是t1有人占着锁，我就不要啦</span></span><br><span class="line"><span class="comment">//         线程名t2释放了锁</span></span><br></pre></td></tr></table></figure><p>看到这里相信大家也都会使用如何使用Lock了吧，关于tryLock(long time, TimeUnit unit)和lockInterruptibly()不再赘述。前者主要存在一个等待时间，在测试代码中写入一个等待时间，后者主要是等待中断，会抛出一个中断异常，常用度不高，喜欢探究可以自己深入研究。</p><p>前面比较重提到“公平锁”，在这里可以提一下ReentrantLock对于平衡锁的定义，在源码中有这么两段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Sync object for non-fair locks</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">        * acquire on failure.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">               setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               acquire(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Sync object for fair locks</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           acquire(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment">        * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">           <span class="keyword">int</span> c = getState();</span><br><span class="line">           <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                   compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                   setExclusiveOwnerThread(current);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">               <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">               <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">               setState(nextc);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>从以上源码可以看出在Lock中可以自己控制锁是否公平，而且，默认的是非公平锁，以下是ReentrantLock的构造函数：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     sync = <span class="keyword">new</span> NonfairSync();<span class="comment">//默认非公平锁</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="尾记录："><a href="#尾记录：" class="headerlink" title="尾记录："></a>尾记录：</h2><p>笔者水平一般，不过此博客在引言中的目的已全部达到。这只是笔者在学习过程中的总结与概括，如存在不正确的，欢迎大家批评指出。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="1、两种锁的底层实现方式："><a href="#1、两种锁的底层实现方式：" class="headerlink" title="1、两种锁的底层实现方式："></a>1、两种锁的底层实现方式：</h3><p>synchronized：我们知道java是用字节码指令来控制程序（这里不包括热点代码编译成机器码）。在字节指令中，存在有synchronized所包含的代码块，那么会形成2段流程的执行。</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/04/java6-1586835150.png" alt="【72期】面试官：对并发熟悉吗？说一下synchronized与Lock的区别与使用" title="【72期】面试官：对并发熟悉吗？说一下synchronized与Lock的区别与使用"></p><p>我们点击查看SyncDemo.java的源码SyncDemo.class，可以看到如下：</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/04/java5-1586835150.png" alt="【72期】面试官：对并发熟悉吗？说一下synchronized与Lock的区别与使用" title="【72期】面试官：对并发熟悉吗？说一下synchronized与Lock的区别与使用"></p><p>如上就是这段代码段字节码指令，没你想的那么难吧。言归正传，我们可以清晰段看到，其实synchronized映射成字节码指令就是增加来两个指令：monitorenter和monitorexit。当一条线程进行执行的遇到monitorenter指令的时候，它会去尝试获得锁，如果获得锁那么锁计数+1（为什么会加一呢，因为它是一个可重入锁，所以需要用这个锁计数判断锁的情况），如果没有获得锁，那么阻塞。当它遇到monitorexit的时候，锁计数器-1，当计数器为0，那么就释放锁。</p><p>那么有的朋友看到这里就疑惑了，那图上有2个monitorexit呀？马上回答这个问题：上面我以前写的文章也有表述过，synchronized锁释放有两种机制，一种就是执行完释放；另外一种就是发送异常，虚拟机释放。图中第二个monitorexit就是发生异常时执行的流程，这就是我开头说的“会有2个流程存在“。而且，从图中我们也可以看到在第13行，有一个goto指令，也就是说如果正常运行结束会跳转到19行执行。</p><p>这下，你对synchronized是不是了解的很清晰了呢。接下来我们再聊一聊Lock。</p><p>Lock：Lock实现和synchronized不一样，后者是一种悲观锁，它胆子很小，它很怕有人和它抢吃的，所以它每次吃东西前都把自己关起来。而Lock呢底层其实是CAS乐观锁的体现，它无所谓，别人抢了它吃的，它重新去拿吃的就好啦，所以它很乐观。具体底层怎么实现，博主不在细述，有机会的话，我会对concurrent包下面的机制好好和大家说说，如果面试问起，你就说底层主要靠volatile和CAS操作实现的。</p><p>现在，才是我真正想在这篇博文后面加的，我要说的是：尽可能去使用synchronized而不要去使用LOCK</p><p>什么概念呢？我和大家打个比方：你叫jdk，你生了一个孩子叫synchronized，后来呢，你领养了一个孩子叫LOCK。起初，LOCK刚来到新家的时候，它很乖，很懂事，各个方面都表现的比synchronized好。你很开心，但是你内心深处又有一点淡淡的忧伤，你不希望你自己亲生的孩子竟然还不如一个领养的孩子乖巧。这个时候，你对亲生的孩子教育更加深刻了，你想证明，你的亲生孩子synchronized并不会比领养的孩子LOCK差。（博主只是打个比方）</p><h3 id="那如何教育呢？"><a href="#那如何教育呢？" class="headerlink" title="那如何教育呢？"></a>那如何教育呢？</h3><p>在jdk1.6~jdk1.7的时候，也就是synchronized16、7岁的时候，你作为爸爸，你给他优化了，具体优化在哪里呢：</p><h3 id="1、线程自旋和适应性自旋"><a href="#1、线程自旋和适应性自旋" class="headerlink" title="1、线程自旋和适应性自旋"></a>1、线程自旋和适应性自旋</h3><p>我们知道，java’线程其实是映射在内核之上的，线程的挂起和恢复会极大的影响开销。并且jdk官方人员发现，很多线程在等待锁的时候，在很短的一段时间就获得了锁，所以它们在线程等待的时候，并不需要把线程挂起，而是让他无目的的循环，一般设置10次。这样就避免了线程切换的开销，极大的提升了性能。</p><p>而适应性自旋，是赋予了自旋一种学习能力，它并不固定自旋10次一下。他可以根据它前面线程的自旋情况，从而调整它的自旋，甚至是不经过自旋而直接挂起。</p><h3 id="2、锁消除"><a href="#2、锁消除" class="headerlink" title="2、锁消除"></a>2、锁消除</h3><p>什么叫锁消除呢？就是把不必要的同步在编译阶段进行移除。</p><p>那么有的小伙伴又迷糊了，我自己写的代码我会不知道这里要不要加锁？我加了锁就是表示这边会有同步呀？</p><p>并不是这样，这里所说的锁消除并不一定指代是你写的代码的锁消除，我打一个比方：</p><p>在jdk1.5以前，我们的String字符串拼接操作其实底层是StringBuffer来实现的（这个大家可以用我前面介绍的方法，写一个简单的demo，然后查看class文件中的字节码指令就清楚了），而在jdk1.5之后，那么是用StringBuilder来拼接的。我们考虑前面的情况，比如如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1=<span class="string">"qwe"</span>;</span><br><span class="line">String str2=<span class="string">"asd"</span>;</span><br><span class="line">String str3=str1+str2;</span><br></pre></td></tr></table></figure><p>底层实现会变成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">sb.append(<span class="string">"qwe"</span>);</span><br><span class="line">sb.append(<span class="string">"asd"</span>);</span><br></pre></td></tr></table></figure><p>我们知道，StringBuffer是一个线程安全的类，也就是说两个append方法都会同步，通过指针逃逸分析（就是变量不会外泄），我们发现在这段代码并不存在线程安全问题，这个时候就会把这个同步锁消除。</p><h3 id="3、锁粗化"><a href="#3、锁粗化" class="headerlink" title="3、锁粗化"></a>3、锁粗化</h3><p>在用synchronized的时候，我们都讲究为了避免大开销，尽量同步代码块要小。那么为什么还要加粗呢？</p><p>我们继续以上面的字符串拼接为例，我们知道在这一段代码中，每一个append都需要同步一次，那么我可以把锁粗化到第一个append和最后一个append（这里不要去纠结前面的锁消除，我只是打个比方）</p><h3 id="4、轻量级锁"><a href="#4、轻量级锁" class="headerlink" title="4、轻量级锁"></a>4、轻量级锁</h3><h3 id="5、偏向锁"><a href="#5、偏向锁" class="headerlink" title="5、偏向锁"></a>5、偏向锁</h3><p>关于最后这两种，我希望留个有缘的读者自己去查找，我不希望我把一件事情描述的那么详细，自己动手得到才是你自己的，博主可以告诉你的是，最后两种并不难。。加油吧，各位。</p><p><em>来源：<a href="https://blog.csdn.net/u012403290/" target="_blank" rel="noopener">https://blog.csdn.net/u012403290/</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言：&quot;&gt;&lt;a href=&quot;#引言：&quot; class=&quot;headerlink&quot; title=&quot;引言：&quot;&gt;&lt;/a&gt;引言：&lt;/h2&gt;&lt;p&gt;昨天在学习别人分享的面试经验时，看到Lock的使用。想起自己在上次面试也遇到了synchronized与Lock的区别与使用。&lt;/p
      
    
    </summary>
    
    
    
      <category term="JAVA并发" scheme="https://kanchai.club/tags/JAVA%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>API接口设计该如何设计？如何保证安全？</title>
    <link href="https://kanchai.club/2020/04/20/API%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E8%AF%A5%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%89%E5%85%A8%EF%BC%9F/"/>
    <id>https://kanchai.club/2020/04/20/API%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E8%AF%A5%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%89%E5%85%A8%EF%BC%9F/</id>
    <published>2020-04-20T10:01:29.424Z</published>
    <updated>2020-04-20T10:00:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>在实际的业务中，难免会跟第三方系统进行数据的交互与传递，那么如何保证数据在传输过程中的安全呢（防窃取）？除了https的协议之外，能不能加上通用的一套算法以及规范来保证传输的安全性呢？  </p><p>下面我们就来讨论下常用的一些API设计的安全方法，可能不一定是最好的，有更牛逼的实现方式，但是这篇是我自己的经验分享.<br><strong>一、token 简介</strong><br>Token：访问令牌access token, 用于接口中, 用于标识接口调用者的身份、凭证，减少用户名和密码的传输次数。一般情况下客户端(接口调用方)需要先向服务器端申请一个接口调用的账号，服务器会给出一个appId和一个key, key用于参数签名使用，注意key保存到客户端，需要做一些安全处理，防止泄露。<br>Token的值一般是UUID，服务端生成Token后需要将token做为key，将一些和token关联的信息作为value保存到缓存服务器中(redis)，当一个请求过来后，服务器就去缓存服务器中查询这个Token是否存在，存在则调用接口，不存在返回接口错误，一般通过拦截器或者过滤器来实现，Token分为两种：  </p><ul><li><p>API Token(接口令牌): 用于访问不需要用户登录的接口，如登录、注册、一些基本数据的获取等。获取接口令牌需要拿appId、timestamp和sign来换，sign=加密(timestamp+key)</p></li><li><p>USER Token(用户令牌): 用于访问需要用户登录之后的接口，如：获取我的基本信息、保存、修改、删除等操作。获取用户令牌需要拿用户名和密码来换</p></li></ul><p>关于Token的时效性：token可以是一次性的、也可以在一段时间范围内是有效的，具体使用哪种看业务需要。<br>一般情况下接口最好使用https协议，如果使用http协议，Token机制只是一种减少被黑的可能性，其实只能防君子不能防小人。<br>一般token、timestamp和sign 三个参数会在接口中会同时作为参数传递，每个参数都有各自的用途。</p><p><strong>二、timestamp 简介</strong><br>timestamp: 时间戳，是客户端调用接口时对应的当前时间戳，时间戳用于防止DoS攻击。当黑客劫持了请求的url去DoS攻击，每次调用接口时接口都会判断服务器当前系统时间和接口中传的的timestamp的差值，如果这个差值超过某个设置的时间(假如5分钟)，那么这个请求将被拦截掉，如果在设置的超时时间范围内，是不能阻止DoS攻击的。timestamp机制只能减轻DoS攻击的时间，缩短攻击时间。如果黑客修改了时间戳的值可通过sign签名机制来处理。<br>DoS<br>DoS是Denial of Service的简称，即拒绝服务，造成DoS的攻击行为被称为DoS攻击，其目的是使计算机或网络无法提供正常的服务。最常见的DoS攻击有计算机网络带宽攻击和连通性攻击。<br>DoS攻击是指故意的攻击网络协议实现的缺陷或直接通过野蛮手段残忍地耗尽被攻击对象的资源，目的是让目标计算机或网络无法提供正常的服务或资源访问，使目标系统服务系统停止响应甚至崩溃，而在此攻击中并不包括侵入目标服务器或目标网络设备。这些服务资源包括网络带宽，文件系统空间容量，开放的进程或者允许的连接。这种攻击会导致资源的匮乏，无论计算机的处理速度多快、内存容量多大、网络带宽的速度多快都无法避免这种攻击带来的后果。  </p><ul><li><p>Pingflood: 该攻击在短时间内向目的主机发送大量ping包，造成网络堵塞或主机资源耗尽。  </p></li><li><p>Synflood: 该攻击以多个随机的源主机地址向目的主机发送SYN包，而在收到目的主机的SYN ACK后并不回应，这样，目的主机就为这些源主机建立了大量的连接队列，而且由于没有收到ACK一直维护着这些队列，造成了资源的大量消耗而不能向正常请求提供服务。  </p></li><li><p>Smurf：该攻击向一个子网的广播地址发一个带有特定请求（如ICMP回应请求）的包，并且将源地址伪装成想要攻击的主机地址。子网上所有主机都回应广播包请求而向被攻击主机发包，使该主机受到攻击。  </p></li><li><p>Land-based：攻击者将一个包的源地址和目的地址都设置为目标主机的地址，然后将该包通过IP欺骗的方式发送给被攻击主机，这种包可以造成被攻击主机因试图与自己建立连接而陷入死循环，从而很大程度地降低了系统性能。  </p></li><li><p>Ping of Death：根据TCP/IP的规范，一个包的长度最大为65536字节。尽管一个包的长度不能超过65536字节，但是一个包分成的多个片段的叠加却能做到。当一个主机收到了长度大于65536字节的包时，就是受到了Ping of Death攻击，该攻击会造成主机的宕机。  </p></li><li><p>Teardrop：IP数据包在网络传递时，数据包可以分成更小的片段。攻击者可以通过发送两段（或者更多）数据包来实现TearDrop攻击。第一个包的偏移量为0，长度为N，第二个包的偏移量小于N。为了合并这些数据段，TCP/IP堆栈会分配超乎寻常的巨大资源，从而造成系统资源的缺乏甚至机器的重新启动。  </p></li><li><p>PingSweep：使用ICMP Echo轮询多个主机。</p></li></ul><p><strong>三、sign 简介</strong><br>nonce：随机值，是客户端随机生成的值，作为参数传递过来，随机值的目的是增加sign签名的多变性。随机值一般是数字和字母的组合，6位长度，随机值的组成和长度没有固定规则。<br>sign: 一般用于参数签名，防止参数被非法篡改，最常见的是修改金额等重要敏感参数， sign的值一般是将所有非空参数按照升续排序然后+token+key+timestamp+nonce(随机数)拼接在一起，然后使用某种加密算法进行加密，作为接口中的一个参数sign来传递，也可以将sign放到请求头中。接口在网络传输过程中如果被黑客挟持，并修改其中的参数值，然后再继续调用接口，虽然参数的值被修改了，但是因为黑客不知道sign是如何计算出来的，不知道sign都有哪些值构成，不知道以怎样的顺序拼接在一起的，最重要的是不知道签名字符串中的key是什么，所以黑客可以篡改参数的值，但没法修改sign的值，当服务器调用接口前会按照sign的规则重新计算出sign的值然后和接口传递的sign参数的值做比较，如果相等表示参数值没有被篡改，如果不等，表示参数被非法篡改了，就不执行接口了。<br><strong>四、防止重复提交</strong>  </p><p>对于一些重要的操作需要防止客户端重复提交的(如非幂等性重要操作)，具体办法是当请求第一次提交时将sign作为key保存到redis，并设置超时时间，超时时间和Timestamp中设置的差值相同。当同一个请求第二次访问时会先检测redis是否存在该sign，如果存在则证明重复提交了，接口就不再继续调用了。如果sign在缓存服务器中因过期时间到了，而被删除了，此时当这个url再次请求服务器时，因token的过期时间和sign的过期时间一直，sign过期也意味着token过期，那样同样的url再访问服务器会因token错误会被拦截掉，这就是为什么sign和token的过期时间要保持一致的原因。拒绝重复调用机制确保URL被别人截获了也无法使用（如抓取数据）。<br>对于哪些接口需要防止重复提交可以自定义个注解来标记。<br>注意：所有的安全措施都用上的话有时候难免太过复杂，在实际项目中需要根据自身情况作出裁剪，比如可以只使用签名机制就可以保证信息不会被篡改，或者定向提供服务的时候只用Token机制就可以了。如何裁剪，全看项目实际情况和对接口安全性的要求。<br><strong>五、使用流程</strong><br>1.接口调用方(客户端)向接口提供方(服务器)申请接口调用账号，申请成功后，接口提供方会给接口调用方一个appId和一个key参数<br>2.客户端携带参数appId、timestamp、sign去调用服务器端的API token，其中sign=加密(appId + timestamp + key)<br>3.客户端拿着api_token 去访问不需要登录就能访问的接口<br>4.当访问用户需要登录的接口时，客户端跳转到登录页面，通过用户名和密码调用登录接口，登录接口会返回一个usertoken, 客户端拿着usertoken 去访问需要登录才能访问的接口<br>sign的作用是防止参数被篡改，客户端调用服务端时需要传递sign参数，服务器响应客户端时也可以返回一个sign用于客户度校验返回的值是否被非法篡改了。客户端传的sign和服务器端响应的sign算法可能会不同。</p><p><strong>六、示例代码</strong><br>1. dependency  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2. RedisConfiguration  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> RedisConfiguration &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JedisConnectionFactory jedisConnectionFactory()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JedisConnectionFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持存储对象</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; redisTemplate()&#123;</span><br><span class="line">        RedisTemplate&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; redisTemplate = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">        redisTemplate.setConnectionFactory(jedisConnectionFactory());</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(<span class="built_in">Object</span>.class);</span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line">        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3. TokenController  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/api/token"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> TokenController &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * API Token</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param sign</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/api_token"</span>)</span><br><span class="line">    <span class="keyword">public</span> ApiResponse&lt;AccessToken&gt; apiToken(<span class="built_in">String</span> appId, <span class="meta">@RequestHeader</span>(<span class="string">"timestamp"</span>) <span class="built_in">String</span> timestamp, <span class="meta">@RequestHeader</span>(<span class="string">"sign"</span>) <span class="built_in">String</span> sign) &#123;</span><br><span class="line">        Assert.isTrue(!StringUtils.isEmpty(appId) &amp;&amp; !StringUtils.isEmpty(timestamp) &amp;&amp; !StringUtils.isEmpty(sign), <span class="string">"参数错误"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        long reqeustInterval = System.currentTimeMillis() - Long.valueOf(timestamp);</span><br><span class="line">        Assert.isTrue(reqeustInterval &lt; <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000</span>, <span class="string">"请求过期，请重新请求"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 根据appId查询数据库获取appSecret</span></span><br><span class="line">        AppInfo appInfo = <span class="keyword">new</span> AppInfo(<span class="string">"1"</span>, <span class="string">"12345678954556"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 校验签名</span></span><br><span class="line">        <span class="built_in">String</span> signString = timestamp + appId + appInfo.getKey();</span><br><span class="line">        <span class="built_in">String</span> signature = MD5Util.encode(signString);</span><br><span class="line">        log.info(signature);</span><br><span class="line">        Assert.isTrue(signature.equals(sign), <span class="string">"签名错误"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 如果正确生成一个token保存到redis中，如果错误返回错误信息</span></span><br><span class="line">        AccessToken accessToken = <span class="keyword">this</span>.saveToken(<span class="number">0</span>, appInfo, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ApiResponse.success(accessToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotRepeatSubmit</span>(<span class="number">5000</span>)</span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"user_token"</span>)</span><br><span class="line">    <span class="keyword">public</span> ApiResponse&lt;UserInfo&gt; userToken(<span class="built_in">String</span> username, <span class="built_in">String</span> password) &#123;</span><br><span class="line">        <span class="comment">// 根据用户名查询密码, 并比较密码(密码可以RSA加密一下)</span></span><br><span class="line">        UserInfo userInfo = <span class="keyword">new</span> UserInfo(username, <span class="string">"81255cb0dca1a5f304328a70ac85dcbd"</span>, <span class="string">"111111"</span>);</span><br><span class="line">        <span class="built_in">String</span> pwd = password + userInfo.getSalt();</span><br><span class="line">        <span class="built_in">String</span> passwordMD5 = MD5Util.encode(pwd);</span><br><span class="line">        Assert.isTrue(passwordMD5.equals(userInfo.getPassword()), <span class="string">"密码错误"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 保存Token</span></span><br><span class="line">        AppInfo appInfo = <span class="keyword">new</span> AppInfo(<span class="string">"1"</span>, <span class="string">"12345678954556"</span>);</span><br><span class="line">        AccessToken accessToken = <span class="keyword">this</span>.saveToken(<span class="number">1</span>, appInfo, userInfo);</span><br><span class="line">        userInfo.setAccessToken(accessToken);</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.success(userInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AccessToken saveToken(int tokenType, AppInfo appInfo,  UserInfo userInfo) &#123;</span><br><span class="line">        <span class="built_in">String</span> token = UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// token有效期为2小时</span></span><br><span class="line">        Calendar calendar = Calendar.getInstance();</span><br><span class="line">        calendar.setTime(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">        calendar.add(Calendar.SECOND, <span class="number">7200</span>);</span><br><span class="line">        <span class="built_in">Date</span> expireTime = calendar.getTime();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 保存token</span></span><br><span class="line">        ValueOperations&lt;<span class="built_in">String</span>, TokenInfo&gt; operations = redisTemplate.opsForValue();</span><br><span class="line">        TokenInfo tokenInfo = <span class="keyword">new</span> TokenInfo();</span><br><span class="line">        tokenInfo.setTokenType(tokenType);</span><br><span class="line">        tokenInfo.setAppInfo(appInfo);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tokenType == <span class="number">1</span>) &#123;</span><br><span class="line">            tokenInfo.setUserInfo(userInfo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        operations.set(token, tokenInfo, <span class="number">7200</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        AccessToken accessToken = <span class="keyword">new</span> AccessToken(token, expireTime);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> accessToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">        long timestamp = System.currentTimeMillis();</span><br><span class="line">        System.out.println(timestamp);</span><br><span class="line">        <span class="built_in">String</span> signString = timestamp + <span class="string">"1"</span> + <span class="string">"12345678954556"</span>;</span><br><span class="line">        <span class="built_in">String</span> sign = MD5Util.encode(signString);</span><br><span class="line">        System.out.println(sign);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------"</span>);</span><br><span class="line">        signString = <span class="string">"password=123456&amp;username=1&amp;12345678954556"</span> + <span class="string">"ff03e64b-427b-45a7-b78b-47d9e8597d3b1529815393153sdfsdfsfs"</span> + timestamp + <span class="string">"A1scr6"</span>;</span><br><span class="line">        sign = MD5Util.encode(signString);</span><br><span class="line">        System.out.println(sign);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4. WebMvcConfiguration  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] excludePathPatterns  = &#123;<span class="string">"/api/token/api_token"</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenInterceptor tokenInterceptor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.addInterceptors(registry);</span><br><span class="line">        registry.addInterceptor(tokenInterceptor)</span><br><span class="line">                .addPathPatterns(<span class="string">"/api/**"</span>)</span><br><span class="line">                .excludePathPatterns(excludePathPatterns);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5</span>. TokenInterceptor</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 访问的目标方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String token = request.getHeader(<span class="string">"token"</span>);</span><br><span class="line">        String timestamp = request.getHeader(<span class="string">"timestamp"</span>);</span><br><span class="line">        <span class="comment">// 随机字符串</span></span><br><span class="line">        String nonce = request.getHeader(<span class="string">"nonce"</span>);</span><br><span class="line">        String sign = request.getHeader(<span class="string">"sign"</span>);</span><br><span class="line">        Assert.isTrue(!StringUtils.isEmpty(token) &amp;&amp; !StringUtils.isEmpty(timestamp) &amp;&amp; !StringUtils.isEmpty(sign), <span class="string">"参数错误"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取超时时间</span></span><br><span class="line">        NotRepeatSubmit notRepeatSubmit = ApiUtil.getNotRepeatSubmit(handler);</span><br><span class="line">        <span class="keyword">long</span> expireTime = notRepeatSubmit == <span class="keyword">null</span> ? <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000</span> : notRepeatSubmit.value();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 请求时间间隔</span></span><br><span class="line">        <span class="keyword">long</span> reqeustInterval = System.currentTimeMillis() - Long.valueOf(timestamp);</span><br><span class="line">        Assert.isTrue(reqeustInterval &lt; expireTime, <span class="string">"请求超时，请重新请求"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 校验Token是否存在</span></span><br><span class="line">        ValueOperations&lt;String, TokenInfo&gt; tokenRedis = redisTemplate.opsForValue();</span><br><span class="line">        TokenInfo tokenInfo = tokenRedis.get(token);</span><br><span class="line">        Assert.notNull(tokenInfo, <span class="string">"token错误"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 校验签名(将所有的参数加进来，防止别人篡改参数) 所有参数看参数名升续排序拼接成url</span></span><br><span class="line">        <span class="comment">// 请求参数 + token + timestamp + nonce</span></span><br><span class="line">        String signString = ApiUtil.concatSignString(request) + tokenInfo.getAppInfo().getKey() + token + timestamp + nonce;</span><br><span class="line">        String signature = MD5Util.encode(signString);</span><br><span class="line">        <span class="keyword">boolean</span> flag = signature.equals(sign);</span><br><span class="line">        Assert.isTrue(flag, <span class="string">"签名错误"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 拒绝重复调用(第一次访问时存储，过期时间和请求超时时间保持一致), 只有标注不允许重复提交注解的才会校验</span></span><br><span class="line">        <span class="keyword">if</span> (notRepeatSubmit != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ValueOperations&lt;String, Integer&gt; signRedis = redisTemplate.opsForValue();</span><br><span class="line">            <span class="keyword">boolean</span> exists = redisTemplate.hasKey(sign);</span><br><span class="line">            Assert.isTrue(!exists, <span class="string">"请勿重复提交"</span>);</span><br><span class="line">            signRedis.set(sign, <span class="number">0</span>, expireTime, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.preHandle(request, response, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6. MD5Util —-MD5工具类，加密生成数字签名  </p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MD5Util</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final String hexDigits[] = &#123; <span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>,</span><br><span class="line">            <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">byteArrayToHexString</span>(<span class="params"><span class="keyword">byte</span> b[]</span>)</span> &#123;</span><br><span class="line">        StringBuffer resultSb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; i++)</span><br><span class="line">            resultSb.append(byteToHexString(b[i]));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultSb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">byteToHexString</span>(<span class="params"><span class="keyword">byte</span> b</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> n = b;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">            n += <span class="number">256</span>;</span><br><span class="line">        <span class="keyword">int</span> d1 = n / <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">int</span> d2 = n % <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> hexDigits[d1] + hexDigits[d2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encode</span>(<span class="params">String origin</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> encode(origin, <span class="string">"UTF-8"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encode</span>(<span class="params">String origin, String charsetname</span>)</span> &#123;</span><br><span class="line">        String resultString = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resultString = <span class="keyword">new</span> String(origin);</span><br><span class="line">            MessageDigest md = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">            <span class="keyword">if</span> (charsetname == <span class="literal">null</span> || <span class="string">""</span>.<span class="keyword">equals</span>(charsetname))</span><br><span class="line">                resultString = byteArrayToHexString(md.digest(resultString</span><br><span class="line">                        .getBytes()));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                resultString = byteArrayToHexString(md.digest(resultString</span><br><span class="line">                        .getBytes(charsetname)));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7. @NotRepeatSubmit   —–自定义注解，防止重复提交。  </p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 禁止重复提交</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> @<span class="keyword">interface</span> <span class="title">NotRepeatSubmit</span> &#123;</span><br><span class="line">    <span class="comment">/** 过期时间，单位毫秒 **/</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">value</span>(<span class="params"></span>) <span class="keyword">default</span> 5000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8. AccessToken  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> AccessToken &#123;</span><br><span class="line">    <span class="comment">/** token */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> token;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 失效时间 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">Date</span> expireTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9. AppInfo  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> AppInfo &#123;</span><br><span class="line">    <span class="comment">/** App id */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> appId;</span><br><span class="line">    <span class="comment">/** API 秘钥 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>10. TokenInfo  </p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TokenInfo</span> &#123;</span><br><span class="line">    <span class="comment">/** token类型: api:0 、user:1 */</span></span><br><span class="line">    <span class="keyword">private</span> Integer tokenType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** App 信息 */</span></span><br><span class="line">    <span class="keyword">private</span> AppInfo appInfo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用户其他数据 */</span></span><br><span class="line">    <span class="keyword">private</span> UserInfo userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>11. UserInfo  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> UserInfo &#123;</span><br><span class="line">    <span class="comment">/** 用户名 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> username;</span><br><span class="line">    <span class="comment">/** 手机号 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> mobile;</span><br><span class="line">    <span class="comment">/** 邮箱 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> email;</span><br><span class="line">    <span class="comment">/** 密码 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> password;</span><br><span class="line">    <span class="comment">/** 盐 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> salt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AccessToken accessToken;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UserInfo(<span class="built_in">String</span> username, <span class="built_in">String</span> password, <span class="built_in">String</span> salt) &#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">        <span class="keyword">this</span>.salt = salt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>12. ApiCodeEnum  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误码code可以使用纯数字,使用不同区间标识一类错误，也可以使用纯字符，也可以使用前缀+编号</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 错误码：ERR + 编号</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 可以使用日志级别的前缀作为错误类型区分 Info(I) Error(E) Warning(W)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 或者以业务模块 + 错误号</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * TODO 错误码设计</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Alipay 用了两个code，两个msg(https://docs.open.alipay.com/api_1/alipay.trade.pay)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ApiCodeEnum &#123;</span><br><span class="line">    SUCCESS(<span class="string">"10000"</span>, <span class="string">"success"</span>),</span><br><span class="line">    UNKNOW_ERROR(<span class="string">"ERR0001"</span>,<span class="string">"未知错误"</span>),</span><br><span class="line">    PARAMETER_ERROR(<span class="string">"ERR0002"</span>,<span class="string">"参数错误"</span>),</span><br><span class="line">    TOKEN_EXPIRE(<span class="string">"ERR0003"</span>,<span class="string">"认证过期"</span>),</span><br><span class="line">    REQUEST_TIMEOUT(<span class="string">"ERR0004"</span>,<span class="string">"请求超时"</span>),</span><br><span class="line">    SIGN_ERROR(<span class="string">"ERR0005"</span>,<span class="string">"签名错误"</span>),</span><br><span class="line">    REPEAT_SUBMIT(<span class="string">"ERR0006"</span>,<span class="string">"请不要频繁操作"</span>),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 代码 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> code;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 结果 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> msg;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ApiCodeEnum(<span class="built_in">String</span> code, <span class="built_in">String</span> msg) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> getCode() &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> getMsg() &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>13. ApiResult  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> ApiResult &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 代码 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> code;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 结果 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>14. ApiUtil  ——-这个参考支付宝加密的算法写的.我直接Copy过来了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ApiUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按参数名升续拼接参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="variable">request</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public <span class="keyword">static</span> <span class="built_in">String</span> concatSignString(HttpServletRequest request) &#123;</span><br><span class="line">        <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; paramterMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        request.getParameterMap().forEach((key, value) -&gt; paramterMap.put(key, value[<span class="number">0</span>]));</span><br><span class="line">        <span class="comment">// 按照key升续排序，然后拼接参数</span></span><br><span class="line">        <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; keySet = paramterMap.keySet();</span><br><span class="line">        <span class="built_in">String</span>[] keyArray = keySet.toArray(<span class="keyword">new</span> <span class="built_in">String</span>[keySet.size()]);</span><br><span class="line">        Arrays.sort(keyArray);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">String</span> k : keyArray) &#123;</span><br><span class="line">            <span class="comment">// 或略掉的字段</span></span><br><span class="line">            <span class="keyword">if</span> (k.equals(<span class="string">"sign"</span>)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (paramterMap.get(k).trim().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 参数值为空，则不参与签名</span></span><br><span class="line">                sb.append(k).append(<span class="string">"="</span>).append(paramterMap.get(k).trim()).append(<span class="string">"&amp;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="built_in">String</span> concatSignString(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; map) &#123;</span><br><span class="line">        <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; paramterMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.forEach((key, value) -&gt; paramterMap.put(key, value));</span><br><span class="line">        <span class="comment">// 按照key升续排序，然后拼接参数</span></span><br><span class="line">        <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; keySet = paramterMap.keySet();</span><br><span class="line">        <span class="built_in">String</span>[] keyArray = keySet.toArray(<span class="keyword">new</span> <span class="built_in">String</span>[keySet.size()]);</span><br><span class="line">        Arrays.sort(keyArray);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">String</span> k : keyArray) &#123;</span><br><span class="line">            <span class="keyword">if</span> (paramterMap.get(k).trim().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 参数值为空，则不参与签名</span></span><br><span class="line">                sb.append(k).append(<span class="string">"="</span>).append(paramterMap.get(k).trim()).append(<span class="string">"&amp;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取方法上的<span class="doctag">@NotRepeatSubmit</span>注解</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="variable">handler</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public <span class="keyword">static</span> NotRepeatSubmit getNotRepeatSubmit(<span class="built_in">Object</span> handler) &#123;</span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> HandlerMethod) &#123;</span><br><span class="line">            HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">            Method method = handlerMethod.getMethod();</span><br><span class="line">            NotRepeatSubmit annotation = method.getAnnotation(NotRepeatSubmit.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> annotation;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>15. ApiResponse</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> ApiResponse&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/** 结果 */</span></span><br><span class="line">    <span class="keyword">private</span> ApiResult result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 数据 */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 签名 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> sign;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ApiResponse success(T data) &#123;</span><br><span class="line">        <span class="keyword">return</span> response(ApiCodeEnum.SUCCESS.getCode(), ApiCodeEnum.SUCCESS.getMsg(), data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ApiResponse error(<span class="built_in">String</span> code, <span class="built_in">String</span> msg) &#123;</span><br><span class="line">        <span class="keyword">return</span> response(code, msg, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ApiResponse response(<span class="built_in">String</span> code, <span class="built_in">String</span> msg, T data) &#123;</span><br><span class="line">        ApiResult result = <span class="keyword">new</span> ApiResult(code, msg);</span><br><span class="line">        ApiResponse response = <span class="keyword">new</span> ApiResponse();</span><br><span class="line">        response.setResult(result);</span><br><span class="line">        response.setData(data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">String</span> sign = signData(data);</span><br><span class="line">        response.setSign(sign);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="built_in">String</span> signData(T data) &#123;</span><br><span class="line">        <span class="comment">// TODO 查询key</span></span><br><span class="line">        <span class="built_in">String</span> key = <span class="string">"12345678954556"</span>;</span><br><span class="line">        Map&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; responseMap = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            responseMap = getFields(data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">String</span> urlComponent = ApiUtil.concatSignString(responseMap);</span><br><span class="line">        <span class="built_in">String</span> signature = urlComponent + <span class="string">"key="</span> + key;</span><br><span class="line">        <span class="built_in">String</span> sign = MD5Util.encode(signature);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sign;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param data 反射的对象,获取对象的字段名和值</span></span><br><span class="line"><span class="comment">     * @throws IllegalArgumentException</span></span><br><span class="line"><span class="comment">     * @throws IllegalAccessException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; getFields(<span class="built_in">Object</span> data) throws IllegalAccessException, IllegalArgumentException &#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        Map&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Field[] fields = data.getClass().getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">            Field field = fields[i];</span><br><span class="line">            field.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="built_in">String</span> name = field.getName();</span><br><span class="line">            <span class="built_in">Object</span> value = field.get(data);</span><br><span class="line">            <span class="keyword">if</span> (field.get(data) != <span class="literal">null</span>) &#123;</span><br><span class="line">                map.put(name, value.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>七、ThreadLocal</strong><br>ThreadLocal是线程内的全局上下文。就是在单个线程中，方法之间共享的内存，每个方法都可以从该上下文中获取值和修改值。<br>实际案例：<br>在调用api时都会传一个token参数，通常会写一个拦截器来校验token是否合法，我们可以通过token找到对应的用户信息(User)，如果token合法，然后将用户信息存储到ThreadLocal中，这样无论是在controller、service、dao的哪一层都能访问到该用户的信息。作用类似于Web中的request作用域。<br>传统方式我们要在方法中访问某个变量，可以通过传参的形式往方法中传参，如果多个方法都要使用那么每个方法都要传参；如果使用ThreadLocal所有方法就不需要传该参数了，每个方法都可以通过ThreadLocal来访问该值。  </p><ul><li><p>ThreadLocalUtil.set(“key”, value); 保存值</p></li><li><p>T value = ThreadLocalUtil.get(“key”); 获取值</p></li></ul><p>ThreadLocalUtil</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalUtil</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    private <span class="keyword">static</span> final ThreadLocal&lt;<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt;&gt; threadLocal = <span class="keyword">new</span> ThreadLocal() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; initialValue() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; getThreadLocal()&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> &lt;T&gt; T <span class="keyword">get</span>(String key) &#123;</span><br><span class="line">        <span class="built_in">Map</span> map = (<span class="built_in">Map</span>)threadLocal.get();</span><br><span class="line">        <span class="keyword">return</span> (T)map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> &lt;T&gt; T <span class="keyword">get</span>(String key,T defaultValue) &#123;</span><br><span class="line">        <span class="built_in">Map</span> map = (<span class="built_in">Map</span>)threadLocal.get();</span><br><span class="line">        <span class="keyword">return</span> (T)map.get(key) == <span class="literal">null</span> ? defaultValue : (T)map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">set</span>(String key, Object value) &#123;</span><br><span class="line">        <span class="built_in">Map</span> map = (<span class="built_in">Map</span>)threadLocal.get();</span><br><span class="line">        map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">set</span>(Map&lt;String, Object&gt; keyValueMap) &#123;</span><br><span class="line">        <span class="built_in">Map</span> map = (<span class="built_in">Map</span>)threadLocal.get();</span><br><span class="line">        map.putAll(keyValueMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> remove() &#123;</span><br><span class="line">        threadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> &lt;T&gt; <span class="built_in">Map</span>&lt;<span class="built_in">String</span>,T&gt; fetchVarsByPrefix(<span class="built_in">String</span> prefix) &#123;</span><br><span class="line">        <span class="built_in">Map</span>&lt;<span class="built_in">String</span>,T&gt; vars = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>( prefix == <span class="literal">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> vars;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Map</span> map = (<span class="built_in">Map</span>)threadLocal.get();</span><br><span class="line">        <span class="built_in">Set</span>&lt;<span class="built_in">Map</span>.Entry&gt; <span class="keyword">set</span> = map.entrySet();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for( Map.Entry entry : <span class="keyword">set</span>)&#123;</span><br><span class="line">            <span class="built_in">Object</span> key = entry.getKey();</span><br><span class="line">            <span class="keyword">if</span>( key <span class="keyword">instanceof</span> <span class="built_in">String</span> )&#123;</span><br><span class="line">                <span class="keyword">if</span>( ((<span class="built_in">String</span>) key).startsWith(prefix) )&#123;</span><br><span class="line">                    vars.put((<span class="built_in">String</span>)key,(T)entry.getValue());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vars;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> &lt;T&gt; T remove(<span class="built_in">String</span> key) &#123;</span><br><span class="line">        <span class="built_in">Map</span> map = (<span class="built_in">Map</span>)threadLocal.get();</span><br><span class="line">        <span class="keyword">return</span> (T)map.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> clear(<span class="built_in">String</span> prefix) &#123;</span><br><span class="line">        <span class="keyword">if</span>( prefix == <span class="literal">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Map</span> map = (<span class="built_in">Map</span>)threadLocal.get();</span><br><span class="line">        <span class="built_in">Set</span>&lt;<span class="built_in">Map</span>.Entry&gt; <span class="keyword">set</span> = map.entrySet();</span><br><span class="line">        List&lt;String&gt; removeKeys = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for( Map.Entry entry : <span class="keyword">set</span> )&#123;</span><br><span class="line">            <span class="built_in">Object</span> key = entry.getKey();</span><br><span class="line">            <span class="keyword">if</span>( key <span class="keyword">instanceof</span> <span class="built_in">String</span> )&#123;</span><br><span class="line">                <span class="keyword">if</span>( ((<span class="built_in">String</span>) key).startsWith(prefix) )&#123;</span><br><span class="line">                    removeKeys.add((<span class="built_in">String</span>)key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( <span class="built_in">String</span> key : removeKeys )&#123;</span><br><span class="line">            map.remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结:这个是目前第三方数据接口交互过程中常用的一些参数与使用示例，希望对大家有点帮助。<br>当然如果为了保证更加的安全，可以加上RSA,RSA2，AES等等加密方式，保证了数据的更加的安全，但是唯一的缺点是加密与解密比较耗费CPU的资源。  </p><blockquote><p>来源：<a href="https://www.cnblogs.com/jurendage/p/12653865.html" target="_blank" rel="noopener">https://www.cnblogs.com/jurendage/p/12653865.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在实际的业务中，难免会跟第三方系统进行数据的交互与传递，那么如何保证数据在传输过程中的安全呢（防窃取）？除了https的协议之外，能不能加上通用的一套算法以及规范来保证传输的安全性呢？  &lt;/p&gt;
&lt;p&gt;下面我们就来讨论下常用的一些API设计的安全方法，可能不一定是最好的，
      
    
    </summary>
    
    
    
      <category term="JAVA安全" scheme="https://kanchai.club/tags/JAVA%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>谈谈关于缓存穿透，缓存击穿，缓存雪崩，热点数据失效问题的解决方案</title>
    <link href="https://kanchai.club/2020/04/20/%E8%B0%88%E8%B0%88%E5%85%B3%E4%BA%8E%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%8C%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://kanchai.club/2020/04/20/%E8%B0%88%E8%B0%88%E5%85%B3%E4%BA%8E%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%8C%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2020-04-20T02:42:53.764Z</published>
    <updated>2020-04-20T02:42:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Tom-shushu</p><p>cnblogs.com/Tom-shushu/p/10636382.html</p></blockquote><h2 id="1-我们使用缓存时的业务流程大概为："><a href="#1-我们使用缓存时的业务流程大概为：" class="headerlink" title="1.我们使用缓存时的业务流程大概为："></a>1.我们使用缓存时的业务流程大概为：</h2><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/04/java10-1586143832.png" alt="面试官：谈谈关于缓存穿透，缓存击穿，缓存雪崩，热点数据失效问题的解决方案" title="面试官：谈谈关于缓存穿透，缓存击穿，缓存雪崩，热点数据失效问题的解决方案"></p><p>当我们查询一条数据时，先去查询缓存，如果缓存有就直接返回，如果没有就去查询数据库，然后返回。这种情况下就可能出现下面的一些现象。</p><h2 id="2-缓存穿透"><a href="#2-缓存穿透" class="headerlink" title="2.缓存穿透"></a>2.缓存穿透</h2><h3 id="2-1什么是缓存穿透"><a href="#2-1什么是缓存穿透" class="headerlink" title="2.1什么是缓存穿透"></a>2.1什么是缓存穿透</h3><p>缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。</p><h3 id="2-2缓存穿透带来的问题"><a href="#2-2缓存穿透带来的问题" class="headerlink" title="2.2缓存穿透带来的问题"></a>2.2缓存穿透带来的问题</h3><p>试想一下，如果有黑客对你的系统进行攻击，拿一个不存在的id去查询数据，会产生大量的请求到你的数据库去查询，可能会导致你的数据库由于压力过大而宕掉。</p><h3 id="2-3解决的办法"><a href="#2-3解决的办法" class="headerlink" title="2.3解决的办法"></a>2.3解决的办法</h3><h4 id="2-3-1缓存空值"><a href="#2-3-1缓存空值" class="headerlink" title="2.3.1缓存空值"></a>2.3.1缓存空值</h4><p>之所以会发生穿透，就是因为缓存中没有储存这些空数据的key。从而导致每次查询都到数据库去了。</p><p>那么我们就可以为这些key对应的值设置为null丢到缓存里面去。后面出现查询这个key的请求的时候直接返回null。</p><p>这样就不用再到数据库中去走一圈了，但是别忘了设置过期时间。</p><p>缓存空对象会有两个问题：</p><ul><li><p>第一，空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间 ( 如果是攻击，问题更严重 )，比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。</p></li><li><p>第二，缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。例如过期时间设置为 5分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致，此时可以利用消息系统或者其他方式清除掉缓存层中的空对象。</p></li></ul><h4 id="2-3-2用布隆过滤器BloomFilter"><a href="#2-3-2用布隆过滤器BloomFilter" class="headerlink" title="2.3.2用布隆过滤器BloomFilter"></a>2.3.2用布隆过滤器BloomFilter</h4><p>BloomFilter类似于一个hbase set用来判断某个元素(key)是否存在于某个集合中。</p><p>这种方式在大数据场景应用比较多，比如Hbase中使用它去判断数据是否在磁盘上。还有在爬虫场景判断url是否已经被爬取过。</p><p>这种方案可以加在第一种方案中，在缓存之前加一层BloomFilter，在查询的时候先去BloomFilter去查询key是否存在，如果不存在就直接返回，存在再去查缓存——–&gt;差数据库。</p><p>流程图如下：</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/04/java6-1586143832-1.png" alt="面试官：谈谈关于缓存穿透，缓存击穿，缓存雪崩，热点数据失效问题的解决方案" title="面试官：谈谈关于缓存穿透，缓存击穿，缓存雪崩，热点数据失效问题的解决方案"></p><h3 id="2-4如何选择"><a href="#2-4如何选择" class="headerlink" title="2.4如何选择"></a>2.4如何选择</h3><p>针对于一些恶意攻击，攻击带来大量key是不存在的，那么我们采用第一种方案就会缓存大量不存在的数据。此时我们采用第一种方案就不合适了，我们完全可以先使用第二种方案过滤掉这些key。</p><p>针对这些key异常多，请求多，重复率比较低的数据，我们就没有必要进行缓存，使用第二种方案直接过滤掉。</p><p>而对于空数据的key有限的，重复率比较高的，我们则可以采用第一种方式进行缓存。</p><h2 id="3-缓存击穿"><a href="#3-缓存击穿" class="headerlink" title="3.缓存击穿"></a>3.缓存击穿</h2><h3 id="3-1什么是缓存击穿"><a href="#3-1什么是缓存击穿" class="headerlink" title="3.1什么是缓存击穿"></a>3.1什么是缓存击穿</h3><p>缓存击穿是我们使用缓存可能遇到的第二个问题。</p><p>在平时高并发的系统中，大量的请求同时查询一个key时，此时这个key正好失效了，就会导致大量的请求都打到数据库上面去，这种现象我们称为缓存击穿。</p><h3 id="3-2会带来什么问题"><a href="#3-2会带来什么问题" class="headerlink" title="3.2会带来什么问题"></a>3.2会带来什么问题</h3><p>会造成某一时刻数据请求量过大，压力剧增。</p><h3 id="3-3如何解决"><a href="#3-3如何解决" class="headerlink" title="3.3如何解决"></a>3.3如何解决</h3><p>上面现象是多个线程同时去查询数据库的这一条数据，那么我们可以在第一个查询数据的请求上使用一个互斥锁来锁住它。（如果是单机，可以用synchronized或者lock来处理，如果是分布式环境可以用分布式锁就可以了（分布式锁，可以用memcache的add, redis的setnx, zookeeper的添加节点操作））</p><p>其他线程走到这一步拿不到锁就等着，等待第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有了缓存，就直接走缓存。</p><h2 id="4-缓存雪崩"><a href="#4-缓存雪崩" class="headerlink" title="4.缓存雪崩"></a>4.缓存雪崩</h2><h3 id="4-1什么是缓存雪崩"><a href="#4-1什么是缓存雪崩" class="headerlink" title="4.1什么是缓存雪崩"></a>4.1什么是缓存雪崩</h3><p>缓存雪崩的情况是指：当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了，会有大量的请求进来直接打到数据库上面，结果就是数据库挂掉。</p><p><img src="https://www.javazhiyin.com/wp-content/uploads/2020/04/java9-1586143832.png" alt="面试官：谈谈关于缓存穿透，缓存击穿，缓存雪崩，热点数据失效问题的解决方案" title="面试官：谈谈关于缓存穿透，缓存击穿，缓存雪崩，热点数据失效问题的解决方案"></p><h3 id="4-2解决办法"><a href="#4-2解决办法" class="headerlink" title="4.2解决办法"></a>4.2解决办法</h3><h4 id="4-2-1雪崩前：使用集群缓存，保证缓存服务的高可用"><a href="#4-2-1雪崩前：使用集群缓存，保证缓存服务的高可用" class="headerlink" title="4.2.1雪崩前：使用集群缓存，保证缓存服务的高可用"></a>4.2.1雪崩前：使用集群缓存，保证缓存服务的高可用</h4><p>这种方案就是在发生雪崩前对缓存集群，实现高可用，如果是使用Redis，可以使用（主从 + 哨兵），Redis Cluster来避免Redis全盘崩溃的情况。</p><h4 id="4-2-2雪崩中：ehcache本地缓存-Hystrix限流-amp-降级，避免MySQl被打死"><a href="#4-2-2雪崩中：ehcache本地缓存-Hystrix限流-amp-降级，避免MySQl被打死" class="headerlink" title="4.2.2雪崩中：ehcache本地缓存 + Hystrix限流 &amp; 降级，避免MySQl被打死"></a>4.2.2雪崩中：ehcache本地缓存 + Hystrix限流 &amp; 降级，避免MySQl被打死</h4><p>使用ehcache本地缓存的目的也是考虑Redis Cluster完全不可用的时候，ehcache本地缓存还能够支撑一阵。</p><p>使用Hystrix进行限流 &amp; 降级，比如一秒来了5000个请求，我们可以设置假设一秒只能有2000个请求可以通过这个组件，那么其他剩余的3000请求就会走限流逻辑。</p><p>然后去调用我们自己开发的降级组件（降级）,比如设置的一些默认值等等之类的。以此来保护最后的MySQl不会被大量的请求打死。</p><h4 id="4-2-3雪崩后：开启Redis持久化，尽快恢复缓存集群。"><a href="#4-2-3雪崩后：开启Redis持久化，尽快恢复缓存集群。" class="headerlink" title="4.2.3雪崩后：开启Redis持久化，尽快恢复缓存集群。"></a>4.2.3雪崩后：开启Redis持久化，尽快恢复缓存集群。</h4><h2 id="5-解决热点数据集中失效问题"><a href="#5-解决热点数据集中失效问题" class="headerlink" title="5.解决热点数据集中失效问题"></a>5.解决热点数据集中失效问题</h2><p>我们在设置缓存的时候，一般会给缓存设置一个失效的时间，过了这个时间，缓存就失效了。</p><p>对于一些热点数据来说，当缓存失效后会存在大量的请求到数据库上来，从而可能导致数据库崩溃的情况。</p><h3 id="5-1解决办法"><a href="#5-1解决办法" class="headerlink" title="5.1解决办法"></a>5.1解决办法</h3><h4 id="5-1-1设置不同的失效时间"><a href="#5-1-1设置不同的失效时间" class="headerlink" title="5.1.1设置不同的失效时间"></a>5.1.1设置不同的失效时间</h4><p>为了避免这些热点数据集体失效，那么我们在设置缓存过期时间的时侯，让他们失效的时间错开。比如我们可以在原有的失效时间基础上增加一个随机值。</p><h4 id="5-1-2互斥锁"><a href="#5-1-2互斥锁" class="headerlink" title="5.1.2互斥锁"></a>5.1.2互斥锁</h4><p>结合上面的击穿情况，在第一个请求去查询数据库的时候对它加一个互斥锁，其余的查询请求都会被阻塞住，直到锁被释放，从而保护数据库。</p><p>但是也是由于它会阻塞其他线程，此时系统的吞吐量会下降。需要结合实际业务去考虑。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;作者：Tom-shushu&lt;/p&gt;
&lt;p&gt;cnblogs.com/Tom-shushu/p/10636382.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-我们使用缓存时的业务流程大概为：&quot;&gt;&lt;a href=&quot;#1-我们使用缓存
      
    
    </summary>
    
    
    
      <category term="JAVA缓存" scheme="https://kanchai.club/tags/JAVA%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
</feed>
